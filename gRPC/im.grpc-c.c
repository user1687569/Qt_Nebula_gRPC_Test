/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: im.proto */

/* Do not generate deprecated warnings for self */
#ifndef PROTOBUF_C__NO_DEPRECATED
#define PROTOBUF_C__NO_DEPRECATED
#endif

#include "im.grpc-c.h"
void   g_im__im_cmd_head__init
                     (GIm__ImCmdHead         *message)
{
  static const GIm__ImCmdHead init_value = G_IM__IM_CMD_HEAD__INIT;
  *message = init_value;
}
size_t g_im__im_cmd_head__get_packed_size
                     (const GIm__ImCmdHead *message)
{
  assert(message->base.descriptor == &g_im__im_cmd_head__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_cmd_head__pack
                     (const GIm__ImCmdHead *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_cmd_head__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_cmd_head__pack_to_buffer
                     (const GIm__ImCmdHead *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_cmd_head__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImCmdHead *
       g_im__im_cmd_head__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImCmdHead *)
     protobuf_c_message_unpack (&g_im__im_cmd_head__descriptor,
                                allocator, len, data);
}
void   g_im__im_cmd_head__free_unpacked
                     (GIm__ImCmdHead *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_cmd_head__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_auth__init
                     (GIm__ImAuth         *message)
{
  static const GIm__ImAuth init_value = G_IM__IM_AUTH__INIT;
  *message = init_value;
}
size_t g_im__im_auth__get_packed_size
                     (const GIm__ImAuth *message)
{
  assert(message->base.descriptor == &g_im__im_auth__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_auth__pack
                     (const GIm__ImAuth *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_auth__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_auth__pack_to_buffer
                     (const GIm__ImAuth *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_auth__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImAuth *
       g_im__im_auth__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImAuth *)
     protobuf_c_message_unpack (&g_im__im_auth__descriptor,
                                allocator, len, data);
}
void   g_im__im_auth__free_unpacked
                     (GIm__ImAuth *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_auth__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_data_store4unit__init
                     (GIm__ImDataStore4unit         *message)
{
  static const GIm__ImDataStore4unit init_value = G_IM__IM_DATA_STORE4UNIT__INIT;
  *message = init_value;
}
size_t g_im__im_data_store4unit__get_packed_size
                     (const GIm__ImDataStore4unit *message)
{
  assert(message->base.descriptor == &g_im__im_data_store4unit__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_data_store4unit__pack
                     (const GIm__ImDataStore4unit *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_data_store4unit__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_data_store4unit__pack_to_buffer
                     (const GIm__ImDataStore4unit *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_data_store4unit__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImDataStore4unit *
       g_im__im_data_store4unit__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImDataStore4unit *)
     protobuf_c_message_unpack (&g_im__im_data_store4unit__descriptor,
                                allocator, len, data);
}
void   g_im__im_data_store4unit__free_unpacked
                     (GIm__ImDataStore4unit *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_data_store4unit__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_data_store4alarm__init
                     (GIm__ImDataStore4alarm         *message)
{
  static const GIm__ImDataStore4alarm init_value = G_IM__IM_DATA_STORE4ALARM__INIT;
  *message = init_value;
}
size_t g_im__im_data_store4alarm__get_packed_size
                     (const GIm__ImDataStore4alarm *message)
{
  assert(message->base.descriptor == &g_im__im_data_store4alarm__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_data_store4alarm__pack
                     (const GIm__ImDataStore4alarm *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_data_store4alarm__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_data_store4alarm__pack_to_buffer
                     (const GIm__ImDataStore4alarm *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_data_store4alarm__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImDataStore4alarm *
       g_im__im_data_store4alarm__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImDataStore4alarm *)
     protobuf_c_message_unpack (&g_im__im_data_store4alarm__descriptor,
                                allocator, len, data);
}
void   g_im__im_data_store4alarm__free_unpacked
                     (GIm__ImDataStore4alarm *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_data_store4alarm__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__smoke_item__init
                     (GIm__SmokeItem         *message)
{
  static const GIm__SmokeItem init_value = G_IM__SMOKE_ITEM__INIT;
  *message = init_value;
}
size_t g_im__smoke_item__get_packed_size
                     (const GIm__SmokeItem *message)
{
  assert(message->base.descriptor == &g_im__smoke_item__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__smoke_item__pack
                     (const GIm__SmokeItem *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__smoke_item__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__smoke_item__pack_to_buffer
                     (const GIm__SmokeItem *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__smoke_item__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__SmokeItem *
       g_im__smoke_item__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__SmokeItem *)
     protobuf_c_message_unpack (&g_im__smoke_item__descriptor,
                                allocator, len, data);
}
void   g_im__smoke_item__free_unpacked
                     (GIm__SmokeItem *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__smoke_item__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__smoke_data__init
                     (GIm__SmokeData         *message)
{
  static const GIm__SmokeData init_value = G_IM__SMOKE_DATA__INIT;
  *message = init_value;
}
size_t g_im__smoke_data__get_packed_size
                     (const GIm__SmokeData *message)
{
  assert(message->base.descriptor == &g_im__smoke_data__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__smoke_data__pack
                     (const GIm__SmokeData *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__smoke_data__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__smoke_data__pack_to_buffer
                     (const GIm__SmokeData *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__smoke_data__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__SmokeData *
       g_im__smoke_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__SmokeData *)
     protobuf_c_message_unpack (&g_im__smoke_data__descriptor,
                                allocator, len, data);
}
void   g_im__smoke_data__free_unpacked
                     (GIm__SmokeData *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__smoke_data__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_co_item__init
                     (GIm__ImCoItem         *message)
{
  static const GIm__ImCoItem init_value = G_IM__IM_CO_ITEM__INIT;
  *message = init_value;
}
size_t g_im__im_co_item__get_packed_size
                     (const GIm__ImCoItem *message)
{
  assert(message->base.descriptor == &g_im__im_co_item__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_co_item__pack
                     (const GIm__ImCoItem *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_co_item__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_co_item__pack_to_buffer
                     (const GIm__ImCoItem *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_co_item__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImCoItem *
       g_im__im_co_item__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImCoItem *)
     protobuf_c_message_unpack (&g_im__im_co_item__descriptor,
                                allocator, len, data);
}
void   g_im__im_co_item__free_unpacked
                     (GIm__ImCoItem *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_co_item__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_co_data__init
                     (GIm__ImCoData         *message)
{
  static const GIm__ImCoData init_value = G_IM__IM_CO_DATA__INIT;
  *message = init_value;
}
size_t g_im__im_co_data__get_packed_size
                     (const GIm__ImCoData *message)
{
  assert(message->base.descriptor == &g_im__im_co_data__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_co_data__pack
                     (const GIm__ImCoData *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_co_data__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_co_data__pack_to_buffer
                     (const GIm__ImCoData *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_co_data__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImCoData *
       g_im__im_co_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImCoData *)
     protobuf_c_message_unpack (&g_im__im_co_data__descriptor,
                                allocator, len, data);
}
void   g_im__im_co_data__free_unpacked
                     (GIm__ImCoData *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_co_data__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_fan__item__init
                     (GIm__ImFanItem         *message)
{
  static const GIm__ImFanItem init_value = G_IM__IM_FAN__ITEM__INIT;
  *message = init_value;
}
size_t g_im__im_fan__item__get_packed_size
                     (const GIm__ImFanItem *message)
{
  assert(message->base.descriptor == &g_im__im_fan__item__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_fan__item__pack
                     (const GIm__ImFanItem *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_fan__item__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_fan__item__pack_to_buffer
                     (const GIm__ImFanItem *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_fan__item__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImFanItem *
       g_im__im_fan__item__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImFanItem *)
     protobuf_c_message_unpack (&g_im__im_fan__item__descriptor,
                                allocator, len, data);
}
void   g_im__im_fan__item__free_unpacked
                     (GIm__ImFanItem *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_fan__item__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_fan_data__init
                     (GIm__ImFanData         *message)
{
  static const GIm__ImFanData init_value = G_IM__IM_FAN_DATA__INIT;
  *message = init_value;
}
size_t g_im__im_fan_data__get_packed_size
                     (const GIm__ImFanData *message)
{
  assert(message->base.descriptor == &g_im__im_fan_data__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_fan_data__pack
                     (const GIm__ImFanData *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_fan_data__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_fan_data__pack_to_buffer
                     (const GIm__ImFanData *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_fan_data__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImFanData *
       g_im__im_fan_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImFanData *)
     protobuf_c_message_unpack (&g_im__im_fan_data__descriptor,
                                allocator, len, data);
}
void   g_im__im_fan_data__free_unpacked
                     (GIm__ImFanData *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_fan_data__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_temp_item__init
                     (GIm__ImTempItem         *message)
{
  static const GIm__ImTempItem init_value = G_IM__IM_TEMP_ITEM__INIT;
  *message = init_value;
}
size_t g_im__im_temp_item__get_packed_size
                     (const GIm__ImTempItem *message)
{
  assert(message->base.descriptor == &g_im__im_temp_item__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_temp_item__pack
                     (const GIm__ImTempItem *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_temp_item__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_temp_item__pack_to_buffer
                     (const GIm__ImTempItem *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_temp_item__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImTempItem *
       g_im__im_temp_item__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImTempItem *)
     protobuf_c_message_unpack (&g_im__im_temp_item__descriptor,
                                allocator, len, data);
}
void   g_im__im_temp_item__free_unpacked
                     (GIm__ImTempItem *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_temp_item__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__env_temp_data__init
                     (GIm__EnvTempData         *message)
{
  static const GIm__EnvTempData init_value = G_IM__ENV_TEMP_DATA__INIT;
  *message = init_value;
}
size_t g_im__env_temp_data__get_packed_size
                     (const GIm__EnvTempData *message)
{
  assert(message->base.descriptor == &g_im__env_temp_data__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__env_temp_data__pack
                     (const GIm__EnvTempData *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__env_temp_data__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__env_temp_data__pack_to_buffer
                     (const GIm__EnvTempData *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__env_temp_data__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__EnvTempData *
       g_im__env_temp_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__EnvTempData *)
     protobuf_c_message_unpack (&g_im__env_temp_data__descriptor,
                                allocator, len, data);
}
void   g_im__env_temp_data__free_unpacked
                     (GIm__EnvTempData *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__env_temp_data__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__negativepressure_data__init
                     (GIm__NegativepressureData         *message)
{
  static const GIm__NegativepressureData init_value = G_IM__NEGATIVEPRESSURE_DATA__INIT;
  *message = init_value;
}
size_t g_im__negativepressure_data__get_packed_size
                     (const GIm__NegativepressureData *message)
{
  assert(message->base.descriptor == &g_im__negativepressure_data__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__negativepressure_data__pack
                     (const GIm__NegativepressureData *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__negativepressure_data__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__negativepressure_data__pack_to_buffer
                     (const GIm__NegativepressureData *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__negativepressure_data__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__NegativepressureData *
       g_im__negativepressure_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__NegativepressureData *)
     protobuf_c_message_unpack (&g_im__negativepressure_data__descriptor,
                                allocator, len, data);
}
void   g_im__negativepressure_data__free_unpacked
                     (GIm__NegativepressureData *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__negativepressure_data__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__alarm_param_data__init
                     (GIm__AlarmParamData         *message)
{
  static const GIm__AlarmParamData init_value = G_IM__ALARM_PARAM_DATA__INIT;
  *message = init_value;
}
size_t g_im__alarm_param_data__get_packed_size
                     (const GIm__AlarmParamData *message)
{
  assert(message->base.descriptor == &g_im__alarm_param_data__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__alarm_param_data__pack
                     (const GIm__AlarmParamData *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__alarm_param_data__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__alarm_param_data__pack_to_buffer
                     (const GIm__AlarmParamData *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__alarm_param_data__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__AlarmParamData *
       g_im__alarm_param_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__AlarmParamData *)
     protobuf_c_message_unpack (&g_im__alarm_param_data__descriptor,
                                allocator, len, data);
}
void   g_im__alarm_param_data__free_unpacked
                     (GIm__AlarmParamData *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__alarm_param_data__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__alarm_set_param_data__init
                     (GIm__AlarmSetParamData         *message)
{
  static const GIm__AlarmSetParamData init_value = G_IM__ALARM_SET_PARAM_DATA__INIT;
  *message = init_value;
}
size_t g_im__alarm_set_param_data__get_packed_size
                     (const GIm__AlarmSetParamData *message)
{
  assert(message->base.descriptor == &g_im__alarm_set_param_data__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__alarm_set_param_data__pack
                     (const GIm__AlarmSetParamData *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__alarm_set_param_data__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__alarm_set_param_data__pack_to_buffer
                     (const GIm__AlarmSetParamData *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__alarm_set_param_data__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__AlarmSetParamData *
       g_im__alarm_set_param_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__AlarmSetParamData *)
     protobuf_c_message_unpack (&g_im__alarm_set_param_data__descriptor,
                                allocator, len, data);
}
void   g_im__alarm_set_param_data__free_unpacked
                     (GIm__AlarmSetParamData *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__alarm_set_param_data__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__serucrity_alarm_data__init
                     (GIm__SerucrityAlarmData         *message)
{
  static const GIm__SerucrityAlarmData init_value = G_IM__SERUCRITY_ALARM_DATA__INIT;
  *message = init_value;
}
size_t g_im__serucrity_alarm_data__get_packed_size
                     (const GIm__SerucrityAlarmData *message)
{
  assert(message->base.descriptor == &g_im__serucrity_alarm_data__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__serucrity_alarm_data__pack
                     (const GIm__SerucrityAlarmData *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__serucrity_alarm_data__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__serucrity_alarm_data__pack_to_buffer
                     (const GIm__SerucrityAlarmData *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__serucrity_alarm_data__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__SerucrityAlarmData *
       g_im__serucrity_alarm_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__SerucrityAlarmData *)
     protobuf_c_message_unpack (&g_im__serucrity_alarm_data__descriptor,
                                allocator, len, data);
}
void   g_im__serucrity_alarm_data__free_unpacked
                     (GIm__SerucrityAlarmData *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__serucrity_alarm_data__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__serucrity_combination_alarm_data__init
                     (GIm__SerucrityCombinationAlarmData         *message)
{
  static const GIm__SerucrityCombinationAlarmData init_value = G_IM__SERUCRITY_COMBINATION_ALARM_DATA__INIT;
  *message = init_value;
}
size_t g_im__serucrity_combination_alarm_data__get_packed_size
                     (const GIm__SerucrityCombinationAlarmData *message)
{
  assert(message->base.descriptor == &g_im__serucrity_combination_alarm_data__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__serucrity_combination_alarm_data__pack
                     (const GIm__SerucrityCombinationAlarmData *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__serucrity_combination_alarm_data__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__serucrity_combination_alarm_data__pack_to_buffer
                     (const GIm__SerucrityCombinationAlarmData *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__serucrity_combination_alarm_data__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__SerucrityCombinationAlarmData *
       g_im__serucrity_combination_alarm_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__SerucrityCombinationAlarmData *)
     protobuf_c_message_unpack (&g_im__serucrity_combination_alarm_data__descriptor,
                                allocator, len, data);
}
void   g_im__serucrity_combination_alarm_data__free_unpacked
                     (GIm__SerucrityCombinationAlarmData *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__serucrity_combination_alarm_data__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__lowercomputer_data__init
                     (GIm__LowercomputerData         *message)
{
  static const GIm__LowercomputerData init_value = G_IM__LOWERCOMPUTER_DATA__INIT;
  *message = init_value;
}
size_t g_im__lowercomputer_data__get_packed_size
                     (const GIm__LowercomputerData *message)
{
  assert(message->base.descriptor == &g_im__lowercomputer_data__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__lowercomputer_data__pack
                     (const GIm__LowercomputerData *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__lowercomputer_data__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__lowercomputer_data__pack_to_buffer
                     (const GIm__LowercomputerData *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__lowercomputer_data__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__LowercomputerData *
       g_im__lowercomputer_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__LowercomputerData *)
     protobuf_c_message_unpack (&g_im__lowercomputer_data__descriptor,
                                allocator, len, data);
}
void   g_im__lowercomputer_data__free_unpacked
                     (GIm__LowercomputerData *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__lowercomputer_data__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__plc_failure_data__init
                     (GIm__PlcFailureData         *message)
{
  static const GIm__PlcFailureData init_value = G_IM__PLC_FAILURE_DATA__INIT;
  *message = init_value;
}
size_t g_im__plc_failure_data__get_packed_size
                     (const GIm__PlcFailureData *message)
{
  assert(message->base.descriptor == &g_im__plc_failure_data__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__plc_failure_data__pack
                     (const GIm__PlcFailureData *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__plc_failure_data__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__plc_failure_data__pack_to_buffer
                     (const GIm__PlcFailureData *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__plc_failure_data__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__PlcFailureData *
       g_im__plc_failure_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__PlcFailureData *)
     protobuf_c_message_unpack (&g_im__plc_failure_data__descriptor,
                                allocator, len, data);
}
void   g_im__plc_failure_data__free_unpacked
                     (GIm__PlcFailureData *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__plc_failure_data__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_stock_security_info__init
                     (GIm__ImStockSecurityInfo         *message)
{
  static const GIm__ImStockSecurityInfo init_value = G_IM__IM_STOCK_SECURITY_INFO__INIT;
  *message = init_value;
}
size_t g_im__im_stock_security_info__get_packed_size
                     (const GIm__ImStockSecurityInfo *message)
{
  assert(message->base.descriptor == &g_im__im_stock_security_info__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_stock_security_info__pack
                     (const GIm__ImStockSecurityInfo *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_stock_security_info__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_stock_security_info__pack_to_buffer
                     (const GIm__ImStockSecurityInfo *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_stock_security_info__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImStockSecurityInfo *
       g_im__im_stock_security_info__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImStockSecurityInfo *)
     protobuf_c_message_unpack (&g_im__im_stock_security_info__descriptor,
                                allocator, len, data);
}
void   g_im__im_stock_security_info__free_unpacked
                     (GIm__ImStockSecurityInfo *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_stock_security_info__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_security_data__init
                     (GIm__ImSecurityData         *message)
{
  static const GIm__ImSecurityData init_value = G_IM__IM_SECURITY_DATA__INIT;
  *message = init_value;
}
size_t g_im__im_security_data__get_packed_size
                     (const GIm__ImSecurityData *message)
{
  assert(message->base.descriptor == &g_im__im_security_data__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_security_data__pack
                     (const GIm__ImSecurityData *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_security_data__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_security_data__pack_to_buffer
                     (const GIm__ImSecurityData *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_security_data__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImSecurityData *
       g_im__im_security_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImSecurityData *)
     protobuf_c_message_unpack (&g_im__im_security_data__descriptor,
                                allocator, len, data);
}
void   g_im__im_security_data__free_unpacked
                     (GIm__ImSecurityData *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_security_data__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_device_update_info__init
                     (GIm__ImDeviceUpdateInfo         *message)
{
  static const GIm__ImDeviceUpdateInfo init_value = G_IM__IM_DEVICE_UPDATE_INFO__INIT;
  *message = init_value;
}
size_t g_im__im_device_update_info__get_packed_size
                     (const GIm__ImDeviceUpdateInfo *message)
{
  assert(message->base.descriptor == &g_im__im_device_update_info__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_device_update_info__pack
                     (const GIm__ImDeviceUpdateInfo *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_device_update_info__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_device_update_info__pack_to_buffer
                     (const GIm__ImDeviceUpdateInfo *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_device_update_info__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImDeviceUpdateInfo *
       g_im__im_device_update_info__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImDeviceUpdateInfo *)
     protobuf_c_message_unpack (&g_im__im_device_update_info__descriptor,
                                allocator, len, data);
}
void   g_im__im_device_update_info__free_unpacked
                     (GIm__ImDeviceUpdateInfo *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_device_update_info__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_device_passthrough_response__init
                     (GIm__ImDevicePassthroughResponse         *message)
{
  static const GIm__ImDevicePassthroughResponse init_value = G_IM__IM_DEVICE_PASSTHROUGH_RESPONSE__INIT;
  *message = init_value;
}
size_t g_im__im_device_passthrough_response__get_packed_size
                     (const GIm__ImDevicePassthroughResponse *message)
{
  assert(message->base.descriptor == &g_im__im_device_passthrough_response__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_device_passthrough_response__pack
                     (const GIm__ImDevicePassthroughResponse *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_device_passthrough_response__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_device_passthrough_response__pack_to_buffer
                     (const GIm__ImDevicePassthroughResponse *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_device_passthrough_response__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImDevicePassthroughResponse *
       g_im__im_device_passthrough_response__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImDevicePassthroughResponse *)
     protobuf_c_message_unpack (&g_im__im_device_passthrough_response__descriptor,
                                allocator, len, data);
}
void   g_im__im_device_passthrough_response__free_unpacked
                     (GIm__ImDevicePassthroughResponse *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_device_passthrough_response__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_device_upgrade_data__init
                     (GIm__ImDeviceUpgradeData         *message)
{
  static const GIm__ImDeviceUpgradeData init_value = G_IM__IM_DEVICE_UPGRADE_DATA__INIT;
  *message = init_value;
}
size_t g_im__im_device_upgrade_data__get_packed_size
                     (const GIm__ImDeviceUpgradeData *message)
{
  assert(message->base.descriptor == &g_im__im_device_upgrade_data__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_device_upgrade_data__pack
                     (const GIm__ImDeviceUpgradeData *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_device_upgrade_data__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_device_upgrade_data__pack_to_buffer
                     (const GIm__ImDeviceUpgradeData *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_device_upgrade_data__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImDeviceUpgradeData *
       g_im__im_device_upgrade_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImDeviceUpgradeData *)
     protobuf_c_message_unpack (&g_im__im_device_upgrade_data__descriptor,
                                allocator, len, data);
}
void   g_im__im_device_upgrade_data__free_unpacked
                     (GIm__ImDeviceUpgradeData *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_device_upgrade_data__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_device_upgrad_notify__init
                     (GIm__ImDeviceUpgradNotify         *message)
{
  static const GIm__ImDeviceUpgradNotify init_value = G_IM__IM_DEVICE_UPGRAD_NOTIFY__INIT;
  *message = init_value;
}
size_t g_im__im_device_upgrad_notify__get_packed_size
                     (const GIm__ImDeviceUpgradNotify *message)
{
  assert(message->base.descriptor == &g_im__im_device_upgrad_notify__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_device_upgrad_notify__pack
                     (const GIm__ImDeviceUpgradNotify *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_device_upgrad_notify__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_device_upgrad_notify__pack_to_buffer
                     (const GIm__ImDeviceUpgradNotify *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_device_upgrad_notify__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImDeviceUpgradNotify *
       g_im__im_device_upgrad_notify__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImDeviceUpgradNotify *)
     protobuf_c_message_unpack (&g_im__im_device_upgrad_notify__descriptor,
                                allocator, len, data);
}
void   g_im__im_device_upgrad_notify__free_unpacked
                     (GIm__ImDeviceUpgradNotify *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_device_upgrad_notify__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_netcard_param__init
                     (GIm__ImNetcardParam         *message)
{
  static const GIm__ImNetcardParam init_value = G_IM__IM_NETCARD_PARAM__INIT;
  *message = init_value;
}
size_t g_im__im_netcard_param__get_packed_size
                     (const GIm__ImNetcardParam *message)
{
  assert(message->base.descriptor == &g_im__im_netcard_param__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_netcard_param__pack
                     (const GIm__ImNetcardParam *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_netcard_param__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_netcard_param__pack_to_buffer
                     (const GIm__ImNetcardParam *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_netcard_param__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImNetcardParam *
       g_im__im_netcard_param__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImNetcardParam *)
     protobuf_c_message_unpack (&g_im__im_netcard_param__descriptor,
                                allocator, len, data);
}
void   g_im__im_netcard_param__free_unpacked
                     (GIm__ImNetcardParam *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_netcard_param__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_master_channel_ret__init
                     (GIm__ImMasterChannelRet         *message)
{
  static const GIm__ImMasterChannelRet init_value = G_IM__IM_MASTER_CHANNEL_RET__INIT;
  *message = init_value;
}
size_t g_im__im_master_channel_ret__get_packed_size
                     (const GIm__ImMasterChannelRet *message)
{
  assert(message->base.descriptor == &g_im__im_master_channel_ret__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_master_channel_ret__pack
                     (const GIm__ImMasterChannelRet *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_master_channel_ret__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_master_channel_ret__pack_to_buffer
                     (const GIm__ImMasterChannelRet *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_master_channel_ret__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImMasterChannelRet *
       g_im__im_master_channel_ret__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImMasterChannelRet *)
     protobuf_c_message_unpack (&g_im__im_master_channel_ret__descriptor,
                                allocator, len, data);
}
void   g_im__im_master_channel_ret__free_unpacked
                     (GIm__ImMasterChannelRet *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_master_channel_ret__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_step_jump__init
                     (GIm__ImStepJump         *message)
{
  static const GIm__ImStepJump init_value = G_IM__IM_STEP_JUMP__INIT;
  *message = init_value;
}
size_t g_im__im_step_jump__get_packed_size
                     (const GIm__ImStepJump *message)
{
  assert(message->base.descriptor == &g_im__im_step_jump__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_step_jump__pack
                     (const GIm__ImStepJump *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_step_jump__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_step_jump__pack_to_buffer
                     (const GIm__ImStepJump *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_step_jump__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImStepJump *
       g_im__im_step_jump__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImStepJump *)
     protobuf_c_message_unpack (&g_im__im_step_jump__descriptor,
                                allocator, len, data);
}
void   g_im__im_step_jump__free_unpacked
                     (GIm__ImStepJump *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_step_jump__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_channel_continue_ret__init
                     (GIm__ImChannelContinueRet         *message)
{
  static const GIm__ImChannelContinueRet init_value = G_IM__IM_CHANNEL_CONTINUE_RET__INIT;
  *message = init_value;
}
size_t g_im__im_channel_continue_ret__get_packed_size
                     (const GIm__ImChannelContinueRet *message)
{
  assert(message->base.descriptor == &g_im__im_channel_continue_ret__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_channel_continue_ret__pack
                     (const GIm__ImChannelContinueRet *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_channel_continue_ret__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_channel_continue_ret__pack_to_buffer
                     (const GIm__ImChannelContinueRet *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_channel_continue_ret__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImChannelContinueRet *
       g_im__im_channel_continue_ret__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImChannelContinueRet *)
     protobuf_c_message_unpack (&g_im__im_channel_continue_ret__descriptor,
                                allocator, len, data);
}
void   g_im__im_channel_continue_ret__free_unpacked
                     (GIm__ImChannelContinueRet *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_channel_continue_ret__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_channel_enable_byip_result__init
                     (GIm__ImChannelEnableByipResult         *message)
{
  static const GIm__ImChannelEnableByipResult init_value = G_IM__IM_CHANNEL_ENABLE_BYIP_RESULT__INIT;
  *message = init_value;
}
size_t g_im__im_channel_enable_byip_result__get_packed_size
                     (const GIm__ImChannelEnableByipResult *message)
{
  assert(message->base.descriptor == &g_im__im_channel_enable_byip_result__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_channel_enable_byip_result__pack
                     (const GIm__ImChannelEnableByipResult *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_channel_enable_byip_result__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_channel_enable_byip_result__pack_to_buffer
                     (const GIm__ImChannelEnableByipResult *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_channel_enable_byip_result__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImChannelEnableByipResult *
       g_im__im_channel_enable_byip_result__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImChannelEnableByipResult *)
     protobuf_c_message_unpack (&g_im__im_channel_enable_byip_result__descriptor,
                                allocator, len, data);
}
void   g_im__im_channel_enable_byip_result__free_unpacked
                     (GIm__ImChannelEnableByipResult *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_channel_enable_byip_result__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_channel_appoint_stop__init
                     (GIm__ImChannelAppointStop         *message)
{
  static const GIm__ImChannelAppointStop init_value = G_IM__IM_CHANNEL_APPOINT_STOP__INIT;
  *message = init_value;
}
size_t g_im__im_channel_appoint_stop__get_packed_size
                     (const GIm__ImChannelAppointStop *message)
{
  assert(message->base.descriptor == &g_im__im_channel_appoint_stop__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_channel_appoint_stop__pack
                     (const GIm__ImChannelAppointStop *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_channel_appoint_stop__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_channel_appoint_stop__pack_to_buffer
                     (const GIm__ImChannelAppointStop *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_channel_appoint_stop__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImChannelAppointStop *
       g_im__im_channel_appoint_stop__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImChannelAppointStop *)
     protobuf_c_message_unpack (&g_im__im_channel_appoint_stop__descriptor,
                                allocator, len, data);
}
void   g_im__im_channel_appoint_stop__free_unpacked
                     (GIm__ImChannelAppointStop *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_channel_appoint_stop__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_security_stop_by_stock__init
                     (GIm__ImSecurityStopByStock         *message)
{
  static const GIm__ImSecurityStopByStock init_value = G_IM__IM_SECURITY_STOP_BY_STOCK__INIT;
  *message = init_value;
}
size_t g_im__im_security_stop_by_stock__get_packed_size
                     (const GIm__ImSecurityStopByStock *message)
{
  assert(message->base.descriptor == &g_im__im_security_stop_by_stock__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_security_stop_by_stock__pack
                     (const GIm__ImSecurityStopByStock *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_security_stop_by_stock__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_security_stop_by_stock__pack_to_buffer
                     (const GIm__ImSecurityStopByStock *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_security_stop_by_stock__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImSecurityStopByStock *
       g_im__im_security_stop_by_stock__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImSecurityStopByStock *)
     protobuf_c_message_unpack (&g_im__im_security_stop_by_stock__descriptor,
                                allocator, len, data);
}
void   g_im__im_security_stop_by_stock__free_unpacked
                     (GIm__ImSecurityStopByStock *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_security_stop_by_stock__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_channel_test__init
                     (GIm__ImChannelTest         *message)
{
  static const GIm__ImChannelTest init_value = G_IM__IM_CHANNEL_TEST__INIT;
  *message = init_value;
}
size_t g_im__im_channel_test__get_packed_size
                     (const GIm__ImChannelTest *message)
{
  assert(message->base.descriptor == &g_im__im_channel_test__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_channel_test__pack
                     (const GIm__ImChannelTest *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_channel_test__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_channel_test__pack_to_buffer
                     (const GIm__ImChannelTest *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_channel_test__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImChannelTest *
       g_im__im_channel_test__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImChannelTest *)
     protobuf_c_message_unpack (&g_im__im_channel_test__descriptor,
                                allocator, len, data);
}
void   g_im__im_channel_test__free_unpacked
                     (GIm__ImChannelTest *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_channel_test__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_channel_clear_warn__init
                     (GIm__ImChannelClearWarn         *message)
{
  static const GIm__ImChannelClearWarn init_value = G_IM__IM_CHANNEL_CLEAR_WARN__INIT;
  *message = init_value;
}
size_t g_im__im_channel_clear_warn__get_packed_size
                     (const GIm__ImChannelClearWarn *message)
{
  assert(message->base.descriptor == &g_im__im_channel_clear_warn__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_channel_clear_warn__pack
                     (const GIm__ImChannelClearWarn *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_channel_clear_warn__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_channel_clear_warn__pack_to_buffer
                     (const GIm__ImChannelClearWarn *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_channel_clear_warn__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImChannelClearWarn *
       g_im__im_channel_clear_warn__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImChannelClearWarn *)
     protobuf_c_message_unpack (&g_im__im_channel_clear_warn__descriptor,
                                allocator, len, data);
}
void   g_im__im_channel_clear_warn__free_unpacked
                     (GIm__ImChannelClearWarn *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_channel_clear_warn__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_security_clear_warn__init
                     (GIm__ImSecurityClearWarn         *message)
{
  static const GIm__ImSecurityClearWarn init_value = G_IM__IM_SECURITY_CLEAR_WARN__INIT;
  *message = init_value;
}
size_t g_im__im_security_clear_warn__get_packed_size
                     (const GIm__ImSecurityClearWarn *message)
{
  assert(message->base.descriptor == &g_im__im_security_clear_warn__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_security_clear_warn__pack
                     (const GIm__ImSecurityClearWarn *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_security_clear_warn__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_security_clear_warn__pack_to_buffer
                     (const GIm__ImSecurityClearWarn *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_security_clear_warn__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImSecurityClearWarn *
       g_im__im_security_clear_warn__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImSecurityClearWarn *)
     protobuf_c_message_unpack (&g_im__im_security_clear_warn__descriptor,
                                allocator, len, data);
}
void   g_im__im_security_clear_warn__free_unpacked
                     (GIm__ImSecurityClearWarn *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_security_clear_warn__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_display_time_protection__init
                     (GIm__ImDisplayTimeProtection         *message)
{
  static const GIm__ImDisplayTimeProtection init_value = G_IM__IM_DISPLAY_TIME_PROTECTION__INIT;
  *message = init_value;
}
size_t g_im__im_display_time_protection__get_packed_size
                     (const GIm__ImDisplayTimeProtection *message)
{
  assert(message->base.descriptor == &g_im__im_display_time_protection__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_display_time_protection__pack
                     (const GIm__ImDisplayTimeProtection *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_display_time_protection__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_display_time_protection__pack_to_buffer
                     (const GIm__ImDisplayTimeProtection *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_display_time_protection__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImDisplayTimeProtection *
       g_im__im_display_time_protection__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImDisplayTimeProtection *)
     protobuf_c_message_unpack (&g_im__im_display_time_protection__descriptor,
                                allocator, len, data);
}
void   g_im__im_display_time_protection__free_unpacked
                     (GIm__ImDisplayTimeProtection *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_display_time_protection__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_soft_update__init
                     (GIm__ImSoftUpdate         *message)
{
  static const GIm__ImSoftUpdate init_value = G_IM__IM_SOFT_UPDATE__INIT;
  *message = init_value;
}
size_t g_im__im_soft_update__get_packed_size
                     (const GIm__ImSoftUpdate *message)
{
  assert(message->base.descriptor == &g_im__im_soft_update__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_soft_update__pack
                     (const GIm__ImSoftUpdate *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_soft_update__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_soft_update__pack_to_buffer
                     (const GIm__ImSoftUpdate *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_soft_update__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImSoftUpdate *
       g_im__im_soft_update__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImSoftUpdate *)
     protobuf_c_message_unpack (&g_im__im_soft_update__descriptor,
                                allocator, len, data);
}
void   g_im__im_soft_update__free_unpacked
                     (GIm__ImSoftUpdate *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_soft_update__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_device_update__init
                     (GIm__ImDeviceUpdate         *message)
{
  static const GIm__ImDeviceUpdate init_value = G_IM__IM_DEVICE_UPDATE__INIT;
  *message = init_value;
}
size_t g_im__im_device_update__get_packed_size
                     (const GIm__ImDeviceUpdate *message)
{
  assert(message->base.descriptor == &g_im__im_device_update__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_device_update__pack
                     (const GIm__ImDeviceUpdate *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_device_update__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_device_update__pack_to_buffer
                     (const GIm__ImDeviceUpdate *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_device_update__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImDeviceUpdate *
       g_im__im_device_update__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImDeviceUpdate *)
     protobuf_c_message_unpack (&g_im__im_device_update__descriptor,
                                allocator, len, data);
}
void   g_im__im_device_update__free_unpacked
                     (GIm__ImDeviceUpdate *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_device_update__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_device_passthrough__init
                     (GIm__ImDevicePassthrough         *message)
{
  static const GIm__ImDevicePassthrough init_value = G_IM__IM_DEVICE_PASSTHROUGH__INIT;
  *message = init_value;
}
size_t g_im__im_device_passthrough__get_packed_size
                     (const GIm__ImDevicePassthrough *message)
{
  assert(message->base.descriptor == &g_im__im_device_passthrough__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_device_passthrough__pack
                     (const GIm__ImDevicePassthrough *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_device_passthrough__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_device_passthrough__pack_to_buffer
                     (const GIm__ImDevicePassthrough *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_device_passthrough__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImDevicePassthrough *
       g_im__im_device_passthrough__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImDevicePassthrough *)
     protobuf_c_message_unpack (&g_im__im_device_passthrough__descriptor,
                                allocator, len, data);
}
void   g_im__im_device_passthrough__free_unpacked
                     (GIm__ImDevicePassthrough *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_device_passthrough__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_cmd_request__init
                     (GIm__ImCmdRequest         *message)
{
  static const GIm__ImCmdRequest init_value = G_IM__IM_CMD_REQUEST__INIT;
  *message = init_value;
}
size_t g_im__im_cmd_request__get_packed_size
                     (const GIm__ImCmdRequest *message)
{
  assert(message->base.descriptor == &g_im__im_cmd_request__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_cmd_request__pack
                     (const GIm__ImCmdRequest *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_cmd_request__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_cmd_request__pack_to_buffer
                     (const GIm__ImCmdRequest *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_cmd_request__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImCmdRequest *
       g_im__im_cmd_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImCmdRequest *)
     protobuf_c_message_unpack (&g_im__im_cmd_request__descriptor,
                                allocator, len, data);
}
void   g_im__im_cmd_request__free_unpacked
                     (GIm__ImCmdRequest *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_cmd_request__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__execute_serucrity_result__init
                     (GIm__ExecuteSerucrityResult         *message)
{
  static const GIm__ExecuteSerucrityResult init_value = G_IM__EXECUTE_SERUCRITY_RESULT__INIT;
  *message = init_value;
}
size_t g_im__execute_serucrity_result__get_packed_size
                     (const GIm__ExecuteSerucrityResult *message)
{
  assert(message->base.descriptor == &g_im__execute_serucrity_result__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__execute_serucrity_result__pack
                     (const GIm__ExecuteSerucrityResult *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__execute_serucrity_result__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__execute_serucrity_result__pack_to_buffer
                     (const GIm__ExecuteSerucrityResult *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__execute_serucrity_result__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ExecuteSerucrityResult *
       g_im__execute_serucrity_result__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ExecuteSerucrityResult *)
     protobuf_c_message_unpack (&g_im__execute_serucrity_result__descriptor,
                                allocator, len, data);
}
void   g_im__execute_serucrity_result__free_unpacked
                     (GIm__ExecuteSerucrityResult *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__execute_serucrity_result__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_cmd_response__init
                     (GIm__ImCmdResponse         *message)
{
  static const GIm__ImCmdResponse init_value = G_IM__IM_CMD_RESPONSE__INIT;
  *message = init_value;
}
size_t g_im__im_cmd_response__get_packed_size
                     (const GIm__ImCmdResponse *message)
{
  assert(message->base.descriptor == &g_im__im_cmd_response__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_cmd_response__pack
                     (const GIm__ImCmdResponse *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_cmd_response__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_cmd_response__pack_to_buffer
                     (const GIm__ImCmdResponse *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_cmd_response__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImCmdResponse *
       g_im__im_cmd_response__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImCmdResponse *)
     protobuf_c_message_unpack (&g_im__im_cmd_response__descriptor,
                                allocator, len, data);
}
void   g_im__im_cmd_response__free_unpacked
                     (GIm__ImCmdResponse *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_cmd_response__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_chnnel_warn__init
                     (GIm__ImChnnelWarn         *message)
{
  static const GIm__ImChnnelWarn init_value = G_IM__IM_CHNNEL_WARN__INIT;
  *message = init_value;
}
size_t g_im__im_chnnel_warn__get_packed_size
                     (const GIm__ImChnnelWarn *message)
{
  assert(message->base.descriptor == &g_im__im_chnnel_warn__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_chnnel_warn__pack
                     (const GIm__ImChnnelWarn *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_chnnel_warn__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_chnnel_warn__pack_to_buffer
                     (const GIm__ImChnnelWarn *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_chnnel_warn__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImChnnelWarn *
       g_im__im_chnnel_warn__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImChnnelWarn *)
     protobuf_c_message_unpack (&g_im__im_chnnel_warn__descriptor,
                                allocator, len, data);
}
void   g_im__im_chnnel_warn__free_unpacked
                     (GIm__ImChnnelWarn *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_chnnel_warn__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_extern_data__init
                     (GIm__ImExternData         *message)
{
  static const GIm__ImExternData init_value = G_IM__IM_EXTERN_DATA__INIT;
  *message = init_value;
}
size_t g_im__im_extern_data__get_packed_size
                     (const GIm__ImExternData *message)
{
  assert(message->base.descriptor == &g_im__im_extern_data__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_extern_data__pack
                     (const GIm__ImExternData *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_extern_data__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_extern_data__pack_to_buffer
                     (const GIm__ImExternData *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_extern_data__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImExternData *
       g_im__im_extern_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImExternData *)
     protobuf_c_message_unpack (&g_im__im_extern_data__descriptor,
                                allocator, len, data);
}
void   g_im__im_extern_data__free_unpacked
                     (GIm__ImExternData *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_extern_data__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_channel_param__init
                     (GIm__ImChannelParam         *message)
{
  static const GIm__ImChannelParam init_value = G_IM__IM_CHANNEL_PARAM__INIT;
  *message = init_value;
}
size_t g_im__im_channel_param__get_packed_size
                     (const GIm__ImChannelParam *message)
{
  assert(message->base.descriptor == &g_im__im_channel_param__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_channel_param__pack
                     (const GIm__ImChannelParam *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_channel_param__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_channel_param__pack_to_buffer
                     (const GIm__ImChannelParam *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_channel_param__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImChannelParam *
       g_im__im_channel_param__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImChannelParam *)
     protobuf_c_message_unpack (&g_im__im_channel_param__descriptor,
                                allocator, len, data);
}
void   g_im__im_channel_param__free_unpacked
                     (GIm__ImChannelParam *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_channel_param__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_cell_param__init
                     (GIm__ImCellParam         *message)
{
  static const GIm__ImCellParam init_value = G_IM__IM_CELL_PARAM__INIT;
  *message = init_value;
}
size_t g_im__im_cell_param__get_packed_size
                     (const GIm__ImCellParam *message)
{
  assert(message->base.descriptor == &g_im__im_cell_param__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_cell_param__pack
                     (const GIm__ImCellParam *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_cell_param__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_cell_param__pack_to_buffer
                     (const GIm__ImCellParam *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_cell_param__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImCellParam *
       g_im__im_cell_param__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImCellParam *)
     protobuf_c_message_unpack (&g_im__im_cell_param__descriptor,
                                allocator, len, data);
}
void   g_im__im_cell_param__free_unpacked
                     (GIm__ImCellParam *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_cell_param__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_ui_data__init
                     (GIm__ImUiData         *message)
{
  static const GIm__ImUiData init_value = G_IM__IM_UI_DATA__INIT;
  *message = init_value;
}
size_t g_im__im_ui_data__get_packed_size
                     (const GIm__ImUiData *message)
{
  assert(message->base.descriptor == &g_im__im_ui_data__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_ui_data__pack
                     (const GIm__ImUiData *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_ui_data__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_ui_data__pack_to_buffer
                     (const GIm__ImUiData *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_ui_data__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImUiData *
       g_im__im_ui_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImUiData *)
     protobuf_c_message_unpack (&g_im__im_ui_data__descriptor,
                                allocator, len, data);
}
void   g_im__im_ui_data__free_unpacked
                     (GIm__ImUiData *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_ui_data__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_ui_data_response__init
                     (GIm__ImUiDataResponse         *message)
{
  static const GIm__ImUiDataResponse init_value = G_IM__IM_UI_DATA_RESPONSE__INIT;
  *message = init_value;
}
size_t g_im__im_ui_data_response__get_packed_size
                     (const GIm__ImUiDataResponse *message)
{
  assert(message->base.descriptor == &g_im__im_ui_data_response__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_ui_data_response__pack
                     (const GIm__ImUiDataResponse *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_ui_data_response__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_ui_data_response__pack_to_buffer
                     (const GIm__ImUiDataResponse *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_ui_data_response__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImUiDataResponse *
       g_im__im_ui_data_response__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImUiDataResponse *)
     protobuf_c_message_unpack (&g_im__im_ui_data_response__descriptor,
                                allocator, len, data);
}
void   g_im__im_ui_data_response__free_unpacked
                     (GIm__ImUiDataResponse *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_ui_data_response__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_ajust_request__init
                     (GIm__ImAjustRequest         *message)
{
  static const GIm__ImAjustRequest init_value = G_IM__IM_AJUST_REQUEST__INIT;
  *message = init_value;
}
size_t g_im__im_ajust_request__get_packed_size
                     (const GIm__ImAjustRequest *message)
{
  assert(message->base.descriptor == &g_im__im_ajust_request__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_ajust_request__pack
                     (const GIm__ImAjustRequest *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_ajust_request__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_ajust_request__pack_to_buffer
                     (const GIm__ImAjustRequest *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_ajust_request__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImAjustRequest *
       g_im__im_ajust_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImAjustRequest *)
     protobuf_c_message_unpack (&g_im__im_ajust_request__descriptor,
                                allocator, len, data);
}
void   g_im__im_ajust_request__free_unpacked
                     (GIm__ImAjustRequest *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_ajust_request__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_ajust_response__init
                     (GIm__ImAjustResponse         *message)
{
  static const GIm__ImAjustResponse init_value = G_IM__IM_AJUST_RESPONSE__INIT;
  *message = init_value;
}
size_t g_im__im_ajust_response__get_packed_size
                     (const GIm__ImAjustResponse *message)
{
  assert(message->base.descriptor == &g_im__im_ajust_response__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_ajust_response__pack
                     (const GIm__ImAjustResponse *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_ajust_response__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_ajust_response__pack_to_buffer
                     (const GIm__ImAjustResponse *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_ajust_response__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImAjustResponse *
       g_im__im_ajust_response__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImAjustResponse *)
     protobuf_c_message_unpack (&g_im__im_ajust_response__descriptor,
                                allocator, len, data);
}
void   g_im__im_ajust_response__free_unpacked
                     (GIm__ImAjustResponse *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_ajust_response__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_debug_request__init
                     (GIm__ImDebugRequest         *message)
{
  static const GIm__ImDebugRequest init_value = G_IM__IM_DEBUG_REQUEST__INIT;
  *message = init_value;
}
size_t g_im__im_debug_request__get_packed_size
                     (const GIm__ImDebugRequest *message)
{
  assert(message->base.descriptor == &g_im__im_debug_request__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_debug_request__pack
                     (const GIm__ImDebugRequest *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_debug_request__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_debug_request__pack_to_buffer
                     (const GIm__ImDebugRequest *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_debug_request__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImDebugRequest *
       g_im__im_debug_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImDebugRequest *)
     protobuf_c_message_unpack (&g_im__im_debug_request__descriptor,
                                allocator, len, data);
}
void   g_im__im_debug_request__free_unpacked
                     (GIm__ImDebugRequest *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_debug_request__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_debug_response__init
                     (GIm__ImDebugResponse         *message)
{
  static const GIm__ImDebugResponse init_value = G_IM__IM_DEBUG_RESPONSE__INIT;
  *message = init_value;
}
size_t g_im__im_debug_response__get_packed_size
                     (const GIm__ImDebugResponse *message)
{
  assert(message->base.descriptor == &g_im__im_debug_response__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_debug_response__pack
                     (const GIm__ImDebugResponse *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_debug_response__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_debug_response__pack_to_buffer
                     (const GIm__ImDebugResponse *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_debug_response__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImDebugResponse *
       g_im__im_debug_response__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImDebugResponse *)
     protobuf_c_message_unpack (&g_im__im_debug_response__descriptor,
                                allocator, len, data);
}
void   g_im__im_debug_response__free_unpacked
                     (GIm__ImDebugResponse *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_debug_response__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_eeprom_request__init
                     (GIm__ImEepromRequest         *message)
{
  static const GIm__ImEepromRequest init_value = G_IM__IM_EEPROM_REQUEST__INIT;
  *message = init_value;
}
size_t g_im__im_eeprom_request__get_packed_size
                     (const GIm__ImEepromRequest *message)
{
  assert(message->base.descriptor == &g_im__im_eeprom_request__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_eeprom_request__pack
                     (const GIm__ImEepromRequest *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_eeprom_request__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_eeprom_request__pack_to_buffer
                     (const GIm__ImEepromRequest *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_eeprom_request__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImEepromRequest *
       g_im__im_eeprom_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImEepromRequest *)
     protobuf_c_message_unpack (&g_im__im_eeprom_request__descriptor,
                                allocator, len, data);
}
void   g_im__im_eeprom_request__free_unpacked
                     (GIm__ImEepromRequest *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_eeprom_request__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_eeprom_read_response__init
                     (GIm__ImEepromReadResponse         *message)
{
  static const GIm__ImEepromReadResponse init_value = G_IM__IM_EEPROM_READ_RESPONSE__INIT;
  *message = init_value;
}
size_t g_im__im_eeprom_read_response__get_packed_size
                     (const GIm__ImEepromReadResponse *message)
{
  assert(message->base.descriptor == &g_im__im_eeprom_read_response__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_eeprom_read_response__pack
                     (const GIm__ImEepromReadResponse *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_eeprom_read_response__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_eeprom_read_response__pack_to_buffer
                     (const GIm__ImEepromReadResponse *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_eeprom_read_response__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImEepromReadResponse *
       g_im__im_eeprom_read_response__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImEepromReadResponse *)
     protobuf_c_message_unpack (&g_im__im_eeprom_read_response__descriptor,
                                allocator, len, data);
}
void   g_im__im_eeprom_read_response__free_unpacked
                     (GIm__ImEepromReadResponse *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_eeprom_read_response__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_eeprom_write_response__init
                     (GIm__ImEepromWriteResponse         *message)
{
  static const GIm__ImEepromWriteResponse init_value = G_IM__IM_EEPROM_WRITE_RESPONSE__INIT;
  *message = init_value;
}
size_t g_im__im_eeprom_write_response__get_packed_size
                     (const GIm__ImEepromWriteResponse *message)
{
  assert(message->base.descriptor == &g_im__im_eeprom_write_response__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_eeprom_write_response__pack
                     (const GIm__ImEepromWriteResponse *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_eeprom_write_response__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_eeprom_write_response__pack_to_buffer
                     (const GIm__ImEepromWriteResponse *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_eeprom_write_response__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImEepromWriteResponse *
       g_im__im_eeprom_write_response__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImEepromWriteResponse *)
     protobuf_c_message_unpack (&g_im__im_eeprom_write_response__descriptor,
                                allocator, len, data);
}
void   g_im__im_eeprom_write_response__free_unpacked
                     (GIm__ImEepromWriteResponse *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_eeprom_write_response__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__negative_pressure_param__init
                     (GIm__NegativePressureParam         *message)
{
  static const GIm__NegativePressureParam init_value = G_IM__NEGATIVE_PRESSURE_PARAM__INIT;
  *message = init_value;
}
size_t g_im__negative_pressure_param__get_packed_size
                     (const GIm__NegativePressureParam *message)
{
  assert(message->base.descriptor == &g_im__negative_pressure_param__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__negative_pressure_param__pack
                     (const GIm__NegativePressureParam *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__negative_pressure_param__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__negative_pressure_param__pack_to_buffer
                     (const GIm__NegativePressureParam *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__negative_pressure_param__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__NegativePressureParam *
       g_im__negative_pressure_param__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__NegativePressureParam *)
     protobuf_c_message_unpack (&g_im__negative_pressure_param__descriptor,
                                allocator, len, data);
}
void   g_im__negative_pressure_param__free_unpacked
                     (GIm__NegativePressureParam *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__negative_pressure_param__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_negative_pressure_request__init
                     (GIm__ImNegativePressureRequest         *message)
{
  static const GIm__ImNegativePressureRequest init_value = G_IM__IM_NEGATIVE_PRESSURE_REQUEST__INIT;
  *message = init_value;
}
size_t g_im__im_negative_pressure_request__get_packed_size
                     (const GIm__ImNegativePressureRequest *message)
{
  assert(message->base.descriptor == &g_im__im_negative_pressure_request__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_negative_pressure_request__pack
                     (const GIm__ImNegativePressureRequest *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_negative_pressure_request__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_negative_pressure_request__pack_to_buffer
                     (const GIm__ImNegativePressureRequest *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_negative_pressure_request__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImNegativePressureRequest *
       g_im__im_negative_pressure_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImNegativePressureRequest *)
     protobuf_c_message_unpack (&g_im__im_negative_pressure_request__descriptor,
                                allocator, len, data);
}
void   g_im__im_negative_pressure_request__free_unpacked
                     (GIm__ImNegativePressureRequest *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_negative_pressure_request__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_negative_pressure_response__init
                     (GIm__ImNegativePressureResponse         *message)
{
  static const GIm__ImNegativePressureResponse init_value = G_IM__IM_NEGATIVE_PRESSURE_RESPONSE__INIT;
  *message = init_value;
}
size_t g_im__im_negative_pressure_response__get_packed_size
                     (const GIm__ImNegativePressureResponse *message)
{
  assert(message->base.descriptor == &g_im__im_negative_pressure_response__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_negative_pressure_response__pack
                     (const GIm__ImNegativePressureResponse *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_negative_pressure_response__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_negative_pressure_response__pack_to_buffer
                     (const GIm__ImNegativePressureResponse *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_negative_pressure_response__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImNegativePressureResponse *
       g_im__im_negative_pressure_response__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImNegativePressureResponse *)
     protobuf_c_message_unpack (&g_im__im_negative_pressure_response__descriptor,
                                allocator, len, data);
}
void   g_im__im_negative_pressure_response__free_unpacked
                     (GIm__ImNegativePressureResponse *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_negative_pressure_response__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_version_query_request__init
                     (GIm__ImVersionQueryRequest         *message)
{
  static const GIm__ImVersionQueryRequest init_value = G_IM__IM_VERSION_QUERY_REQUEST__INIT;
  *message = init_value;
}
size_t g_im__im_version_query_request__get_packed_size
                     (const GIm__ImVersionQueryRequest *message)
{
  assert(message->base.descriptor == &g_im__im_version_query_request__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_version_query_request__pack
                     (const GIm__ImVersionQueryRequest *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_version_query_request__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_version_query_request__pack_to_buffer
                     (const GIm__ImVersionQueryRequest *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_version_query_request__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImVersionQueryRequest *
       g_im__im_version_query_request__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImVersionQueryRequest *)
     protobuf_c_message_unpack (&g_im__im_version_query_request__descriptor,
                                allocator, len, data);
}
void   g_im__im_version_query_request__free_unpacked
                     (GIm__ImVersionQueryRequest *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_version_query_request__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   g_im__im_version_query_response__init
                     (GIm__ImVersionQueryResponse         *message)
{
  static const GIm__ImVersionQueryResponse init_value = G_IM__IM_VERSION_QUERY_RESPONSE__INIT;
  *message = init_value;
}
size_t g_im__im_version_query_response__get_packed_size
                     (const GIm__ImVersionQueryResponse *message)
{
  assert(message->base.descriptor == &g_im__im_version_query_response__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t g_im__im_version_query_response__pack
                     (const GIm__ImVersionQueryResponse *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &g_im__im_version_query_response__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t g_im__im_version_query_response__pack_to_buffer
                     (const GIm__ImVersionQueryResponse *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &g_im__im_version_query_response__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
GIm__ImVersionQueryResponse *
       g_im__im_version_query_response__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (GIm__ImVersionQueryResponse *)
     protobuf_c_message_unpack (&g_im__im_version_query_response__descriptor,
                                allocator, len, data);
}
void   g_im__im_version_query_response__free_unpacked
                     (GIm__ImVersionQueryResponse *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &g_im__im_version_query_response__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
static const ProtobufCFieldDescriptor g_im__im_cmd_head__field_descriptors[3] =
{
  {
    "magic",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImCmdHead, has_magic),
    offsetof(GIm__ImCmdHead, magic),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "seq_num",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImCmdHead, has_seq_num),
    offsetof(GIm__ImCmdHead, seq_num),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "op",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImCmdHead, has_op),
    offsetof(GIm__ImCmdHead, op),
    &g_im__cmd_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_cmd_head__field_indices_by_name[] = {
  0,   /* field[0] = magic */
  2,   /* field[2] = op */
  1,   /* field[1] = seq_num */
};
static const ProtobufCIntRange g_im__im_cmd_head__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor g_im__im_cmd_head__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_cmd_head",
  "ImCmdHead",
  "GIm__ImCmdHead",
  "g_im",
  sizeof(GIm__ImCmdHead),
  3,
  g_im__im_cmd_head__field_descriptors,
  g_im__im_cmd_head__field_indices_by_name,
  1,  g_im__im_cmd_head__number_ranges,
  (ProtobufCMessageInit) g_im__im_cmd_head__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_auth__field_descriptors[6] =
{
  {
    "type",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImAuth, has_type),
    offsetof(GIm__ImAuth, type),
    &g_im__auth_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "auth_times",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImAuth, has_auth_times),
    offsetof(GIm__ImAuth, auth_times),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "auth_year",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImAuth, has_auth_year),
    offsetof(GIm__ImAuth, auth_year),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "auth_month",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImAuth, has_auth_month),
    offsetof(GIm__ImAuth, auth_month),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "auth_day",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImAuth, has_auth_day),
    offsetof(GIm__ImAuth, auth_day),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "auth_start_time",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED64,
    offsetof(GIm__ImAuth, has_auth_start_time),
    offsetof(GIm__ImAuth, auth_start_time),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_auth__field_indices_by_name[] = {
  4,   /* field[4] = auth_day */
  3,   /* field[3] = auth_month */
  5,   /* field[5] = auth_start_time */
  1,   /* field[1] = auth_times */
  2,   /* field[2] = auth_year */
  0,   /* field[0] = type */
};
static const ProtobufCIntRange g_im__im_auth__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 6 }
};
const ProtobufCMessageDescriptor g_im__im_auth__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_auth",
  "ImAuth",
  "GIm__ImAuth",
  "g_im",
  sizeof(GIm__ImAuth),
  6,
  g_im__im_auth__field_descriptors,
  g_im__im_auth__field_indices_by_name,
  1,  g_im__im_auth__number_ranges,
  (ProtobufCMessageInit) g_im__im_auth__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_data_store4unit__field_descriptors[2] =
{
  {
    "enable",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(GIm__ImDataStore4unit, has_enable),
    offsetof(GIm__ImDataStore4unit, enable),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "unit_num",
    6,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImDataStore4unit, n_unit_num),
    offsetof(GIm__ImDataStore4unit, unit_num),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_data_store4unit__field_indices_by_name[] = {
  0,   /* field[0] = enable */
  1,   /* field[1] = unit_num */
};
static const ProtobufCIntRange g_im__im_data_store4unit__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor g_im__im_data_store4unit__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_data_store4unit",
  "ImDataStore4unit",
  "GIm__ImDataStore4unit",
  "g_im",
  sizeof(GIm__ImDataStore4unit),
  2,
  g_im__im_data_store4unit__field_descriptors,
  g_im__im_data_store4unit__field_indices_by_name,
  1,  g_im__im_data_store4unit__number_ranges,
  (ProtobufCMessageInit) g_im__im_data_store4unit__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_data_store4alarm__field_descriptors[3] =
{
  {
    "enable",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(GIm__ImDataStore4alarm, has_enable),
    offsetof(GIm__ImDataStore4alarm, enable),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "interval",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImDataStore4alarm, has_interval),
    offsetof(GIm__ImDataStore4alarm, interval),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "time",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImDataStore4alarm, has_time),
    offsetof(GIm__ImDataStore4alarm, time),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_data_store4alarm__field_indices_by_name[] = {
  0,   /* field[0] = enable */
  1,   /* field[1] = interval */
  2,   /* field[2] = time */
};
static const ProtobufCIntRange g_im__im_data_store4alarm__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor g_im__im_data_store4alarm__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_data_store4alarm",
  "ImDataStore4alarm",
  "GIm__ImDataStore4alarm",
  "g_im",
  sizeof(GIm__ImDataStore4alarm),
  3,
  g_im__im_data_store4alarm__field_descriptors,
  g_im__im_data_store4alarm__field_indices_by_name,
  1,  g_im__im_data_store4alarm__number_ranges,
  (ProtobufCMessageInit) g_im__im_data_store4alarm__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__smoke_item__field_descriptors[2] =
{
  {
    "smoke_id",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__SmokeItem, has_smoke_id),
    offsetof(GIm__SmokeItem, smoke_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "smoke_state",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__SmokeItem, has_smoke_state),
    offsetof(GIm__SmokeItem, smoke_state),
    &g_im__device_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__smoke_item__field_indices_by_name[] = {
  0,   /* field[0] = smoke_id */
  1,   /* field[1] = smoke_state */
};
static const ProtobufCIntRange g_im__smoke_item__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor g_im__smoke_item__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.smoke_item",
  "SmokeItem",
  "GIm__SmokeItem",
  "g_im",
  sizeof(GIm__SmokeItem),
  2,
  g_im__smoke_item__field_descriptors,
  g_im__smoke_item__field_indices_by_name,
  1,  g_im__smoke_item__number_ranges,
  (ProtobufCMessageInit) g_im__smoke_item__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__smoke_data__field_descriptors[2] =
{
  {
    "state",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__SmokeData, has_state),
    offsetof(GIm__SmokeData, state),
    &g_im__device_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "smoke_item",
    6,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__SmokeData, n_smoke_item),
    offsetof(GIm__SmokeData, smoke_item),
    &g_im__smoke_item__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__smoke_data__field_indices_by_name[] = {
  1,   /* field[1] = smoke_item */
  0,   /* field[0] = state */
};
static const ProtobufCIntRange g_im__smoke_data__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor g_im__smoke_data__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.smoke_data",
  "SmokeData",
  "GIm__SmokeData",
  "g_im",
  sizeof(GIm__SmokeData),
  2,
  g_im__smoke_data__field_descriptors,
  g_im__smoke_data__field_indices_by_name,
  1,  g_im__smoke_data__number_ranges,
  (ProtobufCMessageInit) g_im__smoke_data__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_co_item__field_descriptors[3] =
{
  {
    "co_id",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImCoItem, has_co_id),
    offsetof(GIm__ImCoItem, co_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "co_state",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImCoItem, has_co_state),
    offsetof(GIm__ImCoItem, co_state),
    &g_im__device_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "solubility",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImCoItem, has_solubility),
    offsetof(GIm__ImCoItem, solubility),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_co_item__field_indices_by_name[] = {
  0,   /* field[0] = co_id */
  1,   /* field[1] = co_state */
  2,   /* field[2] = solubility */
};
static const ProtobufCIntRange g_im__im_co_item__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor g_im__im_co_item__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_co_item",
  "ImCoItem",
  "GIm__ImCoItem",
  "g_im",
  sizeof(GIm__ImCoItem),
  3,
  g_im__im_co_item__field_descriptors,
  g_im__im_co_item__field_indices_by_name,
  1,  g_im__im_co_item__number_ranges,
  (ProtobufCMessageInit) g_im__im_co_item__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_co_data__field_descriptors[2] =
{
  {
    "state",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImCoData, has_state),
    offsetof(GIm__ImCoData, state),
    &g_im__device_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "im_co_item",
    6,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__ImCoData, n_im_co_item),
    offsetof(GIm__ImCoData, im_co_item),
    &g_im__im_co_item__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_co_data__field_indices_by_name[] = {
  1,   /* field[1] = im_co_item */
  0,   /* field[0] = state */
};
static const ProtobufCIntRange g_im__im_co_data__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor g_im__im_co_data__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_co_data",
  "ImCoData",
  "GIm__ImCoData",
  "g_im",
  sizeof(GIm__ImCoData),
  2,
  g_im__im_co_data__field_descriptors,
  g_im__im_co_data__field_indices_by_name,
  1,  g_im__im_co_data__number_ranges,
  (ProtobufCMessageInit) g_im__im_co_data__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_fan__item__field_descriptors[2] =
{
  {
    "fan_id",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImFanItem, has_fan_id),
    offsetof(GIm__ImFanItem, fan_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "fan_state",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImFanItem, has_fan_state),
    offsetof(GIm__ImFanItem, fan_state),
    &g_im__device_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_fan__item__field_indices_by_name[] = {
  0,   /* field[0] = fan_id */
  1,   /* field[1] = fan_state */
};
static const ProtobufCIntRange g_im__im_fan__item__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor g_im__im_fan__item__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_fan_Item",
  "ImFanItem",
  "GIm__ImFanItem",
  "g_im",
  sizeof(GIm__ImFanItem),
  2,
  g_im__im_fan__item__field_descriptors,
  g_im__im_fan__item__field_indices_by_name,
  1,  g_im__im_fan__item__number_ranges,
  (ProtobufCMessageInit) g_im__im_fan__item__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_fan_data__field_descriptors[2] =
{
  {
    "state",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImFanData, has_state),
    offsetof(GIm__ImFanData, state),
    &g_im__device_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "fan_item",
    7,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__ImFanData, n_fan_item),
    offsetof(GIm__ImFanData, fan_item),
    &g_im__im_fan__item__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_fan_data__field_indices_by_name[] = {
  1,   /* field[1] = fan_item */
  0,   /* field[0] = state */
};
static const ProtobufCIntRange g_im__im_fan_data__number_ranges[1 + 1] =
{
  { 6, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor g_im__im_fan_data__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_fan_data",
  "ImFanData",
  "GIm__ImFanData",
  "g_im",
  sizeof(GIm__ImFanData),
  2,
  g_im__im_fan_data__field_descriptors,
  g_im__im_fan_data__field_indices_by_name,
  1,  g_im__im_fan_data__number_ranges,
  (ProtobufCMessageInit) g_im__im_fan_data__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_temp_item__field_descriptors[3] =
{
  {
    "temp_id",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImTempItem, has_temp_id),
    offsetof(GIm__ImTempItem, temp_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "temp_value",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImTempItem, has_temp_value),
    offsetof(GIm__ImTempItem, temp_value),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "state",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImTempItem, has_state),
    offsetof(GIm__ImTempItem, state),
    &g_im__device_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_temp_item__field_indices_by_name[] = {
  2,   /* field[2] = state */
  0,   /* field[0] = temp_id */
  1,   /* field[1] = temp_value */
};
static const ProtobufCIntRange g_im__im_temp_item__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor g_im__im_temp_item__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_temp_item",
  "ImTempItem",
  "GIm__ImTempItem",
  "g_im",
  sizeof(GIm__ImTempItem),
  3,
  g_im__im_temp_item__field_descriptors,
  g_im__im_temp_item__field_indices_by_name,
  1,  g_im__im_temp_item__number_ranges,
  (ProtobufCMessageInit) g_im__im_temp_item__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__env_temp_data__field_descriptors[2] =
{
  {
    "state",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__EnvTempData, has_state),
    offsetof(GIm__EnvTempData, state),
    &g_im__device_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "temp_detail",
    6,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__EnvTempData, n_temp_detail),
    offsetof(GIm__EnvTempData, temp_detail),
    &g_im__im_temp_item__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__env_temp_data__field_indices_by_name[] = {
  0,   /* field[0] = state */
  1,   /* field[1] = temp_detail */
};
static const ProtobufCIntRange g_im__env_temp_data__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor g_im__env_temp_data__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.env_temp_data",
  "EnvTempData",
  "GIm__EnvTempData",
  "g_im",
  sizeof(GIm__EnvTempData),
  2,
  g_im__env_temp_data__field_descriptors,
  g_im__env_temp_data__field_indices_by_name,
  1,  g_im__env_temp_data__number_ranges,
  (ProtobufCMessageInit) g_im__env_temp_data__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__negativepressure_data__field_descriptors[6] =
{
  {
    "state",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__NegativepressureData, has_state),
    offsetof(GIm__NegativepressureData, state),
    &g_im__device_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "negativepressure_id",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__NegativepressureData, has_negativepressure_id),
    offsetof(GIm__NegativepressureData, negativepressure_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "negativepressure_value",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__NegativepressureData, has_negativepressure_value),
    offsetof(GIm__NegativepressureData, negativepressure_value),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "negativepressure_alarm_data",
    8,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__NegativepressureData, n_negativepressure_alarm_data),
    offsetof(GIm__NegativepressureData, negativepressure_alarm_data),
    &g_im__alarm_set_param_data__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "negativepressure_action",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__NegativepressureData, has_negativepressure_action),
    offsetof(GIm__NegativepressureData, negativepressure_action),
    &g_im__negativepressure_action__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "negativepressure_operation_items",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__NegativepressureData, has_negativepressure_operation_items),
    offsetof(GIm__NegativepressureData, negativepressure_operation_items),
    &g_im__negativepressure_operation_items__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__negativepressure_data__field_indices_by_name[] = {
  4,   /* field[4] = negativepressure_action */
  3,   /* field[3] = negativepressure_alarm_data */
  1,   /* field[1] = negativepressure_id */
  5,   /* field[5] = negativepressure_operation_items */
  2,   /* field[2] = negativepressure_value */
  0,   /* field[0] = state */
};
static const ProtobufCIntRange g_im__negativepressure_data__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 6 }
};
const ProtobufCMessageDescriptor g_im__negativepressure_data__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.negativepressure_data",
  "NegativepressureData",
  "GIm__NegativepressureData",
  "g_im",
  sizeof(GIm__NegativepressureData),
  6,
  g_im__negativepressure_data__field_descriptors,
  g_im__negativepressure_data__field_indices_by_name,
  1,  g_im__negativepressure_data__number_ranges,
  (ProtobufCMessageInit) g_im__negativepressure_data__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__alarm_param_data__field_descriptors[4] =
{
  {
    "param_id",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__AlarmParamData, has_param_id),
    offsetof(GIm__AlarmParamData, param_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "param_value",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__AlarmParamData, has_param_value),
    offsetof(GIm__AlarmParamData, param_value),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "unit_name",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__AlarmParamData, unit_name),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "alarm_time",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SINT64,
    offsetof(GIm__AlarmParamData, has_alarm_time),
    offsetof(GIm__AlarmParamData, alarm_time),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__alarm_param_data__field_indices_by_name[] = {
  3,   /* field[3] = alarm_time */
  0,   /* field[0] = param_id */
  1,   /* field[1] = param_value */
  2,   /* field[2] = unit_name */
};
static const ProtobufCIntRange g_im__alarm_param_data__number_ranges[1 + 1] =
{
  { 6, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor g_im__alarm_param_data__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.alarm_param_data",
  "AlarmParamData",
  "GIm__AlarmParamData",
  "g_im",
  sizeof(GIm__AlarmParamData),
  4,
  g_im__alarm_param_data__field_descriptors,
  g_im__alarm_param_data__field_indices_by_name,
  1,  g_im__alarm_param_data__number_ranges,
  (ProtobufCMessageInit) g_im__alarm_param_data__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__alarm_set_param_data__field_descriptors[2] =
{
  {
    "param_name",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__AlarmSetParamData, param_name),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "param_value",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__AlarmSetParamData, has_param_value),
    offsetof(GIm__AlarmSetParamData, param_value),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__alarm_set_param_data__field_indices_by_name[] = {
  0,   /* field[0] = param_name */
  1,   /* field[1] = param_value */
};
static const ProtobufCIntRange g_im__alarm_set_param_data__number_ranges[1 + 1] =
{
  { 6, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor g_im__alarm_set_param_data__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.alarm_set_param_data",
  "AlarmSetParamData",
  "GIm__AlarmSetParamData",
  "g_im",
  sizeof(GIm__AlarmSetParamData),
  2,
  g_im__alarm_set_param_data__field_descriptors,
  g_im__alarm_set_param_data__field_indices_by_name,
  1,  g_im__alarm_set_param_data__number_ranges,
  (ProtobufCMessageInit) g_im__alarm_set_param_data__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__serucrity_alarm_data__field_descriptors[3] =
{
  {
    "alarm_code",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__SerucrityAlarmData, alarm_code),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "alarm_param_data",
    6,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__SerucrityAlarmData, n_alarm_param_data),
    offsetof(GIm__SerucrityAlarmData, alarm_param_data),
    &g_im__alarm_param_data__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "alarm_set_param_data",
    7,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__SerucrityAlarmData, n_alarm_set_param_data),
    offsetof(GIm__SerucrityAlarmData, alarm_set_param_data),
    &g_im__alarm_set_param_data__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__serucrity_alarm_data__field_indices_by_name[] = {
  0,   /* field[0] = alarm_code */
  1,   /* field[1] = alarm_param_data */
  2,   /* field[2] = alarm_set_param_data */
};
static const ProtobufCIntRange g_im__serucrity_alarm_data__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor g_im__serucrity_alarm_data__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.serucrity_alarm_data",
  "SerucrityAlarmData",
  "GIm__SerucrityAlarmData",
  "g_im",
  sizeof(GIm__SerucrityAlarmData),
  3,
  g_im__serucrity_alarm_data__field_descriptors,
  g_im__serucrity_alarm_data__field_indices_by_name,
  1,  g_im__serucrity_alarm_data__number_ranges,
  (ProtobufCMessageInit) g_im__serucrity_alarm_data__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__serucrity_combination_alarm_data__field_descriptors[7] =
{
  {
    "rule_name",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__SerucrityCombinationAlarmData, rule_name),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "action_name",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__SerucrityCombinationAlarmData, action_name),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "alarm_time",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SINT64,
    offsetof(GIm__SerucrityCombinationAlarmData, has_alarm_time),
    offsetof(GIm__SerucrityCombinationAlarmData, alarm_time),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "reset_state",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__SerucrityCombinationAlarmData, has_reset_state),
    offsetof(GIm__SerucrityCombinationAlarmData, reset_state),
    &g_im__serucrity_reset_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "secondary_reset_state",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__SerucrityCombinationAlarmData, has_secondary_reset_state),
    offsetof(GIm__SerucrityCombinationAlarmData, secondary_reset_state),
    &g_im__serucrity_reset_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "secondary_security_result",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__SerucrityCombinationAlarmData, has_secondary_security_result),
    offsetof(GIm__SerucrityCombinationAlarmData, secondary_security_result),
    &g_im__secondary_security_result_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "secondary_security_time",
    11,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SINT64,
    offsetof(GIm__SerucrityCombinationAlarmData, has_secondary_security_time),
    offsetof(GIm__SerucrityCombinationAlarmData, secondary_security_time),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__serucrity_combination_alarm_data__field_indices_by_name[] = {
  1,   /* field[1] = action_name */
  2,   /* field[2] = alarm_time */
  3,   /* field[3] = reset_state */
  0,   /* field[0] = rule_name */
  4,   /* field[4] = secondary_reset_state */
  5,   /* field[5] = secondary_security_result */
  6,   /* field[6] = secondary_security_time */
};
static const ProtobufCIntRange g_im__serucrity_combination_alarm_data__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 7 }
};
const ProtobufCMessageDescriptor g_im__serucrity_combination_alarm_data__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.serucrity_combination_alarm_data",
  "SerucrityCombinationAlarmData",
  "GIm__SerucrityCombinationAlarmData",
  "g_im",
  sizeof(GIm__SerucrityCombinationAlarmData),
  7,
  g_im__serucrity_combination_alarm_data__field_descriptors,
  g_im__serucrity_combination_alarm_data__field_indices_by_name,
  1,  g_im__serucrity_combination_alarm_data__number_ranges,
  (ProtobufCMessageInit) g_im__serucrity_combination_alarm_data__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__lowercomputer_data__field_descriptors[2] =
{
  {
    "abnormal_time",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED64,
    offsetof(GIm__LowercomputerData, has_abnormal_time),
    offsetof(GIm__LowercomputerData, abnormal_time),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "lowercomputer_status",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__LowercomputerData, has_lowercomputer_status),
    offsetof(GIm__LowercomputerData, lowercomputer_status),
    &g_im__lowercomputer_status__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__lowercomputer_data__field_indices_by_name[] = {
  0,   /* field[0] = abnormal_time */
  1,   /* field[1] = lowercomputer_status */
};
static const ProtobufCIntRange g_im__lowercomputer_data__number_ranges[2 + 1] =
{
  { 5, 0 },
  { 7, 1 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor g_im__lowercomputer_data__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.lowercomputer_data",
  "LowercomputerData",
  "GIm__LowercomputerData",
  "g_im",
  sizeof(GIm__LowercomputerData),
  2,
  g_im__lowercomputer_data__field_descriptors,
  g_im__lowercomputer_data__field_indices_by_name,
  2,  g_im__lowercomputer_data__number_ranges,
  (ProtobufCMessageInit) g_im__lowercomputer_data__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__plc_failure_data__field_descriptors[3] =
{
  {
    "plc_message",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED64,
    offsetof(GIm__PlcFailureData, has_plc_message),
    offsetof(GIm__PlcFailureData, plc_message),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "general_failure",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED64,
    offsetof(GIm__PlcFailureData, has_general_failure),
    offsetof(GIm__PlcFailureData, general_failure),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "security_failure",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED64,
    offsetof(GIm__PlcFailureData, has_security_failure),
    offsetof(GIm__PlcFailureData, security_failure),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__plc_failure_data__field_indices_by_name[] = {
  1,   /* field[1] = general_failure */
  0,   /* field[0] = plc_message */
  2,   /* field[2] = security_failure */
};
static const ProtobufCIntRange g_im__plc_failure_data__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor g_im__plc_failure_data__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.plc_failure_data",
  "PlcFailureData",
  "GIm__PlcFailureData",
  "g_im",
  sizeof(GIm__PlcFailureData),
  3,
  g_im__plc_failure_data__field_descriptors,
  g_im__plc_failure_data__field_indices_by_name,
  1,  g_im__plc_failure_data__number_ranges,
  (ProtobufCMessageInit) g_im__plc_failure_data__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_stock_security_info__field_descriptors[29] =
{
  {
    "stock_no",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImStockSecurityInfo, has_stock_no),
    offsetof(GIm__ImStockSecurityInfo, stock_no),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "stockdoor_state",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImStockSecurityInfo, has_stockdoor_state),
    offsetof(GIm__ImStockSecurityInfo, stockdoor_state),
    &g_im__door_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "tray_state",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImStockSecurityInfo, has_tray_state),
    offsetof(GIm__ImStockSecurityInfo, tray_state),
    &g_im__tray_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "accessdoor_state",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImStockSecurityInfo, has_accessdoor_state),
    offsetof(GIm__ImStockSecurityInfo, accessdoor_state),
    &g_im__accessdoor_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "firedoor_state",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImStockSecurityInfo, has_firedoor_state),
    offsetof(GIm__ImStockSecurityInfo, firedoor_state),
    &g_im__firedoor_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "needlebed_out_state",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImStockSecurityInfo, has_needlebed_out_state),
    offsetof(GIm__ImStockSecurityInfo, needlebed_out_state),
    &g_im__needlebed_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "needlebed_press_state",
    11,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImStockSecurityInfo, has_needlebed_press_state),
    offsetof(GIm__ImStockSecurityInfo, needlebed_press_state),
    &g_im__needlebed_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "scapegoat_state",
    12,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImStockSecurityInfo, has_scapegoat_state),
    offsetof(GIm__ImStockSecurityInfo, scapegoat_state),
    &g_im__scapegoat_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "smoke_data",
    13,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImStockSecurityInfo, smoke_data),
    &g_im__smoke_data__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "reservoir_state",
    14,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImStockSecurityInfo, has_reservoir_state),
    offsetof(GIm__ImStockSecurityInfo, reservoir_state),
    &g_im__reservoir_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "co_data",
    15,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImStockSecurityInfo, co_data),
    &g_im__im_co_data__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "security_fan_data",
    16,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImStockSecurityInfo, security_fan_data),
    &g_im__im_fan_data__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "power_fan_data",
    17,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImStockSecurityInfo, power_fan_data),
    &g_im__im_fan_data__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "cabletray_fan_data",
    18,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImStockSecurityInfo, cabletray_fan_data),
    &g_im__im_fan_data__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "env_temp_data",
    19,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImStockSecurityInfo, env_temp_data),
    &g_im__env_temp_data__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "power_fan_temp_data",
    20,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImStockSecurityInfo, power_fan_temp_data),
    &g_im__env_temp_data__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "negativepressure_data",
    21,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImStockSecurityInfo, negativepressure_data),
    &g_im__negativepressure_data__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "plc_status",
    22,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImStockSecurityInfo, has_plc_status),
    offsetof(GIm__ImStockSecurityInfo, plc_status),
    &g_im__plc_status__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "lowercomputer_data",
    23,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__ImStockSecurityInfo, n_lowercomputer_data),
    offsetof(GIm__ImStockSecurityInfo, lowercomputer_data),
    &g_im__lowercomputer_data__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "stock_model",
    24,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImStockSecurityInfo, has_stock_model),
    offsetof(GIm__ImStockSecurityInfo, stock_model),
    &g_im__stock_model__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "serucrity_alarm_data",
    25,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__ImStockSecurityInfo, n_serucrity_alarm_data),
    offsetof(GIm__ImStockSecurityInfo, serucrity_alarm_data),
    &g_im__serucrity_alarm_data__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "combination_alarm_data",
    26,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__ImStockSecurityInfo, n_combination_alarm_data),
    offsetof(GIm__ImStockSecurityInfo, combination_alarm_data),
    &g_im__serucrity_combination_alarm_data__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "plc_failure_data",
    27,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImStockSecurityInfo, plc_failure_data),
    &g_im__plc_failure_data__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "stock_state",
    28,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImStockSecurityInfo, has_stock_state),
    offsetof(GIm__ImStockSecurityInfo, stock_state),
    &g_im__stock_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "security_runing_state",
    29,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImStockSecurityInfo, has_security_runing_state),
    offsetof(GIm__ImStockSecurityInfo, security_runing_state),
    &g_im__security_runing_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "electric_ball_valve_state",
    30,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImStockSecurityInfo, has_electric_ball_valve_state),
    offsetof(GIm__ImStockSecurityInfo, electric_ball_valve_state),
    &g_im__electric_ball_valve_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "security_message",
    31,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED64,
    offsetof(GIm__ImStockSecurityInfo, has_security_message),
    offsetof(GIm__ImStockSecurityInfo, security_message),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "suction_vacuum_valve_state",
    32,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImStockSecurityInfo, has_suction_vacuum_valve_state),
    offsetof(GIm__ImStockSecurityInfo, suction_vacuum_valve_state),
    &g_im__electric_ball_valve_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "vacuum_breaker_valve_state",
    33,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImStockSecurityInfo, has_vacuum_breaker_valve_state),
    offsetof(GIm__ImStockSecurityInfo, vacuum_breaker_valve_state),
    &g_im__electric_ball_valve_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_stock_security_info__field_indices_by_name[] = {
  3,   /* field[3] = accessdoor_state */
  13,   /* field[13] = cabletray_fan_data */
  10,   /* field[10] = co_data */
  21,   /* field[21] = combination_alarm_data */
  25,   /* field[25] = electric_ball_valve_state */
  14,   /* field[14] = env_temp_data */
  4,   /* field[4] = firedoor_state */
  18,   /* field[18] = lowercomputer_data */
  5,   /* field[5] = needlebed_out_state */
  6,   /* field[6] = needlebed_press_state */
  16,   /* field[16] = negativepressure_data */
  22,   /* field[22] = plc_failure_data */
  17,   /* field[17] = plc_status */
  12,   /* field[12] = power_fan_data */
  15,   /* field[15] = power_fan_temp_data */
  9,   /* field[9] = reservoir_state */
  7,   /* field[7] = scapegoat_state */
  11,   /* field[11] = security_fan_data */
  26,   /* field[26] = security_message */
  24,   /* field[24] = security_runing_state */
  20,   /* field[20] = serucrity_alarm_data */
  8,   /* field[8] = smoke_data */
  19,   /* field[19] = stock_model */
  0,   /* field[0] = stock_no */
  23,   /* field[23] = stock_state */
  1,   /* field[1] = stockdoor_state */
  27,   /* field[27] = suction_vacuum_valve_state */
  2,   /* field[2] = tray_state */
  28,   /* field[28] = vacuum_breaker_valve_state */
};
static const ProtobufCIntRange g_im__im_stock_security_info__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 29 }
};
const ProtobufCMessageDescriptor g_im__im_stock_security_info__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_stock_securityInfo",
  "ImStockSecurityInfo",
  "GIm__ImStockSecurityInfo",
  "g_im",
  sizeof(GIm__ImStockSecurityInfo),
  29,
  g_im__im_stock_security_info__field_descriptors,
  g_im__im_stock_security_info__field_indices_by_name,
  1,  g_im__im_stock_security_info__number_ranges,
  (ProtobufCMessageInit) g_im__im_stock_security_info__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_security_data__field_descriptors[2] =
{
  {
    "head",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImSecurityData, head),
    &g_im__im_cmd_head__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "stock_securityInfo",
    6,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__ImSecurityData, n_stock_securityinfo),
    offsetof(GIm__ImSecurityData, stock_securityinfo),
    &g_im__im_stock_security_info__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_security_data__field_indices_by_name[] = {
  0,   /* field[0] = head */
  1,   /* field[1] = stock_securityInfo */
};
static const ProtobufCIntRange g_im__im_security_data__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor g_im__im_security_data__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_security_data",
  "ImSecurityData",
  "GIm__ImSecurityData",
  "g_im",
  sizeof(GIm__ImSecurityData),
  2,
  g_im__im_security_data__field_descriptors,
  g_im__im_security_data__field_indices_by_name,
  1,  g_im__im_security_data__number_ranges,
  (ProtobufCMessageInit) g_im__im_security_data__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_device_update_info__field_descriptors[6] =
{
  {
    "update_id",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImDeviceUpdateInfo, update_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "device_type",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImDeviceUpdateInfo, has_device_type),
    offsetof(GIm__ImDeviceUpdateInfo, device_type),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "device_addr",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImDeviceUpdateInfo, device_addr),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "device_port",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImDeviceUpdateInfo, has_device_port),
    offsetof(GIm__ImDeviceUpdateInfo, device_port),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "update_status",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImDeviceUpdateInfo, has_update_status),
    offsetof(GIm__ImDeviceUpdateInfo, update_status),
    &g_im__deviece_update_status__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "update_errorcode",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImDeviceUpdateInfo, has_update_errorcode),
    offsetof(GIm__ImDeviceUpdateInfo, update_errorcode),
    &g_im__deviece_update_errorcode__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_device_update_info__field_indices_by_name[] = {
  2,   /* field[2] = device_addr */
  3,   /* field[3] = device_port */
  1,   /* field[1] = device_type */
  5,   /* field[5] = update_errorcode */
  0,   /* field[0] = update_id */
  4,   /* field[4] = update_status */
};
static const ProtobufCIntRange g_im__im_device_update_info__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 6 }
};
const ProtobufCMessageDescriptor g_im__im_device_update_info__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_device_update_info",
  "ImDeviceUpdateInfo",
  "GIm__ImDeviceUpdateInfo",
  "g_im",
  sizeof(GIm__ImDeviceUpdateInfo),
  6,
  g_im__im_device_update_info__field_descriptors,
  g_im__im_device_update_info__field_indices_by_name,
  1,  g_im__im_device_update_info__number_ranges,
  (ProtobufCMessageInit) g_im__im_device_update_info__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_device_passthrough_response__field_descriptors[5] =
{
  {
    "address",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImDevicePassthroughResponse, address),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "port",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImDevicePassthroughResponse, port),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "content",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImDevicePassthroughResponse, content),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "channel_id",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImDevicePassthroughResponse, channel_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "result",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImDevicePassthroughResponse, has_result),
    offsetof(GIm__ImDevicePassthroughResponse, result),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_device_passthrough_response__field_indices_by_name[] = {
  0,   /* field[0] = address */
  3,   /* field[3] = channel_id */
  2,   /* field[2] = content */
  1,   /* field[1] = port */
  4,   /* field[4] = result */
};
static const ProtobufCIntRange g_im__im_device_passthrough_response__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 5 }
};
const ProtobufCMessageDescriptor g_im__im_device_passthrough_response__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_device_passthrough_response",
  "ImDevicePassthroughResponse",
  "GIm__ImDevicePassthroughResponse",
  "g_im",
  sizeof(GIm__ImDevicePassthroughResponse),
  5,
  g_im__im_device_passthrough_response__field_descriptors,
  g_im__im_device_passthrough_response__field_indices_by_name,
  1,  g_im__im_device_passthrough_response__number_ranges,
  (ProtobufCMessageInit) g_im__im_device_passthrough_response__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_device_upgrade_data__field_descriptors[4] =
{
  {
    "head",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImDeviceUpgradeData, head),
    &g_im__im_cmd_head__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "device_upgrade_type",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImDeviceUpgradeData, has_device_upgrade_type),
    offsetof(GIm__ImDeviceUpgradeData, device_upgrade_type),
    &g_im__device_upgrade_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "update_data",
    7,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__ImDeviceUpgradeData, n_update_data),
    offsetof(GIm__ImDeviceUpgradeData, update_data),
    &g_im__im_device_update_info__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "passthrough_data",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImDeviceUpgradeData, passthrough_data),
    &g_im__im_device_passthrough_response__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_device_upgrade_data__field_indices_by_name[] = {
  1,   /* field[1] = device_upgrade_type */
  0,   /* field[0] = head */
  3,   /* field[3] = passthrough_data */
  2,   /* field[2] = update_data */
};
static const ProtobufCIntRange g_im__im_device_upgrade_data__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor g_im__im_device_upgrade_data__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_device_upgrade_data",
  "ImDeviceUpgradeData",
  "GIm__ImDeviceUpgradeData",
  "g_im",
  sizeof(GIm__ImDeviceUpgradeData),
  4,
  g_im__im_device_upgrade_data__field_descriptors,
  g_im__im_device_upgrade_data__field_indices_by_name,
  1,  g_im__im_device_upgrade_data__number_ranges,
  (ProtobufCMessageInit) g_im__im_device_upgrade_data__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_device_upgrad_notify__field_descriptors[1] =
{
  {
    "device_upgrade_type",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImDeviceUpgradNotify, has_device_upgrade_type),
    offsetof(GIm__ImDeviceUpgradNotify, device_upgrade_type),
    &g_im__device_upgrade_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_device_upgrad_notify__field_indices_by_name[] = {
  0,   /* field[0] = device_upgrade_type */
};
static const ProtobufCIntRange g_im__im_device_upgrad_notify__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor g_im__im_device_upgrad_notify__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_device_upgrad_notify",
  "ImDeviceUpgradNotify",
  "GIm__ImDeviceUpgradNotify",
  "g_im",
  sizeof(GIm__ImDeviceUpgradNotify),
  1,
  g_im__im_device_upgrad_notify__field_descriptors,
  g_im__im_device_upgrad_notify__field_indices_by_name,
  1,  g_im__im_device_upgrad_notify__number_ranges,
  (ProtobufCMessageInit) g_im__im_device_upgrad_notify__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_netcard_param__field_descriptors[11] =
{
  {
    "mobile",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(GIm__ImNetcardParam, has_mobile),
    offsetof(GIm__ImNetcardParam, mobile),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "dhcp",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(GIm__ImNetcardParam, has_dhcp),
    offsetof(GIm__ImNetcardParam, dhcp),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ipaddr",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImNetcardParam, has_ipaddr),
    offsetof(GIm__ImNetcardParam, ipaddr),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "netmsk",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImNetcardParam, has_netmsk),
    offsetof(GIm__ImNetcardParam, netmsk),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "gateway",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImNetcardParam, has_gateway),
    offsetof(GIm__ImNetcardParam, gateway),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "mac_addr",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImNetcardParam, mac_addr),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "dns1",
    11,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImNetcardParam, has_dns1),
    offsetof(GIm__ImNetcardParam, dns1),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "dns2",
    12,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImNetcardParam, has_dns2),
    offsetof(GIm__ImNetcardParam, dns2),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "cmd_port",
    13,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImNetcardParam, has_cmd_port),
    offsetof(GIm__ImNetcardParam, cmd_port),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ui_port",
    14,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImNetcardParam, has_ui_port),
    offsetof(GIm__ImNetcardParam, ui_port),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "boardcast_port",
    15,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImNetcardParam, has_boardcast_port),
    offsetof(GIm__ImNetcardParam, boardcast_port),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_netcard_param__field_indices_by_name[] = {
  10,   /* field[10] = boardcast_port */
  8,   /* field[8] = cmd_port */
  1,   /* field[1] = dhcp */
  6,   /* field[6] = dns1 */
  7,   /* field[7] = dns2 */
  4,   /* field[4] = gateway */
  2,   /* field[2] = ipaddr */
  5,   /* field[5] = mac_addr */
  0,   /* field[0] = mobile */
  3,   /* field[3] = netmsk */
  9,   /* field[9] = ui_port */
};
static const ProtobufCIntRange g_im__im_netcard_param__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 11 }
};
const ProtobufCMessageDescriptor g_im__im_netcard_param__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_netcard_param",
  "ImNetcardParam",
  "GIm__ImNetcardParam",
  "g_im",
  sizeof(GIm__ImNetcardParam),
  11,
  g_im__im_netcard_param__field_descriptors,
  g_im__im_netcard_param__field_indices_by_name,
  1,  g_im__im_netcard_param__number_ranges,
  (ProtobufCMessageInit) g_im__im_netcard_param__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_master_channel_ret__field_descriptors[2] =
{
  {
    "channel_id",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImMasterChannelRet, has_channel_id),
    offsetof(GIm__ImMasterChannelRet, channel_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "result",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImMasterChannelRet, has_result),
    offsetof(GIm__ImMasterChannelRet, result),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_master_channel_ret__field_indices_by_name[] = {
  0,   /* field[0] = channel_id */
  1,   /* field[1] = result */
};
static const ProtobufCIntRange g_im__im_master_channel_ret__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor g_im__im_master_channel_ret__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_master_channel_ret",
  "ImMasterChannelRet",
  "GIm__ImMasterChannelRet",
  "g_im",
  sizeof(GIm__ImMasterChannelRet),
  2,
  g_im__im_master_channel_ret__field_descriptors,
  g_im__im_master_channel_ret__field_indices_by_name,
  1,  g_im__im_master_channel_ret__number_ranges,
  (ProtobufCMessageInit) g_im__im_master_channel_ret__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_step_jump__field_descriptors[2] =
{
  {
    "step",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImStepJump, has_step),
    offsetof(GIm__ImStepJump, step),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "channels",
    6,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImStepJump, n_channels),
    offsetof(GIm__ImStepJump, channels),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_step_jump__field_indices_by_name[] = {
  1,   /* field[1] = channels */
  0,   /* field[0] = step */
};
static const ProtobufCIntRange g_im__im_step_jump__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor g_im__im_step_jump__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_step_jump",
  "ImStepJump",
  "GIm__ImStepJump",
  "g_im",
  sizeof(GIm__ImStepJump),
  2,
  g_im__im_step_jump__field_descriptors,
  g_im__im_step_jump__field_indices_by_name,
  1,  g_im__im_step_jump__number_ranges,
  (ProtobufCMessageInit) g_im__im_step_jump__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_channel_continue_ret__field_descriptors[2] =
{
  {
    "step",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImChannelContinueRet, has_step),
    offsetof(GIm__ImChannelContinueRet, step),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "channel_ret",
    6,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__ImChannelContinueRet, n_channel_ret),
    offsetof(GIm__ImChannelContinueRet, channel_ret),
    &g_im__im_master_channel_ret__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_channel_continue_ret__field_indices_by_name[] = {
  1,   /* field[1] = channel_ret */
  0,   /* field[0] = step */
};
static const ProtobufCIntRange g_im__im_channel_continue_ret__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor g_im__im_channel_continue_ret__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_channel_continue_ret",
  "ImChannelContinueRet",
  "GIm__ImChannelContinueRet",
  "g_im",
  sizeof(GIm__ImChannelContinueRet),
  2,
  g_im__im_channel_continue_ret__field_descriptors,
  g_im__im_channel_continue_ret__field_indices_by_name,
  1,  g_im__im_channel_continue_ret__number_ranges,
  (ProtobufCMessageInit) g_im__im_channel_continue_ret__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_channel_enable_byip_result__field_descriptors[2] =
{
  {
    "ipaddr",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImChannelEnableByipResult, has_ipaddr),
    offsetof(GIm__ImChannelEnableByipResult, ipaddr),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "result",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImChannelEnableByipResult, has_result),
    offsetof(GIm__ImChannelEnableByipResult, result),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_channel_enable_byip_result__field_indices_by_name[] = {
  0,   /* field[0] = ipaddr */
  1,   /* field[1] = result */
};
static const ProtobufCIntRange g_im__im_channel_enable_byip_result__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor g_im__im_channel_enable_byip_result__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_channel_enable_byip_result",
  "ImChannelEnableByipResult",
  "GIm__ImChannelEnableByipResult",
  "g_im",
  sizeof(GIm__ImChannelEnableByipResult),
  2,
  g_im__im_channel_enable_byip_result__field_descriptors,
  g_im__im_channel_enable_byip_result__field_indices_by_name,
  1,  g_im__im_channel_enable_byip_result__number_ranges,
  (ProtobufCMessageInit) g_im__im_channel_enable_byip_result__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_channel_appoint_stop__field_descriptors[6] =
{
  {
    "is_set",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(GIm__ImChannelAppointStop, has_is_set),
    offsetof(GIm__ImChannelAppointStop, is_set),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "stop_type",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImChannelAppointStop, has_stop_type),
    offsetof(GIm__ImChannelAppointStop, stop_type),
    &g_im__im_appoint_stop_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "invalid4curstep",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(GIm__ImChannelAppointStop, has_invalid4curstep),
    offsetof(GIm__ImChannelAppointStop, invalid4curstep),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "step",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImChannelAppointStop, has_step),
    offsetof(GIm__ImChannelAppointStop, step),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "loop_times",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImChannelAppointStop, has_loop_times),
    offsetof(GIm__ImChannelAppointStop, loop_times),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "msec",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED64,
    offsetof(GIm__ImChannelAppointStop, has_msec),
    offsetof(GIm__ImChannelAppointStop, msec),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_channel_appoint_stop__field_indices_by_name[] = {
  2,   /* field[2] = invalid4curstep */
  0,   /* field[0] = is_set */
  4,   /* field[4] = loop_times */
  5,   /* field[5] = msec */
  3,   /* field[3] = step */
  1,   /* field[1] = stop_type */
};
static const ProtobufCIntRange g_im__im_channel_appoint_stop__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 6 }
};
const ProtobufCMessageDescriptor g_im__im_channel_appoint_stop__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_channel_appoint_stop",
  "ImChannelAppointStop",
  "GIm__ImChannelAppointStop",
  "g_im",
  sizeof(GIm__ImChannelAppointStop),
  6,
  g_im__im_channel_appoint_stop__field_descriptors,
  g_im__im_channel_appoint_stop__field_indices_by_name,
  1,  g_im__im_channel_appoint_stop__number_ranges,
  (ProtobufCMessageInit) g_im__im_channel_appoint_stop__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_security_stop_by_stock__field_descriptors[2] =
{
  {
    "stock_id",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImSecurityStopByStock, has_stock_id),
    offsetof(GIm__ImSecurityStopByStock, stock_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "success",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(GIm__ImSecurityStopByStock, has_success),
    offsetof(GIm__ImSecurityStopByStock, success),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_security_stop_by_stock__field_indices_by_name[] = {
  0,   /* field[0] = stock_id */
  1,   /* field[1] = success */
};
static const ProtobufCIntRange g_im__im_security_stop_by_stock__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor g_im__im_security_stop_by_stock__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_security_stop_byStock",
  "ImSecurityStopByStock",
  "GIm__ImSecurityStopByStock",
  "g_im",
  sizeof(GIm__ImSecurityStopByStock),
  2,
  g_im__im_security_stop_by_stock__field_descriptors,
  g_im__im_security_stop_by_stock__field_indices_by_name,
  1,  g_im__im_security_stop_by_stock__number_ranges,
  (ProtobufCMessageInit) g_im__im_security_stop_by_stock__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_channel_test__field_descriptors[2] =
{
  {
    "channel_id",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImChannelTest, has_channel_id),
    offsetof(GIm__ImChannelTest, channel_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "step_file_path",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImChannelTest, step_file_path),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_channel_test__field_indices_by_name[] = {
  0,   /* field[0] = channel_id */
  1,   /* field[1] = step_file_path */
};
static const ProtobufCIntRange g_im__im_channel_test__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor g_im__im_channel_test__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_channel_test",
  "ImChannelTest",
  "GIm__ImChannelTest",
  "g_im",
  sizeof(GIm__ImChannelTest),
  2,
  g_im__im_channel_test__field_descriptors,
  g_im__im_channel_test__field_indices_by_name,
  1,  g_im__im_channel_test__number_ranges,
  (ProtobufCMessageInit) g_im__im_channel_test__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_channel_clear_warn__field_descriptors[2] =
{
  {
    "channel_id",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SINT32,
    offsetof(GIm__ImChannelClearWarn, has_channel_id),
    offsetof(GIm__ImChannelClearWarn, channel_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "warn_type",
    6,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImChannelClearWarn, n_warn_type),
    offsetof(GIm__ImChannelClearWarn, warn_type),
    &g_im__im_warn_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_channel_clear_warn__field_indices_by_name[] = {
  0,   /* field[0] = channel_id */
  1,   /* field[1] = warn_type */
};
static const ProtobufCIntRange g_im__im_channel_clear_warn__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor g_im__im_channel_clear_warn__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_channel_clear_warn",
  "ImChannelClearWarn",
  "GIm__ImChannelClearWarn",
  "g_im",
  sizeof(GIm__ImChannelClearWarn),
  2,
  g_im__im_channel_clear_warn__field_descriptors,
  g_im__im_channel_clear_warn__field_indices_by_name,
  1,  g_im__im_channel_clear_warn__number_ranges,
  (ProtobufCMessageInit) g_im__im_channel_clear_warn__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_security_clear_warn__field_descriptors[2] =
{
  {
    "stock_no",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImSecurityClearWarn, has_stock_no),
    offsetof(GIm__ImSecurityClearWarn, stock_no),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "alarm_code",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImSecurityClearWarn, alarm_code),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_security_clear_warn__field_indices_by_name[] = {
  1,   /* field[1] = alarm_code */
  0,   /* field[0] = stock_no */
};
static const ProtobufCIntRange g_im__im_security_clear_warn__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor g_im__im_security_clear_warn__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_security_clear_warn",
  "ImSecurityClearWarn",
  "GIm__ImSecurityClearWarn",
  "g_im",
  sizeof(GIm__ImSecurityClearWarn),
  2,
  g_im__im_security_clear_warn__field_descriptors,
  g_im__im_security_clear_warn__field_indices_by_name,
  1,  g_im__im_security_clear_warn__number_ranges,
  (ProtobufCMessageInit) g_im__im_security_clear_warn__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_display_time_protection__field_descriptors[5] =
{
  {
    "enable",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(GIm__ImDisplayTimeProtection, has_enable),
    offsetof(GIm__ImDisplayTimeProtection, enable),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "sampling_interval",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImDisplayTimeProtection, has_sampling_interval),
    offsetof(GIm__ImDisplayTimeProtection, sampling_interval),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "record_time",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImDisplayTimeProtection, has_record_time),
    offsetof(GIm__ImDisplayTimeProtection, record_time),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "volt_upper_limit_protection",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(GIm__ImDisplayTimeProtection, has_volt_upper_limit_protection),
    offsetof(GIm__ImDisplayTimeProtection, volt_upper_limit_protection),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "volt_lower_limit_protection",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(GIm__ImDisplayTimeProtection, has_volt_lower_limit_protection),
    offsetof(GIm__ImDisplayTimeProtection, volt_lower_limit_protection),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_display_time_protection__field_indices_by_name[] = {
  0,   /* field[0] = enable */
  2,   /* field[2] = record_time */
  1,   /* field[1] = sampling_interval */
  4,   /* field[4] = volt_lower_limit_protection */
  3,   /* field[3] = volt_upper_limit_protection */
};
static const ProtobufCIntRange g_im__im_display_time_protection__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 5 }
};
const ProtobufCMessageDescriptor g_im__im_display_time_protection__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_display_time_protection",
  "ImDisplayTimeProtection",
  "GIm__ImDisplayTimeProtection",
  "g_im",
  sizeof(GIm__ImDisplayTimeProtection),
  5,
  g_im__im_display_time_protection__field_descriptors,
  g_im__im_display_time_protection__field_indices_by_name,
  1,  g_im__im_display_time_protection__number_ranges,
  (ProtobufCMessageInit) g_im__im_display_time_protection__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_soft_update__field_descriptors[2] =
{
  {
    "passwd",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImSoftUpdate, passwd),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "update_file_path",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImSoftUpdate, update_file_path),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_soft_update__field_indices_by_name[] = {
  0,   /* field[0] = passwd */
  1,   /* field[1] = update_file_path */
};
static const ProtobufCIntRange g_im__im_soft_update__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor g_im__im_soft_update__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_soft_update",
  "ImSoftUpdate",
  "GIm__ImSoftUpdate",
  "g_im",
  sizeof(GIm__ImSoftUpdate),
  2,
  g_im__im_soft_update__field_descriptors,
  g_im__im_soft_update__field_indices_by_name,
  1,  g_im__im_soft_update__number_ranges,
  (ProtobufCMessageInit) g_im__im_soft_update__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_device_update__field_descriptors[2] =
{
  {
    "check",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImDeviceUpdate, check),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "update_file_path",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImDeviceUpdate, update_file_path),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_device_update__field_indices_by_name[] = {
  0,   /* field[0] = check */
  1,   /* field[1] = update_file_path */
};
static const ProtobufCIntRange g_im__im_device_update__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor g_im__im_device_update__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_device_update",
  "ImDeviceUpdate",
  "GIm__ImDeviceUpdate",
  "g_im",
  sizeof(GIm__ImDeviceUpdate),
  2,
  g_im__im_device_update__field_descriptors,
  g_im__im_device_update__field_indices_by_name,
  1,  g_im__im_device_update__number_ranges,
  (ProtobufCMessageInit) g_im__im_device_update__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_device_passthrough__field_descriptors[5] =
{
  {
    "address",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImDevicePassthrough, address),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "port",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImDevicePassthrough, port),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "content",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImDevicePassthrough, content),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "im_communication_protocol",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImDevicePassthrough, has_im_communication_protocol),
    offsetof(GIm__ImDevicePassthrough, im_communication_protocol),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "channel_id",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImDevicePassthrough, channel_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_device_passthrough__field_indices_by_name[] = {
  0,   /* field[0] = address */
  4,   /* field[4] = channel_id */
  2,   /* field[2] = content */
  3,   /* field[3] = im_communication_protocol */
  1,   /* field[1] = port */
};
static const ProtobufCIntRange g_im__im_device_passthrough__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 5 }
};
const ProtobufCMessageDescriptor g_im__im_device_passthrough__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_device_passthrough",
  "ImDevicePassthrough",
  "GIm__ImDevicePassthrough",
  "g_im",
  sizeof(GIm__ImDevicePassthrough),
  5,
  g_im__im_device_passthrough__field_descriptors,
  g_im__im_device_passthrough__field_indices_by_name,
  1,  g_im__im_device_passthrough__number_ranges,
  (ProtobufCMessageInit) g_im__im_device_passthrough__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_cmd_request__field_descriptors[27] =
{
  {
    "cmd_head",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImCmdRequest, cmd_head),
    &g_im__im_cmd_head__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "chnl_nodes",
    6,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImCmdRequest, n_chnl_nodes),
    offsetof(GIm__ImCmdRequest, chnl_nodes),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "chnl_test_nodes",
    7,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__ImCmdRequest, n_chnl_test_nodes),
    offsetof(GIm__ImCmdRequest, chnl_test_nodes),
    &g_im__im_channel_test__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "step_nums",
    8,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImCmdRequest, n_step_nums),
    offsetof(GIm__ImCmdRequest, step_nums),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "update",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImCmdRequest, update),
    &g_im__im_soft_update__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "type",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImCmdRequest, has_type),
    offsetof(GIm__ImCmdRequest, type),
    &g_im__sysconf_update_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "time_set_msec",
    11,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED64,
    offsetof(GIm__ImCmdRequest, has_time_set_msec),
    offsetof(GIm__ImCmdRequest, time_set_msec),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "auth",
    12,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImCmdRequest, auth),
    &g_im__im_auth__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ipaddr_nodes",
    13,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImCmdRequest, n_ipaddr_nodes),
    offsetof(GIm__ImCmdRequest, ipaddr_nodes),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "unit_data",
    14,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImCmdRequest, unit_data),
    &g_im__im_data_store4unit__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "alarm_data",
    15,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImCmdRequest, alarm_data),
    &g_im__im_data_store4alarm__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "enable",
    16,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(GIm__ImCmdRequest, has_enable),
    offsetof(GIm__ImCmdRequest, enable),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "security_stop",
    17,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImCmdRequest, n_security_stop),
    offsetof(GIm__ImCmdRequest, security_stop),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "step_jump",
    18,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImCmdRequest, step_jump),
    &g_im__im_step_jump__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "chnl_appoint",
    19,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImCmdRequest, chnl_appoint),
    &g_im__im_channel_appoint_stop__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "warn_data",
    20,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__ImCmdRequest, n_warn_data),
    offsetof(GIm__ImCmdRequest, warn_data),
    &g_im__im_channel_clear_warn__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "transfer_model",
    21,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImCmdRequest, has_transfer_model),
    offsetof(GIm__ImCmdRequest, transfer_model),
    &g_im__security_transfer_model__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "security_clear_warn",
    22,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImCmdRequest, security_clear_warn),
    &g_im__im_security_clear_warn__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "dt_protection_data",
    23,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__ImCmdRequest, n_dt_protection_data),
    offsetof(GIm__ImCmdRequest, dt_protection_data),
    &g_im__im_display_time_protection__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "stock_no",
    24,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SINT32,
    offsetof(GIm__ImCmdRequest, has_stock_no),
    offsetof(GIm__ImCmdRequest, stock_no),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "serucrity_result",
    25,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImCmdRequest, serucrity_result),
    &g_im__execute_serucrity_result__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "device_update",
    26,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImCmdRequest, device_update),
    &g_im__im_device_update__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "device_passthrough",
    27,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImCmdRequest, device_passthrough),
    &g_im__im_device_passthrough__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "stock_state",
    28,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImCmdRequest, has_stock_state),
    offsetof(GIm__ImCmdRequest, stock_state),
    &g_im__stock_state__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "workjust_type",
    29,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImCmdRequest, has_workjust_type),
    offsetof(GIm__ImCmdRequest, workjust_type),
    &g_im__workjust_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "disable_security_code",
    30,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImCmdRequest, disable_security_code),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "adjust_power_mode",
    31,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImCmdRequest, has_adjust_power_mode),
    offsetof(GIm__ImCmdRequest, adjust_power_mode),
    &g_im__adjust_power_mode__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_cmd_request__field_indices_by_name[] = {
  26,   /* field[26] = adjust_power_mode */
  10,   /* field[10] = alarm_data */
  7,   /* field[7] = auth */
  14,   /* field[14] = chnl_appoint */
  1,   /* field[1] = chnl_nodes */
  2,   /* field[2] = chnl_test_nodes */
  0,   /* field[0] = cmd_head */
  22,   /* field[22] = device_passthrough */
  21,   /* field[21] = device_update */
  25,   /* field[25] = disable_security_code */
  18,   /* field[18] = dt_protection_data */
  11,   /* field[11] = enable */
  8,   /* field[8] = ipaddr_nodes */
  17,   /* field[17] = security_clear_warn */
  12,   /* field[12] = security_stop */
  20,   /* field[20] = serucrity_result */
  13,   /* field[13] = step_jump */
  3,   /* field[3] = step_nums */
  19,   /* field[19] = stock_no */
  23,   /* field[23] = stock_state */
  6,   /* field[6] = time_set_msec */
  16,   /* field[16] = transfer_model */
  5,   /* field[5] = type */
  9,   /* field[9] = unit_data */
  4,   /* field[4] = update */
  15,   /* field[15] = warn_data */
  24,   /* field[24] = workjust_type */
};
static const ProtobufCIntRange g_im__im_cmd_request__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 27 }
};
const ProtobufCMessageDescriptor g_im__im_cmd_request__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_cmd_request",
  "ImCmdRequest",
  "GIm__ImCmdRequest",
  "g_im",
  sizeof(GIm__ImCmdRequest),
  27,
  g_im__im_cmd_request__field_descriptors,
  g_im__im_cmd_request__field_indices_by_name,
  1,  g_im__im_cmd_request__number_ranges,
  (ProtobufCMessageInit) g_im__im_cmd_request__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__execute_serucrity_result__field_descriptors[2] =
{
  {
    "stock_no",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SINT32,
    offsetof(GIm__ExecuteSerucrityResult, has_stock_no),
    offsetof(GIm__ExecuteSerucrityResult, stock_no),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "execute_result",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ExecuteSerucrityResult, has_execute_result),
    offsetof(GIm__ExecuteSerucrityResult, execute_result),
    &g_im__execute_result__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__execute_serucrity_result__field_indices_by_name[] = {
  1,   /* field[1] = execute_result */
  0,   /* field[0] = stock_no */
};
static const ProtobufCIntRange g_im__execute_serucrity_result__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor g_im__execute_serucrity_result__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.execute_serucrity_result",
  "ExecuteSerucrityResult",
  "GIm__ExecuteSerucrityResult",
  "g_im",
  sizeof(GIm__ExecuteSerucrityResult),
  2,
  g_im__execute_serucrity_result__field_descriptors,
  g_im__execute_serucrity_result__field_indices_by_name,
  1,  g_im__execute_serucrity_result__number_ranges,
  (ProtobufCMessageInit) g_im__execute_serucrity_result__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_cmd_response__field_descriptors[11] =
{
  {
    "cmd_head",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImCmdResponse, cmd_head),
    &g_im__im_cmd_head__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "result",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImCmdResponse, has_result),
    offsetof(GIm__ImCmdResponse, result),
    &g_im__cmd_result__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "netcard_nodes",
    7,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__ImCmdResponse, n_netcard_nodes),
    offsetof(GIm__ImCmdResponse, netcard_nodes),
    &g_im__im_netcard_param__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "im_version",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImCmdResponse, im_version),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "type",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImCmdResponse, has_type),
    offsetof(GIm__ImCmdResponse, type),
    &g_im__sysconf_update_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "auth_info",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImCmdResponse, auth_info),
    &g_im__im_auth__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "chnl_ret_nodes",
    11,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__ImCmdResponse, n_chnl_ret_nodes),
    offsetof(GIm__ImCmdResponse, chnl_ret_nodes),
    &g_im__im_master_channel_ret__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "step_op",
    12,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImCmdResponse, step_op),
    &g_im__im_channel_continue_ret__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "byip_nodes",
    13,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__ImCmdResponse, n_byip_nodes),
    offsetof(GIm__ImCmdResponse, byip_nodes),
    &g_im__im_channel_enable_byip_result__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "self_check_result",
    14,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImCmdResponse, has_self_check_result),
    offsetof(GIm__ImCmdResponse, self_check_result),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "security_stop_ret",
    15,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__ImCmdResponse, n_security_stop_ret),
    offsetof(GIm__ImCmdResponse, security_stop_ret),
    &g_im__im_security_stop_by_stock__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_cmd_response__field_indices_by_name[] = {
  5,   /* field[5] = auth_info */
  8,   /* field[8] = byip_nodes */
  6,   /* field[6] = chnl_ret_nodes */
  0,   /* field[0] = cmd_head */
  3,   /* field[3] = im_version */
  2,   /* field[2] = netcard_nodes */
  1,   /* field[1] = result */
  10,   /* field[10] = security_stop_ret */
  9,   /* field[9] = self_check_result */
  7,   /* field[7] = step_op */
  4,   /* field[4] = type */
};
static const ProtobufCIntRange g_im__im_cmd_response__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 11 }
};
const ProtobufCMessageDescriptor g_im__im_cmd_response__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_cmd_response",
  "ImCmdResponse",
  "GIm__ImCmdResponse",
  "g_im",
  sizeof(GIm__ImCmdResponse),
  11,
  g_im__im_cmd_response__field_descriptors,
  g_im__im_cmd_response__field_indices_by_name,
  1,  g_im__im_cmd_response__number_ranges,
  (ProtobufCMessageInit) g_im__im_cmd_response__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_chnnel_warn__field_descriptors[4] =
{
  {
    "warn_type",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImChnnelWarn, has_warn_type),
    offsetof(GIm__ImChnnelWarn, warn_type),
    &g_im__im_warn_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "warn_src_id",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SINT32,
    offsetof(GIm__ImChnnelWarn, has_warn_src_id),
    offsetof(GIm__ImChnnelWarn, warn_src_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "warn_code",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SINT64,
    offsetof(GIm__ImChnnelWarn, has_warn_code),
    offsetof(GIm__ImChnnelWarn, warn_code),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "warn_time",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SINT64,
    offsetof(GIm__ImChnnelWarn, has_warn_time),
    offsetof(GIm__ImChnnelWarn, warn_time),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_chnnel_warn__field_indices_by_name[] = {
  2,   /* field[2] = warn_code */
  1,   /* field[1] = warn_src_id */
  3,   /* field[3] = warn_time */
  0,   /* field[0] = warn_type */
};
static const ProtobufCIntRange g_im__im_chnnel_warn__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor g_im__im_chnnel_warn__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_chnnel_warn",
  "ImChnnelWarn",
  "GIm__ImChnnelWarn",
  "g_im",
  sizeof(GIm__ImChnnelWarn),
  4,
  g_im__im_chnnel_warn__field_descriptors,
  g_im__im_chnnel_warn__field_indices_by_name,
  1,  g_im__im_chnnel_warn__number_ranges,
  (ProtobufCMessageInit) g_im__im_chnnel_warn__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_extern_data__field_descriptors[6] =
{
  {
    "alias_name",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImExternData, alias_name),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "unit",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImExternData, unit),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "key_name",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImExternData, key_name),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "dev_type",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImExternData, has_dev_type),
    offsetof(GIm__ImExternData, dev_type),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "dev_index",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImExternData, has_dev_index),
    offsetof(GIm__ImExternData, dev_index),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "value",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImExternData, has_value),
    offsetof(GIm__ImExternData, value),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_extern_data__field_indices_by_name[] = {
  0,   /* field[0] = alias_name */
  4,   /* field[4] = dev_index */
  3,   /* field[3] = dev_type */
  2,   /* field[2] = key_name */
  1,   /* field[1] = unit */
  5,   /* field[5] = value */
};
static const ProtobufCIntRange g_im__im_extern_data__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 6 }
};
const ProtobufCMessageDescriptor g_im__im_extern_data__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_extern_data",
  "ImExternData",
  "GIm__ImExternData",
  "g_im",
  sizeof(GIm__ImExternData),
  6,
  g_im__im_extern_data__field_descriptors,
  g_im__im_extern_data__field_indices_by_name,
  1,  g_im__im_extern_data__number_ranges,
  (ProtobufCMessageInit) g_im__im_extern_data__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_channel_param__field_descriptors[27] =
{
  {
    "channel_id",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SINT32,
    offsetof(GIm__ImChannelParam, has_channel_id),
    offsetof(GIm__ImChannelParam, channel_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "work_state",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImChannelParam, has_work_state),
    offsetof(GIm__ImChannelParam, work_state),
    &g_im__channel_st__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "power_state",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImChannelParam, has_power_state),
    offsetof(GIm__ImChannelParam, power_state),
    &g_im__power_channel_st__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "assist_state",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImChannelParam, has_assist_state),
    offsetof(GIm__ImChannelParam, assist_state),
    &g_im__ch_assist_st__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "im_chnl_warn",
    9,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__ImChannelParam, n_im_chnl_warn),
    offsetof(GIm__ImChannelParam, im_chnl_warn),
    &g_im__im_chnnel_warn__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "loop_num",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImChannelParam, loop_num),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "step_num",
    11,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SINT32,
    offsetof(GIm__ImChannelParam, has_step_num),
    offsetof(GIm__ImChannelParam, step_num),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "step_name",
    12,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImChannelParam, step_name),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "absolute_time",
    13,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED64,
    offsetof(GIm__ImChannelParam, has_absolute_time),
    offsetof(GIm__ImChannelParam, absolute_time),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "relative_time",
    14,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED64,
    offsetof(GIm__ImChannelParam, has_relative_time),
    offsetof(GIm__ImChannelParam, relative_time),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "cell",
    15,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__ImChannelParam, n_cell),
    offsetof(GIm__ImChannelParam, cell),
    &g_im__im_cell_param__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "set_voltage",
    16,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImChannelParam, has_set_voltage),
    offsetof(GIm__ImChannelParam, set_voltage),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "set_current",
    17,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImChannelParam, has_set_current),
    offsetof(GIm__ImChannelParam, set_current),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "set_power",
    18,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImChannelParam, has_set_power),
    offsetof(GIm__ImChannelParam, set_power),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "actual_current",
    19,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImChannelParam, has_actual_current),
    offsetof(GIm__ImChannelParam, actual_current),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "capacity",
    20,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_DOUBLE,
    offsetof(GIm__ImChannelParam, has_capacity),
    offsetof(GIm__ImChannelParam, capacity),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "voltage_total",
    21,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImChannelParam, has_voltage_total),
    offsetof(GIm__ImChannelParam, voltage_total),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ear_voltage",
    22,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImChannelParam, has_ear_voltage),
    offsetof(GIm__ImChannelParam, ear_voltage),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "port_voltage",
    23,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImChannelParam, has_port_voltage),
    offsetof(GIm__ImChannelParam, port_voltage),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "aux_tmp_max",
    24,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImChannelParam, has_aux_tmp_max),
    offsetof(GIm__ImChannelParam, aux_tmp_max),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "aux_tmp_min",
    25,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImChannelParam, has_aux_tmp_min),
    offsetof(GIm__ImChannelParam, aux_tmp_min),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "aux_voltage_diff",
    26,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImChannelParam, has_aux_voltage_diff),
    offsetof(GIm__ImChannelParam, aux_voltage_diff),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "aux_tmp_diff",
    27,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImChannelParam, has_aux_tmp_diff),
    offsetof(GIm__ImChannelParam, aux_tmp_diff),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "aux_voltage_total",
    28,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImChannelParam, has_aux_voltage_total),
    offsetof(GIm__ImChannelParam, aux_voltage_total),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "negative_pressure",
    29,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImChannelParam, has_negative_pressure),
    offsetof(GIm__ImChannelParam, negative_pressure),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "extern_data",
    30,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__ImChannelParam, n_extern_data),
    offsetof(GIm__ImChannelParam, extern_data),
    &g_im__im_extern_data__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "external_pressure",
    31,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImChannelParam, has_external_pressure),
    offsetof(GIm__ImChannelParam, external_pressure),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_channel_param__field_indices_by_name[] = {
  8,   /* field[8] = absolute_time */
  14,   /* field[14] = actual_current */
  3,   /* field[3] = assist_state */
  22,   /* field[22] = aux_tmp_diff */
  19,   /* field[19] = aux_tmp_max */
  20,   /* field[20] = aux_tmp_min */
  21,   /* field[21] = aux_voltage_diff */
  23,   /* field[23] = aux_voltage_total */
  15,   /* field[15] = capacity */
  10,   /* field[10] = cell */
  0,   /* field[0] = channel_id */
  17,   /* field[17] = ear_voltage */
  25,   /* field[25] = extern_data */
  26,   /* field[26] = external_pressure */
  4,   /* field[4] = im_chnl_warn */
  5,   /* field[5] = loop_num */
  24,   /* field[24] = negative_pressure */
  18,   /* field[18] = port_voltage */
  2,   /* field[2] = power_state */
  9,   /* field[9] = relative_time */
  12,   /* field[12] = set_current */
  13,   /* field[13] = set_power */
  11,   /* field[11] = set_voltage */
  7,   /* field[7] = step_name */
  6,   /* field[6] = step_num */
  16,   /* field[16] = voltage_total */
  1,   /* field[1] = work_state */
};
static const ProtobufCIntRange g_im__im_channel_param__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 27 }
};
const ProtobufCMessageDescriptor g_im__im_channel_param__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_channel_param",
  "ImChannelParam",
  "GIm__ImChannelParam",
  "g_im",
  sizeof(GIm__ImChannelParam),
  27,
  g_im__im_channel_param__field_descriptors,
  g_im__im_channel_param__field_indices_by_name,
  1,  g_im__im_channel_param__number_ranges,
  (ProtobufCMessageInit) g_im__im_channel_param__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_cell_param__field_descriptors[8] =
{
  {
    "cell_id",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SINT32,
    offsetof(GIm__ImCellParam, has_cell_id),
    offsetof(GIm__ImCellParam, cell_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "actual_voltage",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImCellParam, has_actual_voltage),
    offsetof(GIm__ImCellParam, actual_voltage),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "actual_power",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImCellParam, has_actual_power),
    offsetof(GIm__ImCellParam, actual_power),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "temperature",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImCellParam, has_temperature),
    offsetof(GIm__ImCellParam, temperature),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "energy",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_DOUBLE,
    offsetof(GIm__ImCellParam, has_energy),
    offsetof(GIm__ImCellParam, energy),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ear_voltage",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImCellParam, has_ear_voltage),
    offsetof(GIm__ImCellParam, ear_voltage),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "port_voltage",
    11,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImCellParam, has_port_voltage),
    offsetof(GIm__ImCellParam, port_voltage),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "extern_data",
    12,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__ImCellParam, n_extern_data),
    offsetof(GIm__ImCellParam, extern_data),
    &g_im__im_extern_data__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_cell_param__field_indices_by_name[] = {
  2,   /* field[2] = actual_power */
  1,   /* field[1] = actual_voltage */
  0,   /* field[0] = cell_id */
  5,   /* field[5] = ear_voltage */
  4,   /* field[4] = energy */
  7,   /* field[7] = extern_data */
  6,   /* field[6] = port_voltage */
  3,   /* field[3] = temperature */
};
static const ProtobufCIntRange g_im__im_cell_param__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 8 }
};
const ProtobufCMessageDescriptor g_im__im_cell_param__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_cell_param",
  "ImCellParam",
  "GIm__ImCellParam",
  "g_im",
  sizeof(GIm__ImCellParam),
  8,
  g_im__im_cell_param__field_descriptors,
  g_im__im_cell_param__field_indices_by_name,
  1,  g_im__im_cell_param__number_ranges,
  (ProtobufCMessageInit) g_im__im_cell_param__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_ui_data__field_descriptors[2] =
{
  {
    "head",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImUiData, head),
    &g_im__im_cmd_head__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "channel",
    6,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(GIm__ImUiData, n_channel),
    offsetof(GIm__ImUiData, channel),
    &g_im__im_channel_param__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_ui_data__field_indices_by_name[] = {
  1,   /* field[1] = channel */
  0,   /* field[0] = head */
};
static const ProtobufCIntRange g_im__im_ui_data__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor g_im__im_ui_data__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_ui_data",
  "ImUiData",
  "GIm__ImUiData",
  "g_im",
  sizeof(GIm__ImUiData),
  2,
  g_im__im_ui_data__field_descriptors,
  g_im__im_ui_data__field_indices_by_name,
  1,  g_im__im_ui_data__number_ranges,
  (ProtobufCMessageInit) g_im__im_ui_data__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_ui_data_response__field_descriptors[1] =
{
  {
    "result",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImUiDataResponse, has_result),
    offsetof(GIm__ImUiDataResponse, result),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_ui_data_response__field_indices_by_name[] = {
  0,   /* field[0] = result */
};
static const ProtobufCIntRange g_im__im_ui_data_response__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor g_im__im_ui_data_response__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_ui_data_response",
  "ImUiDataResponse",
  "GIm__ImUiDataResponse",
  "g_im",
  sizeof(GIm__ImUiDataResponse),
  1,
  g_im__im_ui_data_response__field_descriptors,
  g_im__im_ui_data_response__field_indices_by_name,
  1,  g_im__im_ui_data_response__number_ranges,
  (ProtobufCMessageInit) g_im__im_ui_data_response__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_ajust_request__field_descriptors[6] =
{
  {
    "channel_id",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImAjustRequest, has_channel_id),
    offsetof(GIm__ImAjustRequest, channel_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ajust_type",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImAjustRequest, has_ajust_type),
    offsetof(GIm__ImAjustRequest, ajust_type),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "load_voltage",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImAjustRequest, has_load_voltage),
    offsetof(GIm__ImAjustRequest, load_voltage),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "load_current",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImAjustRequest, has_load_current),
    offsetof(GIm__ImAjustRequest, load_current),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "relay_time",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImAjustRequest, has_relay_time),
    offsetof(GIm__ImAjustRequest, relay_time),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "power_mode",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImAjustRequest, has_power_mode),
    offsetof(GIm__ImAjustRequest, power_mode),
    &g_im__adjust_power_mode__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_ajust_request__field_indices_by_name[] = {
  1,   /* field[1] = ajust_type */
  0,   /* field[0] = channel_id */
  3,   /* field[3] = load_current */
  2,   /* field[2] = load_voltage */
  5,   /* field[5] = power_mode */
  4,   /* field[4] = relay_time */
};
static const ProtobufCIntRange g_im__im_ajust_request__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 6 }
};
const ProtobufCMessageDescriptor g_im__im_ajust_request__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_ajust_request",
  "ImAjustRequest",
  "GIm__ImAjustRequest",
  "g_im",
  sizeof(GIm__ImAjustRequest),
  6,
  g_im__im_ajust_request__field_descriptors,
  g_im__im_ajust_request__field_indices_by_name,
  1,  g_im__im_ajust_request__number_ranges,
  (ProtobufCMessageInit) g_im__im_ajust_request__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_ajust_response__field_descriptors[4] =
{
  {
    "channel_id",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImAjustResponse, has_channel_id),
    offsetof(GIm__ImAjustResponse, channel_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ajust_type",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImAjustResponse, has_ajust_type),
    offsetof(GIm__ImAjustResponse, ajust_type),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "result",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImAjustResponse, has_result),
    offsetof(GIm__ImAjustResponse, result),
    &g_im__cmd_result__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "power_mode",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImAjustResponse, has_power_mode),
    offsetof(GIm__ImAjustResponse, power_mode),
    &g_im__adjust_power_mode__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_ajust_response__field_indices_by_name[] = {
  1,   /* field[1] = ajust_type */
  0,   /* field[0] = channel_id */
  3,   /* field[3] = power_mode */
  2,   /* field[2] = result */
};
static const ProtobufCIntRange g_im__im_ajust_response__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor g_im__im_ajust_response__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_ajust_response",
  "ImAjustResponse",
  "GIm__ImAjustResponse",
  "g_im",
  sizeof(GIm__ImAjustResponse),
  4,
  g_im__im_ajust_response__field_descriptors,
  g_im__im_ajust_response__field_indices_by_name,
  1,  g_im__im_ajust_response__number_ranges,
  (ProtobufCMessageInit) g_im__im_ajust_response__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_debug_request__field_descriptors[3] =
{
  {
    "channel_id",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImDebugRequest, has_channel_id),
    offsetof(GIm__ImDebugRequest, channel_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "read_type",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImDebugRequest, has_read_type),
    offsetof(GIm__ImDebugRequest, read_type),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "power_mode",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImDebugRequest, has_power_mode),
    offsetof(GIm__ImDebugRequest, power_mode),
    &g_im__adjust_power_mode__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_debug_request__field_indices_by_name[] = {
  0,   /* field[0] = channel_id */
  2,   /* field[2] = power_mode */
  1,   /* field[1] = read_type */
};
static const ProtobufCIntRange g_im__im_debug_request__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor g_im__im_debug_request__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_debug_request",
  "ImDebugRequest",
  "GIm__ImDebugRequest",
  "g_im",
  sizeof(GIm__ImDebugRequest),
  3,
  g_im__im_debug_request__field_descriptors,
  g_im__im_debug_request__field_indices_by_name,
  1,  g_im__im_debug_request__number_ranges,
  (ProtobufCMessageInit) g_im__im_debug_request__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_debug_response__field_descriptors[16] =
{
  {
    "channel_id",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImDebugResponse, has_channel_id),
    offsetof(GIm__ImDebugResponse, channel_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "read_type",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImDebugResponse, has_read_type),
    offsetof(GIm__ImDebugResponse, read_type),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "result",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImDebugResponse, has_result),
    offsetof(GIm__ImDebugResponse, result),
    &g_im__cmd_result__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "vnum",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImDebugResponse, has_vnum),
    offsetof(GIm__ImDebugResponse, vnum),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "inum",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImDebugResponse, has_inum),
    offsetof(GIm__ImDebugResponse, inum),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "tnum",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImDebugResponse, has_tnum),
    offsetof(GIm__ImDebugResponse, tnum),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "voltages",
    11,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImDebugResponse, n_voltages),
    offsetof(GIm__ImDebugResponse, voltages),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "currents",
    12,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImDebugResponse, n_currents),
    offsetof(GIm__ImDebugResponse, currents),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "temperatures",
    13,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImDebugResponse, n_temperatures),
    offsetof(GIm__ImDebugResponse, temperatures),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "dc_dc_input_voltage",
    14,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImDebugResponse, has_dc_dc_input_voltage),
    offsetof(GIm__ImDebugResponse, dc_dc_input_voltage),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "dc_dc_output_voltage",
    15,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImDebugResponse, has_dc_dc_output_voltage),
    offsetof(GIm__ImDebugResponse, dc_dc_output_voltage),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "dc_dc_temperature",
    16,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImDebugResponse, has_dc_dc_temperature),
    offsetof(GIm__ImDebugResponse, dc_dc_temperature),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "power_mode",
    17,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImDebugResponse, has_power_mode),
    offsetof(GIm__ImDebugResponse, power_mode),
    &g_im__adjust_power_mode__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "low_warm_type",
    18,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImDebugResponse, has_low_warm_type),
    offsetof(GIm__ImDebugResponse, low_warm_type),
    &g_im__lower_machine_warn_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "channel_fault_type",
    19,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImDebugResponse, has_channel_fault_type),
    offsetof(GIm__ImDebugResponse, channel_fault_type),
    &g_im__lower_machine_channel_fault_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "arm_fault_type",
    20,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImDebugResponse, has_arm_fault_type),
    offsetof(GIm__ImDebugResponse, arm_fault_type),
    &g_im__lower_machine_arm_fault_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_debug_response__field_indices_by_name[] = {
  15,   /* field[15] = arm_fault_type */
  14,   /* field[14] = channel_fault_type */
  0,   /* field[0] = channel_id */
  7,   /* field[7] = currents */
  9,   /* field[9] = dc_dc_input_voltage */
  10,   /* field[10] = dc_dc_output_voltage */
  11,   /* field[11] = dc_dc_temperature */
  4,   /* field[4] = inum */
  13,   /* field[13] = low_warm_type */
  12,   /* field[12] = power_mode */
  1,   /* field[1] = read_type */
  2,   /* field[2] = result */
  8,   /* field[8] = temperatures */
  5,   /* field[5] = tnum */
  3,   /* field[3] = vnum */
  6,   /* field[6] = voltages */
};
static const ProtobufCIntRange g_im__im_debug_response__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 16 }
};
const ProtobufCMessageDescriptor g_im__im_debug_response__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_debug_response",
  "ImDebugResponse",
  "GIm__ImDebugResponse",
  "g_im",
  sizeof(GIm__ImDebugResponse),
  16,
  g_im__im_debug_response__field_descriptors,
  g_im__im_debug_response__field_indices_by_name,
  1,  g_im__im_debug_response__number_ranges,
  (ProtobufCMessageInit) g_im__im_debug_response__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_eeprom_request__field_descriptors[7] =
{
  {
    "channel_id",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImEepromRequest, has_channel_id),
    offsetof(GIm__ImEepromRequest, channel_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "eeprom_type",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImEepromRequest, has_eeprom_type),
    offsetof(GIm__ImEepromRequest, eeprom_type),
    &g_im__im_eeprom_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "fator_type",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImEepromRequest, has_fator_type),
    offsetof(GIm__ImEepromRequest, fator_type),
    &g_im__im_fator_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "fator_option",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImEepromRequest, has_fator_option),
    offsetof(GIm__ImEepromRequest, fator_option),
    &g_im__im_fator_option__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "k_fators",
    9,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImEepromRequest, n_k_fators),
    offsetof(GIm__ImEepromRequest, k_fators),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "b_fators",
    10,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImEepromRequest, n_b_fators),
    offsetof(GIm__ImEepromRequest, b_fators),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "power_mode",
    11,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImEepromRequest, has_power_mode),
    offsetof(GIm__ImEepromRequest, power_mode),
    &g_im__adjust_power_mode__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_eeprom_request__field_indices_by_name[] = {
  5,   /* field[5] = b_fators */
  0,   /* field[0] = channel_id */
  1,   /* field[1] = eeprom_type */
  3,   /* field[3] = fator_option */
  2,   /* field[2] = fator_type */
  4,   /* field[4] = k_fators */
  6,   /* field[6] = power_mode */
};
static const ProtobufCIntRange g_im__im_eeprom_request__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 7 }
};
const ProtobufCMessageDescriptor g_im__im_eeprom_request__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_eeprom_request",
  "ImEepromRequest",
  "GIm__ImEepromRequest",
  "g_im",
  sizeof(GIm__ImEepromRequest),
  7,
  g_im__im_eeprom_request__field_descriptors,
  g_im__im_eeprom_request__field_indices_by_name,
  1,  g_im__im_eeprom_request__number_ranges,
  (ProtobufCMessageInit) g_im__im_eeprom_request__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_eeprom_read_response__field_descriptors[11] =
{
  {
    "channel_id",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImEepromReadResponse, has_channel_id),
    offsetof(GIm__ImEepromReadResponse, channel_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "eeprom_type",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImEepromReadResponse, has_eeprom_type),
    offsetof(GIm__ImEepromReadResponse, eeprom_type),
    &g_im__im_eeprom_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "result",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImEepromReadResponse, has_result),
    offsetof(GIm__ImEepromReadResponse, result),
    &g_im__cmd_result__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "fator_type",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImEepromReadResponse, has_fator_type),
    offsetof(GIm__ImEepromReadResponse, fator_type),
    &g_im__im_fator_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "fator_option",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImEepromReadResponse, has_fator_option),
    offsetof(GIm__ImEepromReadResponse, fator_option),
    &g_im__im_fator_option__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "k_fators",
    10,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImEepromReadResponse, n_k_fators),
    offsetof(GIm__ImEepromReadResponse, k_fators),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "b_fators",
    11,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImEepromReadResponse, n_b_fators),
    offsetof(GIm__ImEepromReadResponse, b_fators),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "v_max",
    12,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImEepromReadResponse, has_v_max),
    offsetof(GIm__ImEepromReadResponse, v_max),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "i_max",
    13,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImEepromReadResponse, has_i_max),
    offsetof(GIm__ImEepromReadResponse, i_max),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "p_max",
    14,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImEepromReadResponse, has_p_max),
    offsetof(GIm__ImEepromReadResponse, p_max),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "power_mode",
    15,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImEepromReadResponse, has_power_mode),
    offsetof(GIm__ImEepromReadResponse, power_mode),
    &g_im__adjust_power_mode__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_eeprom_read_response__field_indices_by_name[] = {
  6,   /* field[6] = b_fators */
  0,   /* field[0] = channel_id */
  1,   /* field[1] = eeprom_type */
  4,   /* field[4] = fator_option */
  3,   /* field[3] = fator_type */
  8,   /* field[8] = i_max */
  5,   /* field[5] = k_fators */
  9,   /* field[9] = p_max */
  10,   /* field[10] = power_mode */
  2,   /* field[2] = result */
  7,   /* field[7] = v_max */
};
static const ProtobufCIntRange g_im__im_eeprom_read_response__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 11 }
};
const ProtobufCMessageDescriptor g_im__im_eeprom_read_response__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_eeprom_read_response",
  "ImEepromReadResponse",
  "GIm__ImEepromReadResponse",
  "g_im",
  sizeof(GIm__ImEepromReadResponse),
  11,
  g_im__im_eeprom_read_response__field_descriptors,
  g_im__im_eeprom_read_response__field_indices_by_name,
  1,  g_im__im_eeprom_read_response__number_ranges,
  (ProtobufCMessageInit) g_im__im_eeprom_read_response__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_eeprom_write_response__field_descriptors[4] =
{
  {
    "channel_id",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImEepromWriteResponse, has_channel_id),
    offsetof(GIm__ImEepromWriteResponse, channel_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "eeprom_type",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImEepromWriteResponse, has_eeprom_type),
    offsetof(GIm__ImEepromWriteResponse, eeprom_type),
    &g_im__im_eeprom_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "power_mode",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImEepromWriteResponse, has_power_mode),
    offsetof(GIm__ImEepromWriteResponse, power_mode),
    &g_im__adjust_power_mode__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "result",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImEepromWriteResponse, has_result),
    offsetof(GIm__ImEepromWriteResponse, result),
    &g_im__cmd_result__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_eeprom_write_response__field_indices_by_name[] = {
  0,   /* field[0] = channel_id */
  1,   /* field[1] = eeprom_type */
  2,   /* field[2] = power_mode */
  3,   /* field[3] = result */
};
static const ProtobufCIntRange g_im__im_eeprom_write_response__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor g_im__im_eeprom_write_response__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_eeprom_write_response",
  "ImEepromWriteResponse",
  "GIm__ImEepromWriteResponse",
  "g_im",
  sizeof(GIm__ImEepromWriteResponse),
  4,
  g_im__im_eeprom_write_response__field_descriptors,
  g_im__im_eeprom_write_response__field_indices_by_name,
  1,  g_im__im_eeprom_write_response__number_ranges,
  (ProtobufCMessageInit) g_im__im_eeprom_write_response__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__negative_pressure_param__field_descriptors[6] =
{
  {
    "k_negative_pressure",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__NegativePressureParam, has_k_negative_pressure),
    offsetof(GIm__NegativePressureParam, k_negative_pressure),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "k_negative_pressure_limit",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__NegativePressureParam, has_k_negative_pressure_limit),
    offsetof(GIm__NegativePressureParam, k_negative_pressure_limit),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "k_negative_pressure_rate",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__NegativePressureParam, has_k_negative_pressure_rate),
    offsetof(GIm__NegativePressureParam, k_negative_pressure_rate),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "k_wait_seconds",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__NegativePressureParam, has_k_wait_seconds),
    offsetof(GIm__NegativePressureParam, k_wait_seconds),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "k_negative_pressure_timeout_seconds",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__NegativePressureParam, has_k_negative_pressure_timeout_seconds),
    offsetof(GIm__NegativePressureParam, k_negative_pressure_timeout_seconds),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "k_leakage_jugge_seconds",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__NegativePressureParam, has_k_leakage_jugge_seconds),
    offsetof(GIm__NegativePressureParam, k_leakage_jugge_seconds),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__negative_pressure_param__field_indices_by_name[] = {
  5,   /* field[5] = k_leakage_jugge_seconds */
  0,   /* field[0] = k_negative_pressure */
  1,   /* field[1] = k_negative_pressure_limit */
  2,   /* field[2] = k_negative_pressure_rate */
  4,   /* field[4] = k_negative_pressure_timeout_seconds */
  3,   /* field[3] = k_wait_seconds */
};
static const ProtobufCIntRange g_im__negative_pressure_param__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 6 }
};
const ProtobufCMessageDescriptor g_im__negative_pressure_param__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.negative_pressure_param",
  "NegativePressureParam",
  "GIm__NegativePressureParam",
  "g_im",
  sizeof(GIm__NegativePressureParam),
  6,
  g_im__negative_pressure_param__field_descriptors,
  g_im__negative_pressure_param__field_indices_by_name,
  1,  g_im__negative_pressure_param__number_ranges,
  (ProtobufCMessageInit) g_im__negative_pressure_param__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_negative_pressure_request__field_descriptors[4] =
{
  {
    "stock_no",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImNegativePressureRequest, has_stock_no),
    offsetof(GIm__ImNegativePressureRequest, stock_no),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "cmd_type",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImNegativePressureRequest, has_cmd_type),
    offsetof(GIm__ImNegativePressureRequest, cmd_type),
    &g_im__negative_pressure_cmd_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "cmd_param",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(GIm__ImNegativePressureRequest, cmd_param),
    &g_im__negative_pressure_param__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "valve_type",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImNegativePressureRequest, has_valve_type),
    offsetof(GIm__ImNegativePressureRequest, valve_type),
    &g_im__negative_pressure_vacuum_valve_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_negative_pressure_request__field_indices_by_name[] = {
  2,   /* field[2] = cmd_param */
  1,   /* field[1] = cmd_type */
  0,   /* field[0] = stock_no */
  3,   /* field[3] = valve_type */
};
static const ProtobufCIntRange g_im__im_negative_pressure_request__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor g_im__im_negative_pressure_request__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_negative_pressure_request",
  "ImNegativePressureRequest",
  "GIm__ImNegativePressureRequest",
  "g_im",
  sizeof(GIm__ImNegativePressureRequest),
  4,
  g_im__im_negative_pressure_request__field_descriptors,
  g_im__im_negative_pressure_request__field_indices_by_name,
  1,  g_im__im_negative_pressure_request__number_ranges,
  (ProtobufCMessageInit) g_im__im_negative_pressure_request__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_negative_pressure_response__field_descriptors[10] =
{
  {
    "stock_no",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImNegativePressureResponse, has_stock_no),
    offsetof(GIm__ImNegativePressureResponse, stock_no),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "cmd_type",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImNegativePressureResponse, has_cmd_type),
    offsetof(GIm__ImNegativePressureResponse, cmd_type),
    &g_im__negative_pressure_cmd_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "k_negative_pressure",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImNegativePressureResponse, has_k_negative_pressure),
    offsetof(GIm__ImNegativePressureResponse, k_negative_pressure),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "result",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImNegativePressureResponse, has_result),
    offsetof(GIm__ImNegativePressureResponse, result),
    &g_im__cmd_result__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "op_res",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImNegativePressureResponse, has_op_res),
    offsetof(GIm__ImNegativePressureResponse, op_res),
    &g_im__negative_pressure_op_res__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "leakage_rate",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImNegativePressureResponse, has_leakage_rate),
    offsetof(GIm__ImNegativePressureResponse, leakage_rate),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "vacuum_neg_pressure",
    11,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImNegativePressureResponse, has_vacuum_neg_pressure),
    offsetof(GIm__ImNegativePressureResponse, vacuum_neg_pressure),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "steady_neg_pressure",
    12,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImNegativePressureResponse, has_steady_neg_pressure),
    offsetof(GIm__ImNegativePressureResponse, steady_neg_pressure),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "first_neg_pressure",
    13,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImNegativePressureResponse, has_first_neg_pressure),
    offsetof(GIm__ImNegativePressureResponse, first_neg_pressure),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "second_neg_pressure",
    14,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(GIm__ImNegativePressureResponse, has_second_neg_pressure),
    offsetof(GIm__ImNegativePressureResponse, second_neg_pressure),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_negative_pressure_response__field_indices_by_name[] = {
  1,   /* field[1] = cmd_type */
  8,   /* field[8] = first_neg_pressure */
  2,   /* field[2] = k_negative_pressure */
  5,   /* field[5] = leakage_rate */
  4,   /* field[4] = op_res */
  3,   /* field[3] = result */
  9,   /* field[9] = second_neg_pressure */
  7,   /* field[7] = steady_neg_pressure */
  0,   /* field[0] = stock_no */
  6,   /* field[6] = vacuum_neg_pressure */
};
static const ProtobufCIntRange g_im__im_negative_pressure_response__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 10 }
};
const ProtobufCMessageDescriptor g_im__im_negative_pressure_response__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_negative_pressure_response",
  "ImNegativePressureResponse",
  "GIm__ImNegativePressureResponse",
  "g_im",
  sizeof(GIm__ImNegativePressureResponse),
  10,
  g_im__im_negative_pressure_response__field_descriptors,
  g_im__im_negative_pressure_response__field_indices_by_name,
  1,  g_im__im_negative_pressure_response__number_ranges,
  (ProtobufCMessageInit) g_im__im_negative_pressure_response__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_version_query_request__field_descriptors[4] =
{
  {
    "power_mode",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImVersionQueryRequest, has_power_mode),
    offsetof(GIm__ImVersionQueryRequest, power_mode),
    &g_im__adjust_power_mode__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "channel_id",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImVersionQueryRequest, has_channel_id),
    offsetof(GIm__ImVersionQueryRequest, channel_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "chip_type",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImVersionQueryRequest, has_chip_type),
    offsetof(GIm__ImVersionQueryRequest, chip_type),
    &g_im__version_query_chip_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "query_type",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImVersionQueryRequest, has_query_type),
    offsetof(GIm__ImVersionQueryRequest, query_type),
    &g_im__version_query_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_version_query_request__field_indices_by_name[] = {
  1,   /* field[1] = channel_id */
  2,   /* field[2] = chip_type */
  0,   /* field[0] = power_mode */
  3,   /* field[3] = query_type */
};
static const ProtobufCIntRange g_im__im_version_query_request__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor g_im__im_version_query_request__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_version_query_request",
  "ImVersionQueryRequest",
  "GIm__ImVersionQueryRequest",
  "g_im",
  sizeof(GIm__ImVersionQueryRequest),
  4,
  g_im__im_version_query_request__field_descriptors,
  g_im__im_version_query_request__field_indices_by_name,
  1,  g_im__im_version_query_request__number_ranges,
  (ProtobufCMessageInit) g_im__im_version_query_request__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor g_im__im_version_query_response__field_descriptors[7] =
{
  {
    "power_mode",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImVersionQueryResponse, has_power_mode),
    offsetof(GIm__ImVersionQueryResponse, power_mode),
    &g_im__adjust_power_mode__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "channel_id",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SFIXED32,
    offsetof(GIm__ImVersionQueryResponse, has_channel_id),
    offsetof(GIm__ImVersionQueryResponse, channel_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "chip_type",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImVersionQueryResponse, has_chip_type),
    offsetof(GIm__ImVersionQueryResponse, chip_type),
    &g_im__version_query_chip_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "query_type",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImVersionQueryResponse, has_query_type),
    offsetof(GIm__ImVersionQueryResponse, query_type),
    &g_im__version_query_type__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "result",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(GIm__ImVersionQueryResponse, has_result),
    offsetof(GIm__ImVersionQueryResponse, result),
    &g_im__cmd_result__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "app_version",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImVersionQueryResponse, app_version),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "app_name",
    11,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(GIm__ImVersionQueryResponse, app_name),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned g_im__im_version_query_response__field_indices_by_name[] = {
  6,   /* field[6] = app_name */
  5,   /* field[5] = app_version */
  1,   /* field[1] = channel_id */
  2,   /* field[2] = chip_type */
  0,   /* field[0] = power_mode */
  3,   /* field[3] = query_type */
  4,   /* field[4] = result */
};
static const ProtobufCIntRange g_im__im_version_query_response__number_ranges[1 + 1] =
{
  { 5, 0 },
  { 0, 7 }
};
const ProtobufCMessageDescriptor g_im__im_version_query_response__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "g_im.im_version_query_response",
  "ImVersionQueryResponse",
  "GIm__ImVersionQueryResponse",
  "g_im",
  sizeof(GIm__ImVersionQueryResponse),
  7,
  g_im__im_version_query_response__field_descriptors,
  g_im__im_version_query_response__field_indices_by_name,
  1,  g_im__im_version_query_response__number_ranges,
  (ProtobufCMessageInit) g_im__im_version_query_response__init,
  NULL,NULL,NULL    /* reserved[123] */
};

size_t
g_im__im_cmd_head_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_cmd_head__get_packed_size((GIm__ImCmdHead *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_cmd_head__pack((GIm__ImCmdHead *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_cmd_head_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImCmdHead *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_cmd_head__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_cmd_head_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_cmd_head__free_unpacked((GIm__ImCmdHead *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_auth_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_auth__get_packed_size((GIm__ImAuth *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_auth__pack((GIm__ImAuth *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_auth_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImAuth *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_auth__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_auth_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_auth__free_unpacked((GIm__ImAuth *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_data_store4unit_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_data_store4unit__get_packed_size((GIm__ImDataStore4unit *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_data_store4unit__pack((GIm__ImDataStore4unit *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_data_store4unit_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImDataStore4unit *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_data_store4unit__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_data_store4unit_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_data_store4unit__free_unpacked((GIm__ImDataStore4unit *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_data_store4alarm_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_data_store4alarm__get_packed_size((GIm__ImDataStore4alarm *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_data_store4alarm__pack((GIm__ImDataStore4alarm *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_data_store4alarm_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImDataStore4alarm *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_data_store4alarm__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_data_store4alarm_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_data_store4alarm__free_unpacked((GIm__ImDataStore4alarm *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__smoke_item_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__smoke_item__get_packed_size((GIm__SmokeItem *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__smoke_item__pack((GIm__SmokeItem *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__smoke_item_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__SmokeItem *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__smoke_item__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__smoke_item_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__smoke_item__free_unpacked((GIm__SmokeItem *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__smoke_data_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__smoke_data__get_packed_size((GIm__SmokeData *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__smoke_data__pack((GIm__SmokeData *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__smoke_data_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__SmokeData *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__smoke_data__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__smoke_data_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__smoke_data__free_unpacked((GIm__SmokeData *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_co_item_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_co_item__get_packed_size((GIm__ImCoItem *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_co_item__pack((GIm__ImCoItem *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_co_item_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImCoItem *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_co_item__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_co_item_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_co_item__free_unpacked((GIm__ImCoItem *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_co_data_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_co_data__get_packed_size((GIm__ImCoData *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_co_data__pack((GIm__ImCoData *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_co_data_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImCoData *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_co_data__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_co_data_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_co_data__free_unpacked((GIm__ImCoData *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_fan__item_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_fan__item__get_packed_size((GIm__ImFanItem *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_fan__item__pack((GIm__ImFanItem *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_fan__item_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImFanItem *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_fan__item__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_fan__item_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_fan__item__free_unpacked((GIm__ImFanItem *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_fan_data_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_fan_data__get_packed_size((GIm__ImFanData *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_fan_data__pack((GIm__ImFanData *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_fan_data_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImFanData *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_fan_data__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_fan_data_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_fan_data__free_unpacked((GIm__ImFanData *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_temp_item_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_temp_item__get_packed_size((GIm__ImTempItem *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_temp_item__pack((GIm__ImTempItem *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_temp_item_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImTempItem *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_temp_item__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_temp_item_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_temp_item__free_unpacked((GIm__ImTempItem *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__env_temp_data_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__env_temp_data__get_packed_size((GIm__EnvTempData *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__env_temp_data__pack((GIm__EnvTempData *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__env_temp_data_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__EnvTempData *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__env_temp_data__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__env_temp_data_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__env_temp_data__free_unpacked((GIm__EnvTempData *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__negativepressure_data_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__negativepressure_data__get_packed_size((GIm__NegativepressureData *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__negativepressure_data__pack((GIm__NegativepressureData *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__negativepressure_data_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__NegativepressureData *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__negativepressure_data__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__negativepressure_data_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__negativepressure_data__free_unpacked((GIm__NegativepressureData *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__alarm_param_data_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__alarm_param_data__get_packed_size((GIm__AlarmParamData *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__alarm_param_data__pack((GIm__AlarmParamData *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__alarm_param_data_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__AlarmParamData *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__alarm_param_data__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__alarm_param_data_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__alarm_param_data__free_unpacked((GIm__AlarmParamData *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__alarm_set_param_data_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__alarm_set_param_data__get_packed_size((GIm__AlarmSetParamData *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__alarm_set_param_data__pack((GIm__AlarmSetParamData *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__alarm_set_param_data_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__AlarmSetParamData *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__alarm_set_param_data__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__alarm_set_param_data_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__alarm_set_param_data__free_unpacked((GIm__AlarmSetParamData *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__serucrity_alarm_data_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__serucrity_alarm_data__get_packed_size((GIm__SerucrityAlarmData *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__serucrity_alarm_data__pack((GIm__SerucrityAlarmData *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__serucrity_alarm_data_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__SerucrityAlarmData *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__serucrity_alarm_data__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__serucrity_alarm_data_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__serucrity_alarm_data__free_unpacked((GIm__SerucrityAlarmData *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__serucrity_combination_alarm_data_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__serucrity_combination_alarm_data__get_packed_size((GIm__SerucrityCombinationAlarmData *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__serucrity_combination_alarm_data__pack((GIm__SerucrityCombinationAlarmData *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__serucrity_combination_alarm_data_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__SerucrityCombinationAlarmData *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__serucrity_combination_alarm_data__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__serucrity_combination_alarm_data_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__serucrity_combination_alarm_data__free_unpacked((GIm__SerucrityCombinationAlarmData *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__lowercomputer_data_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__lowercomputer_data__get_packed_size((GIm__LowercomputerData *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__lowercomputer_data__pack((GIm__LowercomputerData *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__lowercomputer_data_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__LowercomputerData *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__lowercomputer_data__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__lowercomputer_data_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__lowercomputer_data__free_unpacked((GIm__LowercomputerData *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__plc_failure_data_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__plc_failure_data__get_packed_size((GIm__PlcFailureData *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__plc_failure_data__pack((GIm__PlcFailureData *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__plc_failure_data_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__PlcFailureData *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__plc_failure_data__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__plc_failure_data_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__plc_failure_data__free_unpacked((GIm__PlcFailureData *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_stock_security_info_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_stock_security_info__get_packed_size((GIm__ImStockSecurityInfo *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_stock_security_info__pack((GIm__ImStockSecurityInfo *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_stock_security_info_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImStockSecurityInfo *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_stock_security_info__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_stock_security_info_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_stock_security_info__free_unpacked((GIm__ImStockSecurityInfo *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_security_data_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_security_data__get_packed_size((GIm__ImSecurityData *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_security_data__pack((GIm__ImSecurityData *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_security_data_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImSecurityData *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_security_data__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_security_data_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_security_data__free_unpacked((GIm__ImSecurityData *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_device_update_info_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_device_update_info__get_packed_size((GIm__ImDeviceUpdateInfo *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_device_update_info__pack((GIm__ImDeviceUpdateInfo *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_device_update_info_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImDeviceUpdateInfo *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_device_update_info__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_device_update_info_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_device_update_info__free_unpacked((GIm__ImDeviceUpdateInfo *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_device_passthrough_response_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_device_passthrough_response__get_packed_size((GIm__ImDevicePassthroughResponse *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_device_passthrough_response__pack((GIm__ImDevicePassthroughResponse *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_device_passthrough_response_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImDevicePassthroughResponse *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_device_passthrough_response__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_device_passthrough_response_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_device_passthrough_response__free_unpacked((GIm__ImDevicePassthroughResponse *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_device_upgrade_data_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_device_upgrade_data__get_packed_size((GIm__ImDeviceUpgradeData *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_device_upgrade_data__pack((GIm__ImDeviceUpgradeData *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_device_upgrade_data_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImDeviceUpgradeData *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_device_upgrade_data__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_device_upgrade_data_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_device_upgrade_data__free_unpacked((GIm__ImDeviceUpgradeData *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_device_upgrad_notify_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_device_upgrad_notify__get_packed_size((GIm__ImDeviceUpgradNotify *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_device_upgrad_notify__pack((GIm__ImDeviceUpgradNotify *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_device_upgrad_notify_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImDeviceUpgradNotify *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_device_upgrad_notify__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_device_upgrad_notify_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_device_upgrad_notify__free_unpacked((GIm__ImDeviceUpgradNotify *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_netcard_param_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_netcard_param__get_packed_size((GIm__ImNetcardParam *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_netcard_param__pack((GIm__ImNetcardParam *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_netcard_param_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImNetcardParam *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_netcard_param__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_netcard_param_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_netcard_param__free_unpacked((GIm__ImNetcardParam *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_master_channel_ret_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_master_channel_ret__get_packed_size((GIm__ImMasterChannelRet *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_master_channel_ret__pack((GIm__ImMasterChannelRet *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_master_channel_ret_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImMasterChannelRet *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_master_channel_ret__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_master_channel_ret_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_master_channel_ret__free_unpacked((GIm__ImMasterChannelRet *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_step_jump_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_step_jump__get_packed_size((GIm__ImStepJump *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_step_jump__pack((GIm__ImStepJump *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_step_jump_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImStepJump *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_step_jump__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_step_jump_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_step_jump__free_unpacked((GIm__ImStepJump *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_channel_continue_ret_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_channel_continue_ret__get_packed_size((GIm__ImChannelContinueRet *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_channel_continue_ret__pack((GIm__ImChannelContinueRet *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_channel_continue_ret_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImChannelContinueRet *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_channel_continue_ret__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_channel_continue_ret_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_channel_continue_ret__free_unpacked((GIm__ImChannelContinueRet *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_channel_enable_byip_result_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_channel_enable_byip_result__get_packed_size((GIm__ImChannelEnableByipResult *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_channel_enable_byip_result__pack((GIm__ImChannelEnableByipResult *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_channel_enable_byip_result_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImChannelEnableByipResult *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_channel_enable_byip_result__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_channel_enable_byip_result_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_channel_enable_byip_result__free_unpacked((GIm__ImChannelEnableByipResult *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_channel_appoint_stop_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_channel_appoint_stop__get_packed_size((GIm__ImChannelAppointStop *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_channel_appoint_stop__pack((GIm__ImChannelAppointStop *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_channel_appoint_stop_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImChannelAppointStop *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_channel_appoint_stop__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_channel_appoint_stop_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_channel_appoint_stop__free_unpacked((GIm__ImChannelAppointStop *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_security_stop_by_stock_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_security_stop_by_stock__get_packed_size((GIm__ImSecurityStopByStock *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_security_stop_by_stock__pack((GIm__ImSecurityStopByStock *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_security_stop_by_stock_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImSecurityStopByStock *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_security_stop_by_stock__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_security_stop_by_stock_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_security_stop_by_stock__free_unpacked((GIm__ImSecurityStopByStock *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_channel_test_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_channel_test__get_packed_size((GIm__ImChannelTest *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_channel_test__pack((GIm__ImChannelTest *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_channel_test_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImChannelTest *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_channel_test__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_channel_test_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_channel_test__free_unpacked((GIm__ImChannelTest *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_channel_clear_warn_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_channel_clear_warn__get_packed_size((GIm__ImChannelClearWarn *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_channel_clear_warn__pack((GIm__ImChannelClearWarn *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_channel_clear_warn_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImChannelClearWarn *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_channel_clear_warn__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_channel_clear_warn_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_channel_clear_warn__free_unpacked((GIm__ImChannelClearWarn *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_security_clear_warn_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_security_clear_warn__get_packed_size((GIm__ImSecurityClearWarn *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_security_clear_warn__pack((GIm__ImSecurityClearWarn *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_security_clear_warn_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImSecurityClearWarn *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_security_clear_warn__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_security_clear_warn_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_security_clear_warn__free_unpacked((GIm__ImSecurityClearWarn *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_display_time_protection_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_display_time_protection__get_packed_size((GIm__ImDisplayTimeProtection *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_display_time_protection__pack((GIm__ImDisplayTimeProtection *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_display_time_protection_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImDisplayTimeProtection *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_display_time_protection__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_display_time_protection_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_display_time_protection__free_unpacked((GIm__ImDisplayTimeProtection *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_soft_update_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_soft_update__get_packed_size((GIm__ImSoftUpdate *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_soft_update__pack((GIm__ImSoftUpdate *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_soft_update_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImSoftUpdate *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_soft_update__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_soft_update_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_soft_update__free_unpacked((GIm__ImSoftUpdate *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_device_update_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_device_update__get_packed_size((GIm__ImDeviceUpdate *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_device_update__pack((GIm__ImDeviceUpdate *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_device_update_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImDeviceUpdate *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_device_update__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_device_update_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_device_update__free_unpacked((GIm__ImDeviceUpdate *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_device_passthrough_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_device_passthrough__get_packed_size((GIm__ImDevicePassthrough *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_device_passthrough__pack((GIm__ImDevicePassthrough *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_device_passthrough_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImDevicePassthrough *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_device_passthrough__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_device_passthrough_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_device_passthrough__free_unpacked((GIm__ImDevicePassthrough *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_cmd_request_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_cmd_request__get_packed_size((GIm__ImCmdRequest *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_cmd_request__pack((GIm__ImCmdRequest *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_cmd_request_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImCmdRequest *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_cmd_request__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_cmd_request_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_cmd_request__free_unpacked((GIm__ImCmdRequest *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__execute_serucrity_result_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__execute_serucrity_result__get_packed_size((GIm__ExecuteSerucrityResult *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__execute_serucrity_result__pack((GIm__ExecuteSerucrityResult *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__execute_serucrity_result_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ExecuteSerucrityResult *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__execute_serucrity_result__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__execute_serucrity_result_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__execute_serucrity_result__free_unpacked((GIm__ExecuteSerucrityResult *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_cmd_response_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_cmd_response__get_packed_size((GIm__ImCmdResponse *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_cmd_response__pack((GIm__ImCmdResponse *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_cmd_response_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImCmdResponse *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_cmd_response__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_cmd_response_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_cmd_response__free_unpacked((GIm__ImCmdResponse *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_chnnel_warn_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_chnnel_warn__get_packed_size((GIm__ImChnnelWarn *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_chnnel_warn__pack((GIm__ImChnnelWarn *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_chnnel_warn_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImChnnelWarn *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_chnnel_warn__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_chnnel_warn_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_chnnel_warn__free_unpacked((GIm__ImChnnelWarn *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_extern_data_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_extern_data__get_packed_size((GIm__ImExternData *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_extern_data__pack((GIm__ImExternData *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_extern_data_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImExternData *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_extern_data__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_extern_data_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_extern_data__free_unpacked((GIm__ImExternData *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_channel_param_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_channel_param__get_packed_size((GIm__ImChannelParam *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_channel_param__pack((GIm__ImChannelParam *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_channel_param_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImChannelParam *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_channel_param__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_channel_param_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_channel_param__free_unpacked((GIm__ImChannelParam *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_cell_param_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_cell_param__get_packed_size((GIm__ImCellParam *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_cell_param__pack((GIm__ImCellParam *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_cell_param_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImCellParam *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_cell_param__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_cell_param_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_cell_param__free_unpacked((GIm__ImCellParam *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_ui_data_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_ui_data__get_packed_size((GIm__ImUiData *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_ui_data__pack((GIm__ImUiData *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_ui_data_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImUiData *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_ui_data__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_ui_data_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_ui_data__free_unpacked((GIm__ImUiData *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_ui_data_response_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_ui_data_response__get_packed_size((GIm__ImUiDataResponse *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_ui_data_response__pack((GIm__ImUiDataResponse *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_ui_data_response_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImUiDataResponse *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_ui_data_response__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_ui_data_response_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_ui_data_response__free_unpacked((GIm__ImUiDataResponse *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_ajust_request_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_ajust_request__get_packed_size((GIm__ImAjustRequest *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_ajust_request__pack((GIm__ImAjustRequest *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_ajust_request_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImAjustRequest *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_ajust_request__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_ajust_request_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_ajust_request__free_unpacked((GIm__ImAjustRequest *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_ajust_response_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_ajust_response__get_packed_size((GIm__ImAjustResponse *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_ajust_response__pack((GIm__ImAjustResponse *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_ajust_response_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImAjustResponse *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_ajust_response__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_ajust_response_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_ajust_response__free_unpacked((GIm__ImAjustResponse *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_debug_request_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_debug_request__get_packed_size((GIm__ImDebugRequest *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_debug_request__pack((GIm__ImDebugRequest *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_debug_request_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImDebugRequest *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_debug_request__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_debug_request_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_debug_request__free_unpacked((GIm__ImDebugRequest *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_debug_response_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_debug_response__get_packed_size((GIm__ImDebugResponse *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_debug_response__pack((GIm__ImDebugResponse *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_debug_response_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImDebugResponse *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_debug_response__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_debug_response_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_debug_response__free_unpacked((GIm__ImDebugResponse *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_eeprom_request_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_eeprom_request__get_packed_size((GIm__ImEepromRequest *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_eeprom_request__pack((GIm__ImEepromRequest *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_eeprom_request_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImEepromRequest *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_eeprom_request__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_eeprom_request_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_eeprom_request__free_unpacked((GIm__ImEepromRequest *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_eeprom_read_response_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_eeprom_read_response__get_packed_size((GIm__ImEepromReadResponse *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_eeprom_read_response__pack((GIm__ImEepromReadResponse *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_eeprom_read_response_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImEepromReadResponse *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_eeprom_read_response__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_eeprom_read_response_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_eeprom_read_response__free_unpacked((GIm__ImEepromReadResponse *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_eeprom_write_response_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_eeprom_write_response__get_packed_size((GIm__ImEepromWriteResponse *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_eeprom_write_response__pack((GIm__ImEepromWriteResponse *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_eeprom_write_response_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImEepromWriteResponse *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_eeprom_write_response__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_eeprom_write_response_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_eeprom_write_response__free_unpacked((GIm__ImEepromWriteResponse *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__negative_pressure_param_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__negative_pressure_param__get_packed_size((GIm__NegativePressureParam *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__negative_pressure_param__pack((GIm__NegativePressureParam *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__negative_pressure_param_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__NegativePressureParam *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__negative_pressure_param__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__negative_pressure_param_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__negative_pressure_param__free_unpacked((GIm__NegativePressureParam *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_negative_pressure_request_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_negative_pressure_request__get_packed_size((GIm__ImNegativePressureRequest *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_negative_pressure_request__pack((GIm__ImNegativePressureRequest *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_negative_pressure_request_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImNegativePressureRequest *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_negative_pressure_request__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_negative_pressure_request_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_negative_pressure_request__free_unpacked((GIm__ImNegativePressureRequest *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_negative_pressure_response_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_negative_pressure_response__get_packed_size((GIm__ImNegativePressureResponse *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_negative_pressure_response__pack((GIm__ImNegativePressureResponse *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_negative_pressure_response_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImNegativePressureResponse *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_negative_pressure_response__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_negative_pressure_response_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_negative_pressure_response__free_unpacked((GIm__ImNegativePressureResponse *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_version_query_request_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_version_query_request__get_packed_size((GIm__ImVersionQueryRequest *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_version_query_request__pack((GIm__ImVersionQueryRequest *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_version_query_request_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImVersionQueryRequest *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_version_query_request__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_version_query_request_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_version_query_request__free_unpacked((GIm__ImVersionQueryRequest *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}

size_t
g_im__im_version_query_response_packer (void *input, grpc_byte_buffer **buffer)
{
    uint8_t *out;
    size_t size = g_im__im_version_query_response__get_packed_size((GIm__ImVersionQueryResponse *)input);
    out = gpr_malloc(sizeof(uint8_t) * size);
    size_t len = g_im__im_version_query_response__pack((GIm__ImVersionQueryResponse *)input, out);
    grpc_slice slice = grpc_slice_new(out, len, gpr_free);
    *buffer = grpc_raw_byte_buffer_create(&slice, 1);
    grpc_slice_unref(slice);
    return len;
}

void *
g_im__im_version_query_response_unpacker (grpc_c_context_t *context, grpc_byte_buffer *buffer)
{
    GIm__ImVersionQueryResponse *h = NULL;
    if (buffer != NULL) {
        struct ProtobufCAllocator allocator;
        grpc_byte_buffer_reader reader;
        grpc_slice slice;
        grpc_byte_buffer_reader_init(&reader, buffer);
        char *buf = NULL;
        size_t buf_len = 0;
        while (grpc_byte_buffer_reader_next(&reader, &slice) != 0) {
            if (buf == NULL) {
                buf = gpr_malloc(GRPC_SLICE_LENGTH(slice));
            } else {
                buf = gpr_realloc(buf, buf_len + GRPC_SLICE_LENGTH(slice));
            }
            if (buf == NULL) {
                grpc_slice_unref(slice);
                break;
            }
            if (memcpy(buf + buf_len, GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice)) == NULL) {
                gpr_free(buf);
                grpc_slice_unref(slice);
                return NULL;
            }
            buf_len += GRPC_SLICE_LENGTH(slice);
            grpc_slice_unref(slice);
            if (buf == NULL) break;
        }
        h = g_im__im_version_query_response__unpack(grpc_c_get_protobuf_c_allocator(context, &allocator), buf_len, (void *)buf);
        gpr_free(buf);
    }
    return h;
}

void
g_im__im_version_query_response_free (grpc_c_context_t *context, void *buf)
{
    struct ProtobufCAllocator allocator;
    if (buf == NULL) return;
    g_im__im_version_query_response__free_unpacked((GIm__ImVersionQueryResponse *)buf, grpc_c_get_protobuf_c_allocator(context, &allocator));
}
static const ProtobufCEnumValue g_im__cmd_type__enum_values_by_number[65] =
{
  { "BOARDCAST", "G_IM__CMD_TYPE__BOARDCAST", 0 },
  { "STEPFILE_UPDATE", "G_IM__CMD_TYPE__STEPFILE_UPDATE", 1 },
  { "CHANNEL_STEP_STRAT", "G_IM__CMD_TYPE__CHANNEL_STEP_STRAT", 2 },
  { "CHANNEL_PAUSE", "G_IM__CMD_TYPE__CHANNEL_PAUSE", 3 },
  { "CHANNEL_CONTINUE", "G_IM__CMD_TYPE__CHANNEL_CONTINUE", 4 },
  { "CHANNLE_STOP", "G_IM__CMD_TYPE__CHANNLE_STOP", 5 },
  { "CHANNLE_CLEAR_FAULT", "G_IM__CMD_TYPE__CHANNLE_CLEAR_FAULT", 6 },
  { "CHANNEL_DISABLE", "G_IM__CMD_TYPE__CHANNEL_DISABLE", 7 },
  { "CHANNEL_ENABLE", "G_IM__CMD_TYPE__CHANNEL_ENABLE", 8 },
  { "CHANNEL_UNION", "G_IM__CMD_TYPE__CHANNEL_UNION", 9 },
  { "CHANNEL_TRANS", "G_IM__CMD_TYPE__CHANNEL_TRANS", 10 },
  { "CHANNEL_LINK_CANCEL", "G_IM__CMD_TYPE__CHANNEL_LINK_CANCEL", 11 },
  { "CHANNEL_STEP_JUMP", "G_IM__CMD_TYPE__CHANNEL_STEP_JUMP", 12 },
  { "CHANNEL_PAUSE_APPOINT", "G_IM__CMD_TYPE__CHANNEL_PAUSE_APPOINT", 13 },
  { "CHANNEL_NEW_STEPFILE_DEL", "G_IM__CMD_TYPE__CHANNEL_NEW_STEPFILE_DEL", 14 },
  { "CHANNEL_ENABLE_BYIP", "G_IM__CMD_TYPE__CHANNEL_ENABLE_BYIP", 15 },
  { "IM_SOFTVESION_GET", "G_IM__CMD_TYPE__IM_SOFTVESION_GET", 16 },
  { "IM_SOFT_UPDATE", "G_IM__CMD_TYPE__IM_SOFT_UPDATE", 17 },
  { "SYSCONF_UPDATE", "G_IM__CMD_TYPE__SYSCONF_UPDATE", 18 },
  { "CLOCKTIME_SET", "G_IM__CMD_TYPE__CLOCKTIME_SET", 19 },
  { "SELFCHECK_GET", "G_IM__CMD_TYPE__SELFCHECK_GET", 20 },
  { "EXTERN_FILE_UPDATE", "G_IM__CMD_TYPE__EXTERN_FILE_UPDATE", 21 },
  { "IM_AUTH", "G_IM__CMD_TYPE__IM_AUTH", 22 },
  { "IM_AUTH_READ", "G_IM__CMD_TYPE__IM_AUTH_READ", 23 },
  { "SECURITY_FILE_UPDATE", "G_IM__CMD_TYPE__SECURITY_FILE_UPDATE", 24 },
  { "SECURITY_STOP", "G_IM__CMD_TYPE__SECURITY_STOP", 25 },
  { "SECURITY_TRANSFER_MODEL", "G_IM__CMD_TYPE__SECURITY_TRANSFER_MODEL", 26 },
  { "GET_SECURITY_DATA", "G_IM__CMD_TYPE__GET_SECURITY_DATA", 27 },
  { "FANS_STATE_GET", "G_IM__CMD_TYPE__FANS_STATE_GET", 28 },
  { "SECURITY_EX_TEMP_ENABLE", "G_IM__CMD_TYPE__SECURITY_EX_TEMP_ENABLE", 29 },
  { "LIGHT_SOUND_ALARM_ENABLE", "G_IM__CMD_TYPE__LIGHT_SOUND_ALARM_ENABLE", 30 },
  { "DATA_STORE_FOR_UNITS", "G_IM__CMD_TYPE__DATA_STORE_FOR_UNITS", 31 },
  { "IM_32VT_ENABLE", "G_IM__CMD_TYPE__IM_32VT_ENABLE", 32 },
  { "DATA_STORE_FOR_ALARM", "G_IM__CMD_TYPE__DATA_STORE_FOR_ALARM", 33 },
  { "IM_SYSTEM_RESTART", "G_IM__CMD_TYPE__IM_SYSTEM_RESTART", 34 },
  { "IM_READ_EEPROM", "G_IM__CMD_TYPE__IM_READ_EEPROM", 35 },
  { "IM_WRITE_EEPROM", "G_IM__CMD_TYPE__IM_WRITE_EEPROM", 36 },
  { "UNIT_CLEAR_FAULT", "G_IM__CMD_TYPE__UNIT_CLEAR_FAULT", 37 },
  { "DISPLAY_TIME_PROTECTION", "G_IM__CMD_TYPE__DISPLAY_TIME_PROTECTION", 38 },
  { "STOP_DISPLAY_TIME_RECORD", "G_IM__CMD_TYPE__STOP_DISPLAY_TIME_RECORD", 39 },
  { "STORAGE_FILE_UPDATE", "G_IM__CMD_TYPE__STORAGE_FILE_UPDATE", 40 },
  { "SECURITY_REST", "G_IM__CMD_TYPE__SECURITY_REST", 41 },
  { "SECURITY_FEEDBACK", "G_IM__CMD_TYPE__SECURITY_FEEDBACK", 42 },
  { "ADJUST_RELAY_CONTROL", "G_IM__CMD_TYPE__ADJUST_RELAY_CONTROL", 43 },
  { "ADJUST_LOAD_PARAM", "G_IM__CMD_TYPE__ADJUST_LOAD_PARAM", 44 },
  { "ADJUST_DEBUG", "G_IM__CMD_TYPE__ADJUST_DEBUG", 45 },
  { "ADJUST_CLEAR_FAULTS", "G_IM__CMD_TYPE__ADJUST_CLEAR_FAULTS", 46 },
  { "ADJUST_LOCK", "G_IM__CMD_TYPE__ADJUST_LOCK", 47 },
  { "ADJUST_UNLOCK", "G_IM__CMD_TYPE__ADJUST_UNLOCK", 48 },
  { "ADJUST_TRANS_CONTROL", "G_IM__CMD_TYPE__ADJUST_TRANS_CONTROL", 49 },
  { "NEGATIVE_PRESSURE_ADJUST", "G_IM__CMD_TYPE__NEGATIVE_PRESSURE_ADJUST", 50 },
  { "NEGATIVE_PRESSURE_LEAKAGE_DETECT_START", "G_IM__CMD_TYPE__NEGATIVE_PRESSURE_LEAKAGE_DETECT_START", 51 },
  { "NEGATIVE_PRESSURE_PLUGGING_DETECT_START", "G_IM__CMD_TYPE__NEGATIVE_PRESSURE_PLUGGING_DETECT_START", 52 },
  { "NEGATIVE_PRESSURE_FILE_UPDATE", "G_IM__CMD_TYPE__NEGATIVE_PRESSURE_FILE_UPDATE", 53 },
  { "PRESS_DISENGAGE", "G_IM__CMD_TYPE__PRESS_DISENGAGE", 54 },
  { "DEVICE_UPDATE_START", "G_IM__CMD_TYPE__DEVICE_UPDATE_START", 55 },
  { "DEVICE_PASSTHROUGH", "G_IM__CMD_TYPE__DEVICE_PASSTHROUGH", 56 },
  { "GET_DEVICE_UPDATE", "G_IM__CMD_TYPE__GET_DEVICE_UPDATE", 57 },
  { "DETECTIONFILE_UPDATE", "G_IM__CMD_TYPE__DETECTIONFILE_UPDATE", 58 },
  { "SET_STOCK_STATE", "G_IM__CMD_TYPE__SET_STOCK_STATE", 59 },
  { "NEGATIVE_PRESSURE_CLEAR_FAULT", "G_IM__CMD_TYPE__NEGATIVE_PRESSURE_CLEAR_FAULT", 60 },
  { "SWITCH_SECURIT", "G_IM__CMD_TYPE__SWITCH_SECURIT", 61 },
  { "SOUND_LIGHT_ALARM", "G_IM__CMD_TYPE__SOUND_LIGHT_ALARM", 62 },
  { "ADJUST_LOWERMACHINE_VERSION_READ", "G_IM__CMD_TYPE__ADJUST_LOWERMACHINE_VERSION_READ", 63 },
  { "CMD_TYPES_MAX", "G_IM__CMD_TYPE__CMD_TYPES_MAX", 64 },
};
static const ProtobufCIntRange g_im__cmd_type__value_ranges[] = {
{0, 0},{0, 65}
};
static const ProtobufCEnumValueIndex g_im__cmd_type__enum_values_by_name[65] =
{
  { "ADJUST_CLEAR_FAULTS", 46 },
  { "ADJUST_DEBUG", 45 },
  { "ADJUST_LOAD_PARAM", 44 },
  { "ADJUST_LOCK", 47 },
  { "ADJUST_LOWERMACHINE_VERSION_READ", 63 },
  { "ADJUST_RELAY_CONTROL", 43 },
  { "ADJUST_TRANS_CONTROL", 49 },
  { "ADJUST_UNLOCK", 48 },
  { "BOARDCAST", 0 },
  { "CHANNEL_CONTINUE", 4 },
  { "CHANNEL_DISABLE", 7 },
  { "CHANNEL_ENABLE", 8 },
  { "CHANNEL_ENABLE_BYIP", 15 },
  { "CHANNEL_LINK_CANCEL", 11 },
  { "CHANNEL_NEW_STEPFILE_DEL", 14 },
  { "CHANNEL_PAUSE", 3 },
  { "CHANNEL_PAUSE_APPOINT", 13 },
  { "CHANNEL_STEP_JUMP", 12 },
  { "CHANNEL_STEP_STRAT", 2 },
  { "CHANNEL_TRANS", 10 },
  { "CHANNEL_UNION", 9 },
  { "CHANNLE_CLEAR_FAULT", 6 },
  { "CHANNLE_STOP", 5 },
  { "CLOCKTIME_SET", 19 },
  { "CMD_TYPES_MAX", 64 },
  { "DATA_STORE_FOR_ALARM", 33 },
  { "DATA_STORE_FOR_UNITS", 31 },
  { "DETECTIONFILE_UPDATE", 58 },
  { "DEVICE_PASSTHROUGH", 56 },
  { "DEVICE_UPDATE_START", 55 },
  { "DISPLAY_TIME_PROTECTION", 38 },
  { "EXTERN_FILE_UPDATE", 21 },
  { "FANS_STATE_GET", 28 },
  { "GET_DEVICE_UPDATE", 57 },
  { "GET_SECURITY_DATA", 27 },
  { "IM_32VT_ENABLE", 32 },
  { "IM_AUTH", 22 },
  { "IM_AUTH_READ", 23 },
  { "IM_READ_EEPROM", 35 },
  { "IM_SOFTVESION_GET", 16 },
  { "IM_SOFT_UPDATE", 17 },
  { "IM_SYSTEM_RESTART", 34 },
  { "IM_WRITE_EEPROM", 36 },
  { "LIGHT_SOUND_ALARM_ENABLE", 30 },
  { "NEGATIVE_PRESSURE_ADJUST", 50 },
  { "NEGATIVE_PRESSURE_CLEAR_FAULT", 60 },
  { "NEGATIVE_PRESSURE_FILE_UPDATE", 53 },
  { "NEGATIVE_PRESSURE_LEAKAGE_DETECT_START", 51 },
  { "NEGATIVE_PRESSURE_PLUGGING_DETECT_START", 52 },
  { "PRESS_DISENGAGE", 54 },
  { "SECURITY_EX_TEMP_ENABLE", 29 },
  { "SECURITY_FEEDBACK", 42 },
  { "SECURITY_FILE_UPDATE", 24 },
  { "SECURITY_REST", 41 },
  { "SECURITY_STOP", 25 },
  { "SECURITY_TRANSFER_MODEL", 26 },
  { "SELFCHECK_GET", 20 },
  { "SET_STOCK_STATE", 59 },
  { "SOUND_LIGHT_ALARM", 62 },
  { "STEPFILE_UPDATE", 1 },
  { "STOP_DISPLAY_TIME_RECORD", 39 },
  { "STORAGE_FILE_UPDATE", 40 },
  { "SWITCH_SECURIT", 61 },
  { "SYSCONF_UPDATE", 18 },
  { "UNIT_CLEAR_FAULT", 37 },
};
const ProtobufCEnumDescriptor g_im__cmd_type__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.cmd_type",
  "cmd_type",
  "GIm__CmdType",
  "g_im",
  65,
  g_im__cmd_type__enum_values_by_number,
  65,
  g_im__cmd_type__enum_values_by_name,
  1,
  g_im__cmd_type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__cmd_result__enum_values_by_number[35] =
{
  { "CMD_SUCCESS", "G_IM__CMD_RESULT__CMD_SUCCESS", 0 },
  { "CMD_NO_MATCH", "G_IM__CMD_RESULT__CMD_NO_MATCH", 1 },
  { "FILE_NOEXIST", "G_IM__CMD_RESULT__FILE_NOEXIST", 2 },
  { "FILE_OPEN_FAIL", "G_IM__CMD_RESULT__FILE_OPEN_FAIL", 3 },
  { "FILE_FORMAT_ERR", "G_IM__CMD_RESULT__FILE_FORMAT_ERR", 4 },
  { "FILE_COPY_FAIL", "G_IM__CMD_RESULT__FILE_COPY_FAIL", 5 },
  { "FILE_RENAME_FAILE", "G_IM__CMD_RESULT__FILE_RENAME_FAILE", 6 },
  { "FILE_PARSE_FAIL", "G_IM__CMD_RESULT__FILE_PARSE_FAIL", 7 },
  { "FILE_DEL_FAIL", "G_IM__CMD_RESULT__FILE_DEL_FAIL", 8 },
  { "FILE_SAVE_FILE", "G_IM__CMD_RESULT__FILE_SAVE_FILE", 9 },
  { "LOWER_CONNECT_TIMEOUT", "G_IM__CMD_RESULT__LOWER_CONNECT_TIMEOUT", 11 },
  { "CHANNEL_NO_MATCH", "G_IM__CMD_RESULT__CHANNEL_NO_MATCH", 12 },
  { "PARAM_INVALID", "G_IM__CMD_RESULT__PARAM_INVALID", 13 },
  { "CMD_NO_DEAL", "G_IM__CMD_RESULT__CMD_NO_DEAL", 14 },
  { "WORK_FILE_INVALID", "G_IM__CMD_RESULT__WORK_FILE_INVALID", 15 },
  { "SYSTEM_TIME_FALSE", "G_IM__CMD_RESULT__SYSTEM_TIME_FALSE", 16 },
  { "GET_CUSTOM_VAR_FAIL", "G_IM__CMD_RESULT__GET_CUSTOM_VAR_FAIL", 17 },
  { "IM_DEALING_CMD_TO_LOWER", "G_IM__CMD_RESULT__IM_DEALING_CMD_TO_LOWER", 18 },
  { "LOWER_ALARM", "G_IM__CMD_RESULT__LOWER_ALARM", 19 },
  { "PASSWD_FALSE", "G_IM__CMD_RESULT__PASSWD_FALSE", 20 },
  { "SECURITY_SET_INVALID", "G_IM__CMD_RESULT__SECURITY_SET_INVALID", 21 },
  { "CHANNEL_BUSY", "G_IM__CMD_RESULT__CHANNEL_BUSY", 22 },
  { "AUTH_TIME_INVALID", "G_IM__CMD_RESULT__AUTH_TIME_INVALID", 23 },
  { "AUTH_TIMES_EXCEED", "G_IM__CMD_RESULT__AUTH_TIMES_EXCEED", 24 },
  { "AUTH_TIME_EXCEED", "G_IM__CMD_RESULT__AUTH_TIME_EXCEED", 25 },
  { "CHANNEL_NO_EXIST", "G_IM__CMD_RESULT__CHANNEL_NO_EXIST", 26 },
  { "SYSTIME_SET_FAIL", "G_IM__CMD_RESULT__SYSTIME_SET_FAIL", 27 },
  { "CHANNEL_TRANS_FAIL", "G_IM__CMD_RESULT__CHANNEL_TRANS_FAIL", 28 },
  { "STEP_SET_ERROR", "G_IM__CMD_RESULT__STEP_SET_ERROR", 29 },
  { "STEP_VERSION_ERROR", "G_IM__CMD_RESULT__STEP_VERSION_ERROR", 30 },
  { "IM_NO_MEMORY", "G_IM__CMD_RESULT__IM_NO_MEMORY", 31 },
  { "IM_OTHER_ERR_MSG", "G_IM__CMD_RESULT__IM_OTHER_ERR_MSG", 32 },
  { "NP_PRESSURE", "G_IM__CMD_RESULT__NP_PRESSURE", 33 },
  { "IS_PRESSURE", "G_IM__CMD_RESULT__IS_PRESSURE", 34 },
  { "STOCK_RUNNING", "G_IM__CMD_RESULT__STOCK_RUNNING", 35 },
};
static const ProtobufCIntRange g_im__cmd_result__value_ranges[] = {
{0, 0},{11, 10},{0, 35}
};
static const ProtobufCEnumValueIndex g_im__cmd_result__enum_values_by_name[35] =
{
  { "AUTH_TIMES_EXCEED", 23 },
  { "AUTH_TIME_EXCEED", 24 },
  { "AUTH_TIME_INVALID", 22 },
  { "CHANNEL_BUSY", 21 },
  { "CHANNEL_NO_EXIST", 25 },
  { "CHANNEL_NO_MATCH", 11 },
  { "CHANNEL_TRANS_FAIL", 27 },
  { "CMD_NO_DEAL", 13 },
  { "CMD_NO_MATCH", 1 },
  { "CMD_SUCCESS", 0 },
  { "FILE_COPY_FAIL", 5 },
  { "FILE_DEL_FAIL", 8 },
  { "FILE_FORMAT_ERR", 4 },
  { "FILE_NOEXIST", 2 },
  { "FILE_OPEN_FAIL", 3 },
  { "FILE_PARSE_FAIL", 7 },
  { "FILE_RENAME_FAILE", 6 },
  { "FILE_SAVE_FILE", 9 },
  { "GET_CUSTOM_VAR_FAIL", 16 },
  { "IM_DEALING_CMD_TO_LOWER", 17 },
  { "IM_NO_MEMORY", 30 },
  { "IM_OTHER_ERR_MSG", 31 },
  { "IS_PRESSURE", 33 },
  { "LOWER_ALARM", 18 },
  { "LOWER_CONNECT_TIMEOUT", 10 },
  { "NP_PRESSURE", 32 },
  { "PARAM_INVALID", 12 },
  { "PASSWD_FALSE", 19 },
  { "SECURITY_SET_INVALID", 20 },
  { "STEP_SET_ERROR", 28 },
  { "STEP_VERSION_ERROR", 29 },
  { "STOCK_RUNNING", 34 },
  { "SYSTEM_TIME_FALSE", 15 },
  { "SYSTIME_SET_FAIL", 26 },
  { "WORK_FILE_INVALID", 14 },
};
const ProtobufCEnumDescriptor g_im__cmd_result__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.cmd_result",
  "cmd_result",
  "GIm__CmdResult",
  "g_im",
  35,
  g_im__cmd_result__enum_values_by_number,
  35,
  g_im__cmd_result__enum_values_by_name,
  2,
  g_im__cmd_result__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__sysconf_update_type__enum_values_by_number[9] =
{
  { "UPDATE_ALL", "G_IM__SYSCONF_UPDATE_TYPE__UPDATE_ALL", 0 },
  { "CHANNEL_UPDATE", "G_IM__SYSCONF_UPDATE_TYPE__CHANNEL_UPDATE", 1 },
  { "IM_INFO_UPDATE", "G_IM__SYSCONF_UPDATE_TYPE__IM_INFO_UPDATE", 2 },
  { "ETH0_UPDATE", "G_IM__SYSCONF_UPDATE_TYPE__ETH0_UPDATE", 3 },
  { "ETH1_UPDATE", "G_IM__SYSCONF_UPDATE_TYPE__ETH1_UPDATE", 4 },
  { "PC_INFO_UPDATE", "G_IM__SYSCONF_UPDATE_TYPE__PC_INFO_UPDATE", 5 },
  { "MOBILE_UPDATE", "G_IM__SYSCONF_UPDATE_TYPE__MOBILE_UPDATE", 6 },
  { "CLOUD_UPDATE", "G_IM__SYSCONF_UPDATE_TYPE__CLOUD_UPDATE", 7 },
  { "PeripheralsUpdate", "G_IM__SYSCONF_UPDATE_TYPE__PeripheralsUpdate", 8 },
};
static const ProtobufCIntRange g_im__sysconf_update_type__value_ranges[] = {
{0, 0},{0, 9}
};
static const ProtobufCEnumValueIndex g_im__sysconf_update_type__enum_values_by_name[9] =
{
  { "CHANNEL_UPDATE", 1 },
  { "CLOUD_UPDATE", 7 },
  { "ETH0_UPDATE", 3 },
  { "ETH1_UPDATE", 4 },
  { "IM_INFO_UPDATE", 2 },
  { "MOBILE_UPDATE", 6 },
  { "PC_INFO_UPDATE", 5 },
  { "PeripheralsUpdate", 8 },
  { "UPDATE_ALL", 0 },
};
const ProtobufCEnumDescriptor g_im__sysconf_update_type__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.sysconf_update_type",
  "sysconf_update_type",
  "GIm__SysconfUpdateType",
  "g_im",
  9,
  g_im__sysconf_update_type__enum_values_by_number,
  9,
  g_im__sysconf_update_type__enum_values_by_name,
  1,
  g_im__sysconf_update_type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__auth_type__enum_values_by_number[3] =
{
  { "UNLIMITED", "G_IM__AUTH_TYPE__UNLIMITED", 0 },
  { "AUTH_BY_TIMES", "G_IM__AUTH_TYPE__AUTH_BY_TIMES", 1 },
  { "AUTH_BY_TIMER", "G_IM__AUTH_TYPE__AUTH_BY_TIMER", 2 },
};
static const ProtobufCIntRange g_im__auth_type__value_ranges[] = {
{0, 0},{0, 3}
};
static const ProtobufCEnumValueIndex g_im__auth_type__enum_values_by_name[3] =
{
  { "AUTH_BY_TIMER", 2 },
  { "AUTH_BY_TIMES", 1 },
  { "UNLIMITED", 0 },
};
const ProtobufCEnumDescriptor g_im__auth_type__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.auth_type",
  "auth_type",
  "GIm__AuthType",
  "g_im",
  3,
  g_im__auth_type__enum_values_by_number,
  3,
  g_im__auth_type__enum_values_by_name,
  1,
  g_im__auth_type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__channel_st__enum_values_by_number[28] =
{
  { "CHANNEL_ST_READY", "G_IM__CHANNEL_ST__CHANNEL_ST_READY", 0 },
  { "CHANNEL_ST_CHARGE", "G_IM__CHANNEL_ST__CHANNEL_ST_CHARGE", 1 },
  { "CHANNEL_ST_DISCHARGE", "G_IM__CHANNEL_ST__CHANNEL_ST_DISCHARGE", 2 },
  { "CHANNEL_ST_STEWING", "G_IM__CHANNEL_ST__CHANNEL_ST_STEWING", 3 },
  { "CHANNEL_ST_WORK_CONDITION", "G_IM__CHANNEL_ST__CHANNEL_ST_WORK_CONDITION", 4 },
  { "CHANNEL_ST_OK", "G_IM__CHANNEL_ST__CHANNEL_ST_OK", 5 },
  { "CHANNEL_ST_NOK", "G_IM__CHANNEL_ST__CHANNEL_ST_NOK", 6 },
  { "CHANNEL_ST_DEVICE_ALARM", "G_IM__CHANNEL_ST__CHANNEL_ST_DEVICE_ALARM", 7 },
  { "CHANNEL_ST_USER_TERMINATE", "G_IM__CHANNEL_ST__CHANNEL_ST_USER_TERMINATE", 8 },
  { "CHANNEL_ST_COMM_ERROR", "G_IM__CHANNEL_ST__CHANNEL_ST_COMM_ERROR", 9 },
  { "CHANNEL_ST_NOT_CONNECT_BATTERY", "G_IM__CHANNEL_ST__CHANNEL_ST_NOT_CONNECT_BATTERY", 10 },
  { "CHANNEL_ST_DISABLE", "G_IM__CHANNEL_ST__CHANNEL_ST_DISABLE", 11 },
  { "CHANNEL_ST_PAUSE", "G_IM__CHANNEL_ST__CHANNEL_ST_PAUSE", 12 },
  { "CHANNEL_ST_APPOINT_TIME_PAUSE", "G_IM__CHANNEL_ST__CHANNEL_ST_APPOINT_TIME_PAUSE", 13 },
  { "CHANNEL_ST_APPOINT_STEP_PAUSE", "G_IM__CHANNEL_ST__CHANNEL_ST_APPOINT_STEP_PAUSE", 14 },
  { "CHANNEL_ST_APPOINT_LOOP_PAUSE", "G_IM__CHANNEL_ST__CHANNEL_ST_APPOINT_LOOP_PAUSE", 15 },
  { "CHANNEL_ST_EXTERN_COMM_ERROR", "G_IM__CHANNEL_ST__CHANNEL_ST_EXTERN_COMM_ERROR", 16 },
  { "CHANNEL_ST_WAIT_FOR_LINKAGE", "G_IM__CHANNEL_ST__CHANNEL_ST_WAIT_FOR_LINKAGE", 19 },
  { "CHANNEL_ST_FREE_TIME_RECORD", "G_IM__CHANNEL_ST__CHANNEL_ST_FREE_TIME_RECORD", 20 },
  { "CHANNEL_ST_CC", "G_IM__CHANNEL_ST__CHANNEL_ST_CC", 21 },
  { "CHANNEL_ST_CV", "G_IM__CHANNEL_ST__CHANNEL_ST_CV", 22 },
  { "CHANNEL_ST_CCCV", "G_IM__CHANNEL_ST__CHANNEL_ST_CCCV", 23 },
  { "CHANNEL_ST_DC", "G_IM__CHANNEL_ST__CHANNEL_ST_DC", 24 },
  { "CHANNEL_ADJUSTING", "G_IM__CHANNEL_ST__CHANNEL_ADJUSTING", 25 },
  { "CHANNEL_MAINTAINED", "G_IM__CHANNEL_ST__CHANNEL_MAINTAINED", 26 },
  { "CHANNEL_ST_PRESSURE_PAUSE", "G_IM__CHANNEL_ST__CHANNEL_ST_PRESSURE_PAUSE", 29 },
  { "CHANNEL_ST_BYPASS", "G_IM__CHANNEL_ST__CHANNEL_ST_BYPASS", 30 },
  { "CHANNEL_ST_MAX", "G_IM__CHANNEL_ST__CHANNEL_ST_MAX", 99 },
};
static const ProtobufCIntRange g_im__channel_st__value_ranges[] = {
{0, 0},{19, 17},{29, 25},{99, 27},{0, 28}
};
static const ProtobufCEnumValueIndex g_im__channel_st__enum_values_by_name[28] =
{
  { "CHANNEL_ADJUSTING", 23 },
  { "CHANNEL_MAINTAINED", 24 },
  { "CHANNEL_ST_APPOINT_LOOP_PAUSE", 15 },
  { "CHANNEL_ST_APPOINT_STEP_PAUSE", 14 },
  { "CHANNEL_ST_APPOINT_TIME_PAUSE", 13 },
  { "CHANNEL_ST_BYPASS", 26 },
  { "CHANNEL_ST_CC", 19 },
  { "CHANNEL_ST_CCCV", 21 },
  { "CHANNEL_ST_CHARGE", 1 },
  { "CHANNEL_ST_COMM_ERROR", 9 },
  { "CHANNEL_ST_CV", 20 },
  { "CHANNEL_ST_DC", 22 },
  { "CHANNEL_ST_DEVICE_ALARM", 7 },
  { "CHANNEL_ST_DISABLE", 11 },
  { "CHANNEL_ST_DISCHARGE", 2 },
  { "CHANNEL_ST_EXTERN_COMM_ERROR", 16 },
  { "CHANNEL_ST_FREE_TIME_RECORD", 18 },
  { "CHANNEL_ST_MAX", 27 },
  { "CHANNEL_ST_NOK", 6 },
  { "CHANNEL_ST_NOT_CONNECT_BATTERY", 10 },
  { "CHANNEL_ST_OK", 5 },
  { "CHANNEL_ST_PAUSE", 12 },
  { "CHANNEL_ST_PRESSURE_PAUSE", 25 },
  { "CHANNEL_ST_READY", 0 },
  { "CHANNEL_ST_STEWING", 3 },
  { "CHANNEL_ST_USER_TERMINATE", 8 },
  { "CHANNEL_ST_WAIT_FOR_LINKAGE", 17 },
  { "CHANNEL_ST_WORK_CONDITION", 4 },
};
const ProtobufCEnumDescriptor g_im__channel_st__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.channel_st",
  "channel_st",
  "GIm__ChannelSt",
  "g_im",
  28,
  g_im__channel_st__enum_values_by_number,
  28,
  g_im__channel_st__enum_values_by_name,
  4,
  g_im__channel_st__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__power_channel_st__enum_values_by_number[10] =
{
  { "POWER_CHANNEL_ST_READY", "G_IM__POWER_CHANNEL_ST__POWER_CHANNEL_ST_READY", 0 },
  { "POWER_CHANNEL_ST_RUN", "G_IM__POWER_CHANNEL_ST__POWER_CHANNEL_ST_RUN", 1 },
  { "POWER_CHANNEL_ST_ABNORMAL", "G_IM__POWER_CHANNEL_ST__POWER_CHANNEL_ST_ABNORMAL", 2 },
  { "POWER_CHANNEL_ST_PAUSE", "G_IM__POWER_CHANNEL_ST__POWER_CHANNEL_ST_PAUSE", 3 },
  { "POWER_CHANNEL_ST_LOCK", "G_IM__POWER_CHANNEL_ST__POWER_CHANNEL_ST_LOCK", 4 },
  { "POWER_CHANNEL_ST_TERMINATE", "G_IM__POWER_CHANNEL_ST__POWER_CHANNEL_ST_TERMINATE", 5 },
  { "POWER_CHANNEL_ST_OK", "G_IM__POWER_CHANNEL_ST__POWER_CHANNEL_ST_OK", 6 },
  { "POWER_CHANNEL_ADJUSTING", "G_IM__POWER_CHANNEL_ST__POWER_CHANNEL_ADJUSTING", 7 },
  { "POWER_MAINTAINED", "G_IM__POWER_CHANNEL_ST__POWER_MAINTAINED", 8 },
  { "POWER__PRESSURE_PAUSE", "G_IM__POWER_CHANNEL_ST__POWER__PRESSURE_PAUSE", 9 },
};
static const ProtobufCIntRange g_im__power_channel_st__value_ranges[] = {
{0, 0},{0, 10}
};
static const ProtobufCEnumValueIndex g_im__power_channel_st__enum_values_by_name[10] =
{
  { "POWER_CHANNEL_ADJUSTING", 7 },
  { "POWER_CHANNEL_ST_ABNORMAL", 2 },
  { "POWER_CHANNEL_ST_LOCK", 4 },
  { "POWER_CHANNEL_ST_OK", 6 },
  { "POWER_CHANNEL_ST_PAUSE", 3 },
  { "POWER_CHANNEL_ST_READY", 0 },
  { "POWER_CHANNEL_ST_RUN", 1 },
  { "POWER_CHANNEL_ST_TERMINATE", 5 },
  { "POWER_MAINTAINED", 8 },
  { "POWER__PRESSURE_PAUSE", 9 },
};
const ProtobufCEnumDescriptor g_im__power_channel_st__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.power_channel_st",
  "power_channel_st",
  "GIm__PowerChannelSt",
  "g_im",
  10,
  g_im__power_channel_st__enum_values_by_number,
  10,
  g_im__power_channel_st__enum_values_by_name,
  1,
  g_im__power_channel_st__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__ch_assist_st__enum_values_by_number[5] =
{
  { "CH_ASSIST_ST_NONE", "G_IM__CH_ASSIST_ST__CH_ASSIST_ST_NONE", 0 },
  { "CH_ASSIST_ST_DISPLAY_TIME", "G_IM__CH_ASSIST_ST__CH_ASSIST_ST_DISPLAY_TIME", 1 },
  { "CH_ASSIST_ST_DISPLAY_TIME_OK", "G_IM__CH_ASSIST_ST__CH_ASSIST_ST_DISPLAY_TIME_OK", 2 },
  { "CH_ASSIST_ST_DISPLAY_TIME_TERMINATE", "G_IM__CH_ASSIST_ST__CH_ASSIST_ST_DISPLAY_TIME_TERMINATE", 3 },
  { "CH_ASSIST_ST_MAX", "G_IM__CH_ASSIST_ST__CH_ASSIST_ST_MAX", 4 },
};
static const ProtobufCIntRange g_im__ch_assist_st__value_ranges[] = {
{0, 0},{0, 5}
};
static const ProtobufCEnumValueIndex g_im__ch_assist_st__enum_values_by_name[5] =
{
  { "CH_ASSIST_ST_DISPLAY_TIME", 1 },
  { "CH_ASSIST_ST_DISPLAY_TIME_OK", 2 },
  { "CH_ASSIST_ST_DISPLAY_TIME_TERMINATE", 3 },
  { "CH_ASSIST_ST_MAX", 4 },
  { "CH_ASSIST_ST_NONE", 0 },
};
const ProtobufCEnumDescriptor g_im__ch_assist_st__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.ch_assist_st",
  "ch_assist_st",
  "GIm__ChAssistSt",
  "g_im",
  5,
  g_im__ch_assist_st__enum_values_by_number,
  5,
  g_im__ch_assist_st__enum_values_by_name,
  1,
  g_im__ch_assist_st__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__im_eeprom_type__enum_values_by_number[8] =
{
  { "EEP_RESERVED", "G_IM__IM_EEPROM_TYPE__EEP_RESERVED", 0 },
  { "EEP_MODEL", "G_IM__IM_EEPROM_TYPE__EEP_MODEL", 1 },
  { "EEP_CHANNEL", "G_IM__IM_EEPROM_TYPE__EEP_CHANNEL", 2 },
  { "EEP_BARCODE", "G_IM__IM_EEPROM_TYPE__EEP_BARCODE", 3 },
  { "EEP_SAMPLER_TIME", "G_IM__IM_EEPROM_TYPE__EEP_SAMPLER_TIME", 4 },
  { "EEP_RECORD_INTERVAL", "G_IM__IM_EEPROM_TYPE__EEP_RECORD_INTERVAL", 5 },
  { "EEP_DEVICE_CONFIG", "G_IM__IM_EEPROM_TYPE__EEP_DEVICE_CONFIG", 6 },
  { "EEP_CALIBRATION", "G_IM__IM_EEPROM_TYPE__EEP_CALIBRATION", 7 },
};
static const ProtobufCIntRange g_im__im_eeprom_type__value_ranges[] = {
{0, 0},{0, 8}
};
static const ProtobufCEnumValueIndex g_im__im_eeprom_type__enum_values_by_name[8] =
{
  { "EEP_BARCODE", 3 },
  { "EEP_CALIBRATION", 7 },
  { "EEP_CHANNEL", 2 },
  { "EEP_DEVICE_CONFIG", 6 },
  { "EEP_MODEL", 1 },
  { "EEP_RECORD_INTERVAL", 5 },
  { "EEP_RESERVED", 0 },
  { "EEP_SAMPLER_TIME", 4 },
};
const ProtobufCEnumDescriptor g_im__im_eeprom_type__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.im_eeprom_type",
  "im_eeprom_type",
  "GIm__ImEepromType",
  "g_im",
  8,
  g_im__im_eeprom_type__enum_values_by_number,
  8,
  g_im__im_eeprom_type__enum_values_by_name,
  1,
  g_im__im_eeprom_type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__im_fator_type__enum_values_by_number[3] =
{
  { "EPP_FT_RESERVED", "G_IM__IM_FATOR_TYPE__EPP_FT_RESERVED", 0 },
  { "AV", "G_IM__IM_FATOR_TYPE__AV", 1 },
  { "PV", "G_IM__IM_FATOR_TYPE__PV", 2 },
};
static const ProtobufCIntRange g_im__im_fator_type__value_ranges[] = {
{0, 0},{0, 3}
};
static const ProtobufCEnumValueIndex g_im__im_fator_type__enum_values_by_name[3] =
{
  { "AV", 1 },
  { "EPP_FT_RESERVED", 0 },
  { "PV", 2 },
};
const ProtobufCEnumDescriptor g_im__im_fator_type__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.im_fator_type",
  "im_fator_type",
  "GIm__ImFatorType",
  "g_im",
  3,
  g_im__im_fator_type__enum_values_by_number,
  3,
  g_im__im_fator_type__enum_values_by_name,
  1,
  g_im__im_fator_type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__im_fator_option__enum_values_by_number[9] =
{
  { "EPP_FO_RESERVED", "G_IM__IM_FATOR_OPTION__EPP_FO_RESERVED", 0 },
  { "CV", "G_IM__IM_FATOR_OPTION__CV", 1 },
  { "CC", "G_IM__IM_FATOR_OPTION__CC", 2 },
  { "DV", "G_IM__IM_FATOR_OPTION__DV", 3 },
  { "DC", "G_IM__IM_FATOR_OPTION__DC", 4 },
  { "BT", "G_IM__IM_FATOR_OPTION__BT", 5 },
  { "DT", "G_IM__IM_FATOR_OPTION__DT", 6 },
  { "DCDC_IN", "G_IM__IM_FATOR_OPTION__DCDC_IN", 7 },
  { "DCDC_OUT", "G_IM__IM_FATOR_OPTION__DCDC_OUT", 8 },
};
static const ProtobufCIntRange g_im__im_fator_option__value_ranges[] = {
{0, 0},{0, 9}
};
static const ProtobufCEnumValueIndex g_im__im_fator_option__enum_values_by_name[9] =
{
  { "BT", 5 },
  { "CC", 2 },
  { "CV", 1 },
  { "DC", 4 },
  { "DCDC_IN", 7 },
  { "DCDC_OUT", 8 },
  { "DT", 6 },
  { "DV", 3 },
  { "EPP_FO_RESERVED", 0 },
};
const ProtobufCEnumDescriptor g_im__im_fator_option__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.im_fator_option",
  "im_fator_option",
  "GIm__ImFatorOption",
  "g_im",
  9,
  g_im__im_fator_option__enum_values_by_number,
  9,
  g_im__im_fator_option__enum_values_by_name,
  1,
  g_im__im_fator_option__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__im_appoint_stop_type__enum_values_by_number[3] =
{
  { "appoint_step_stop", "G_IM__IM_APPOINT_STOP_TYPE__appoint_step_stop", 0 },
  { "appoint_loop_stop", "G_IM__IM_APPOINT_STOP_TYPE__appoint_loop_stop", 1 },
  { "appoint_time_stop", "G_IM__IM_APPOINT_STOP_TYPE__appoint_time_stop", 2 },
};
static const ProtobufCIntRange g_im__im_appoint_stop_type__value_ranges[] = {
{0, 0},{0, 3}
};
static const ProtobufCEnumValueIndex g_im__im_appoint_stop_type__enum_values_by_name[3] =
{
  { "appoint_loop_stop", 1 },
  { "appoint_step_stop", 0 },
  { "appoint_time_stop", 2 },
};
const ProtobufCEnumDescriptor g_im__im_appoint_stop_type__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.im_appoint_stop_type",
  "im_appoint_stop_type",
  "GIm__ImAppointStopType",
  "g_im",
  3,
  g_im__im_appoint_stop_type__enum_values_by_number,
  3,
  g_im__im_appoint_stop_type__enum_values_by_name,
  1,
  g_im__im_appoint_stop_type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__im_warn_type__enum_values_by_number[7] =
{
  { "extern_device_warn", "G_IM__IM_WARN_TYPE__extern_device_warn", 0 },
  { "extern_device_judge_warn", "G_IM__IM_WARN_TYPE__extern_device_judge_warn", 1 },
  { "channel_warn", "G_IM__IM_WARN_TYPE__channel_warn", 2 },
  { "channel_judge_warn", "G_IM__IM_WARN_TYPE__channel_judge_warn", 3 },
  { "step_judge_warn", "G_IM__IM_WARN_TYPE__step_judge_warn", 4 },
  { "power_ac_warn", "G_IM__IM_WARN_TYPE__power_ac_warn", 5 },
  { "security_warn", "G_IM__IM_WARN_TYPE__security_warn", 6 },
};
static const ProtobufCIntRange g_im__im_warn_type__value_ranges[] = {
{0, 0},{0, 7}
};
static const ProtobufCEnumValueIndex g_im__im_warn_type__enum_values_by_name[7] =
{
  { "channel_judge_warn", 3 },
  { "channel_warn", 2 },
  { "extern_device_judge_warn", 1 },
  { "extern_device_warn", 0 },
  { "power_ac_warn", 5 },
  { "security_warn", 6 },
  { "step_judge_warn", 4 },
};
const ProtobufCEnumDescriptor g_im__im_warn_type__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.im_warn_type",
  "im_warn_type",
  "GIm__ImWarnType",
  "g_im",
  7,
  g_im__im_warn_type__enum_values_by_number,
  7,
  g_im__im_warn_type__enum_values_by_name,
  1,
  g_im__im_warn_type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__lower_machine_warn_type__enum_values_by_number[25] =
{
  { "NO_WARN", "G_IM__LOWER_MACHINE_WARN_TYPE__NO_WARN", 0 },
  { "DC_DC_INPUT_OVER_VOLTAGE", "G_IM__LOWER_MACHINE_WARN_TYPE__DC_DC_INPUT_OVER_VOLTAGE", 1 },
  { "DC_DC_OUPUT_OVER_VOLTAGE", "G_IM__LOWER_MACHINE_WARN_TYPE__DC_DC_OUPUT_OVER_VOLTAGE", 2 },
  { "DC_DC_OUPUT_OVER_CURRENT", "G_IM__LOWER_MACHINE_WARN_TYPE__DC_DC_OUPUT_OVER_CURRENT", 3 },
  { "DC_DC_OVER_TEMP", "G_IM__LOWER_MACHINE_WARN_TYPE__DC_DC_OVER_TEMP", 4 },
  { "DC_DC_INPUT_VOLTAGE_ABNORMAL", "G_IM__LOWER_MACHINE_WARN_TYPE__DC_DC_INPUT_VOLTAGE_ABNORMAL", 5 },
  { "DC_DC_OUTPUT_VOLTAGE_ABNORMAL", "G_IM__LOWER_MACHINE_WARN_TYPE__DC_DC_OUTPUT_VOLTAGE_ABNORMAL", 6 },
  { "AD_TIMEOUT", "G_IM__LOWER_MACHINE_WARN_TYPE__AD_TIMEOUT", 7 },
  { "EEPROM_TIMEOUT", "G_IM__LOWER_MACHINE_WARN_TYPE__EEPROM_TIMEOUT", 8 },
  { "INIT_FAILED", "G_IM__LOWER_MACHINE_WARN_TYPE__INIT_FAILED", 9 },
  { "PARALLEL_START_TIMEOUT", "G_IM__LOWER_MACHINE_WARN_TYPE__PARALLEL_START_TIMEOUT", 10 },
  { "PARALLEL_CLOSE_TIMEOUT", "G_IM__LOWER_MACHINE_WARN_TYPE__PARALLEL_CLOSE_TIMEOUT", 11 },
  { "PRECHARGE_FAILED", "G_IM__LOWER_MACHINE_WARN_TYPE__PRECHARGE_FAILED", 12 },
  { "SAMPLE_LINE_FALL_OFF", "G_IM__LOWER_MACHINE_WARN_TYPE__SAMPLE_LINE_FALL_OFF", 13 },
  { "PARALLEL_CIRCUIT_FAULT", "G_IM__LOWER_MACHINE_WARN_TYPE__PARALLEL_CIRCUIT_FAULT", 14 },
  { "VOLTAGE_UPPER_LIMIT_GUARD", "G_IM__LOWER_MACHINE_WARN_TYPE__VOLTAGE_UPPER_LIMIT_GUARD", 15 },
  { "VOLTAGE_LOWER_LIMIT_GUARD", "G_IM__LOWER_MACHINE_WARN_TYPE__VOLTAGE_LOWER_LIMIT_GUARD", 16 },
  { "CURRENT_UPPER_LIMIT_GUARD", "G_IM__LOWER_MACHINE_WARN_TYPE__CURRENT_UPPER_LIMIT_GUARD", 17 },
  { "CURRENT_LOWER_LIMIT_GUARD", "G_IM__LOWER_MACHINE_WARN_TYPE__CURRENT_LOWER_LIMIT_GUARD", 18 },
  { "TEMP_UPPER_LIMIT_GUARD", "G_IM__LOWER_MACHINE_WARN_TYPE__TEMP_UPPER_LIMIT_GUARD", 19 },
  { "TEMP_LOWER_LIMIT_GUARD", "G_IM__LOWER_MACHINE_WARN_TYPE__TEMP_LOWER_LIMIT_GUARD", 20 },
  { "OUTPUT_SHORT_CIRCUIT_GUARD", "G_IM__LOWER_MACHINE_WARN_TYPE__OUTPUT_SHORT_CIRCUIT_GUARD", 21 },
  { "BATTERY_REVERSAL", "G_IM__LOWER_MACHINE_WARN_TYPE__BATTERY_REVERSAL", 22 },
  { "DC_DC_FAN_FAULT", "G_IM__LOWER_MACHINE_WARN_TYPE__DC_DC_FAN_FAULT", 23 },
  { "BATTERY_GUARD_OR_DROPPED", "G_IM__LOWER_MACHINE_WARN_TYPE__BATTERY_GUARD_OR_DROPPED", 24 },
};
static const ProtobufCIntRange g_im__lower_machine_warn_type__value_ranges[] = {
{0, 0},{0, 25}
};
static const ProtobufCEnumValueIndex g_im__lower_machine_warn_type__enum_values_by_name[25] =
{
  { "AD_TIMEOUT", 7 },
  { "BATTERY_GUARD_OR_DROPPED", 24 },
  { "BATTERY_REVERSAL", 22 },
  { "CURRENT_LOWER_LIMIT_GUARD", 18 },
  { "CURRENT_UPPER_LIMIT_GUARD", 17 },
  { "DC_DC_FAN_FAULT", 23 },
  { "DC_DC_INPUT_OVER_VOLTAGE", 1 },
  { "DC_DC_INPUT_VOLTAGE_ABNORMAL", 5 },
  { "DC_DC_OUPUT_OVER_CURRENT", 3 },
  { "DC_DC_OUPUT_OVER_VOLTAGE", 2 },
  { "DC_DC_OUTPUT_VOLTAGE_ABNORMAL", 6 },
  { "DC_DC_OVER_TEMP", 4 },
  { "EEPROM_TIMEOUT", 8 },
  { "INIT_FAILED", 9 },
  { "NO_WARN", 0 },
  { "OUTPUT_SHORT_CIRCUIT_GUARD", 21 },
  { "PARALLEL_CIRCUIT_FAULT", 14 },
  { "PARALLEL_CLOSE_TIMEOUT", 11 },
  { "PARALLEL_START_TIMEOUT", 10 },
  { "PRECHARGE_FAILED", 12 },
  { "SAMPLE_LINE_FALL_OFF", 13 },
  { "TEMP_LOWER_LIMIT_GUARD", 20 },
  { "TEMP_UPPER_LIMIT_GUARD", 19 },
  { "VOLTAGE_LOWER_LIMIT_GUARD", 16 },
  { "VOLTAGE_UPPER_LIMIT_GUARD", 15 },
};
const ProtobufCEnumDescriptor g_im__lower_machine_warn_type__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.lower_machine_warn_type",
  "lower_machine_warn_type",
  "GIm__LowerMachineWarnType",
  "g_im",
  25,
  g_im__lower_machine_warn_type__enum_values_by_number,
  25,
  g_im__lower_machine_warn_type__enum_values_by_name,
  1,
  g_im__lower_machine_warn_type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__lower_machine_arm_fault_type__enum_values_by_number[21] =
{
  { "ARM_NO_FAULT", "G_IM__LOWER_MACHINE_ARM_FAULT_TYPE__ARM_NO_FAULT", 0 },
  { "LOST_LOCK", "G_IM__LOWER_MACHINE_ARM_FAULT_TYPE__LOST_LOCK", 1 },
  { "LOST_SIGNAL", "G_IM__LOWER_MACHINE_ARM_FAULT_TYPE__LOST_SIGNAL", 2 },
  { "FREQUENCY_ERROR", "G_IM__LOWER_MACHINE_ARM_FAULT_TYPE__FREQUENCY_ERROR", 3 },
  { "SIP_DISCONNECT", "G_IM__LOWER_MACHINE_ARM_FAULT_TYPE__SIP_DISCONNECT", 4 },
  { "ASSERT_FAILED", "G_IM__LOWER_MACHINE_ARM_FAULT_TYPE__ASSERT_FAILED", 5 },
  { "ACDC_WARNING", "G_IM__LOWER_MACHINE_ARM_FAULT_TYPE__ACDC_WARNING", 6 },
  { "MAC_CONFLICT", "G_IM__LOWER_MACHINE_ARM_FAULT_TYPE__MAC_CONFLICT", 7 },
  { "START_TIMEOUT", "G_IM__LOWER_MACHINE_ARM_FAULT_TYPE__START_TIMEOUT", 8 },
  { "STOP_TIMEOUT", "G_IM__LOWER_MACHINE_ARM_FAULT_TYPE__STOP_TIMEOUT", 9 },
  { "ESTOP_PROTECT", "G_IM__LOWER_MACHINE_ARM_FAULT_TYPE__ESTOP_PROTECT", 10 },
  { "CAN_FAULT", "G_IM__LOWER_MACHINE_ARM_FAULT_TYPE__CAN_FAULT", 11 },
  { "NETWORK_FAULT", "G_IM__LOWER_MACHINE_ARM_FAULT_TYPE__NETWORK_FAULT", 12 },
  { "CELL_VOL_BOARD_COMM_FAILED", "G_IM__LOWER_MACHINE_ARM_FAULT_TYPE__CELL_VOL_BOARD_COMM_FAILED", 13 },
  { "EAR_VOL_BOARD_COMM_FAILED", "G_IM__LOWER_MACHINE_ARM_FAULT_TYPE__EAR_VOL_BOARD_COMM_FAILED", 14 },
  { "AC_DC_COMM_DISCONNECT", "G_IM__LOWER_MACHINE_ARM_FAULT_TYPE__AC_DC_COMM_DISCONNECT", 15 },
  { "CHANNEL_COMM_FAILED", "G_IM__LOWER_MACHINE_ARM_FAULT_TYPE__CHANNEL_COMM_FAILED", 32 },
  { "STEP_SETTING_ERROR", "G_IM__LOWER_MACHINE_ARM_FAULT_TYPE__STEP_SETTING_ERROR", 33 },
  { "CHANNEL_BATTERY_REVERSAL", "G_IM__LOWER_MACHINE_ARM_FAULT_TYPE__CHANNEL_BATTERY_REVERSAL", 34 },
  { "CHANNEL_BATTERY_GUARD_OR_DROPPED", "G_IM__LOWER_MACHINE_ARM_FAULT_TYPE__CHANNEL_BATTERY_GUARD_OR_DROPPED", 35 },
  { "CHANNEL_HISTORY_FAULT", "G_IM__LOWER_MACHINE_ARM_FAULT_TYPE__CHANNEL_HISTORY_FAULT", 36 },
};
static const ProtobufCIntRange g_im__lower_machine_arm_fault_type__value_ranges[] = {
{0, 0},{32, 16},{0, 21}
};
static const ProtobufCEnumValueIndex g_im__lower_machine_arm_fault_type__enum_values_by_name[21] =
{
  { "ACDC_WARNING", 6 },
  { "AC_DC_COMM_DISCONNECT", 15 },
  { "ARM_NO_FAULT", 0 },
  { "ASSERT_FAILED", 5 },
  { "CAN_FAULT", 11 },
  { "CELL_VOL_BOARD_COMM_FAILED", 13 },
  { "CHANNEL_BATTERY_GUARD_OR_DROPPED", 19 },
  { "CHANNEL_BATTERY_REVERSAL", 18 },
  { "CHANNEL_COMM_FAILED", 16 },
  { "CHANNEL_HISTORY_FAULT", 20 },
  { "EAR_VOL_BOARD_COMM_FAILED", 14 },
  { "ESTOP_PROTECT", 10 },
  { "FREQUENCY_ERROR", 3 },
  { "LOST_LOCK", 1 },
  { "LOST_SIGNAL", 2 },
  { "MAC_CONFLICT", 7 },
  { "NETWORK_FAULT", 12 },
  { "SIP_DISCONNECT", 4 },
  { "START_TIMEOUT", 8 },
  { "STEP_SETTING_ERROR", 17 },
  { "STOP_TIMEOUT", 9 },
};
const ProtobufCEnumDescriptor g_im__lower_machine_arm_fault_type__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.lower_machine_arm_fault_type",
  "lower_machine_arm_fault_type",
  "GIm__LowerMachineArmFaultType",
  "g_im",
  21,
  g_im__lower_machine_arm_fault_type__enum_values_by_number,
  21,
  g_im__lower_machine_arm_fault_type__enum_values_by_name,
  2,
  g_im__lower_machine_arm_fault_type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__lower_machine_channel_fault_type__enum_values_by_number[159] =
{
  { "CHANNEL_NO_FAULT", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__CHANNEL_NO_FAULT", 0 },
  { "Input_Transient_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Input_Transient_Over_Vol", 1 },
  { "Input1_Transient_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Input1_Transient_Over_Vol", 2 },
  { "Input2_Transient_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Input2_Transient_Over_Vol", 3 },
  { "Input3_Transient_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Input3_Transient_Over_Vol", 4 },
  { "Input4_Transient_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Input4_Transient_Over_Vol", 5 },
  { "Input_Transient_Under_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Input_Transient_Under_Vol", 6 },
  { "Input1_Transient_Under_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Input1_Transient_Under_Vol", 7 },
  { "Input2_Transient_Under_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Input2_Transient_Under_Vol", 8 },
  { "Input3_Transient_Under_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Input3_Transient_Under_Vol", 9 },
  { "Input4_Transient_Under_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Input4_Transient_Under_Vol", 10 },
  { "Input_Vol1_Reversal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Input_Vol1_Reversal", 11 },
  { "Input_Vol2_Reversal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Input_Vol2_Reversal", 12 },
  { "Input_Vol3_Reversal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Input_Vol3_Reversal", 13 },
  { "Input_Vol4_Reversal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Input_Vol4_Reversal", 14 },
  { "Input_Vol_Sample_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Input_Vol_Sample_Abnormal", 15 },
  { "Input_Vol_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Input_Vol_Over_Vol", 16 },
  { "Input_Vol_Reversal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Input_Vol_Reversal", 17 },
  { "LCur_P_Transient_Over_Cur", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__LCur_P_Transient_Over_Cur", 20 },
  { "LCur_N_Transient_Over_Cur", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__LCur_N_Transient_Over_Cur", 21 },
  { "Output_Vol_P_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Output_Vol_P_Over_Vol", 22 },
  { "Output_Vol_N_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Output_Vol_N_Over_Vol", 23 },
  { "ADC_Comm_Fault", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__ADC_Comm_Fault", 24 },
  { "Output_Short_Circuit", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Output_Short_Circuit", 25 },
  { "Vol_Over_Upper_Limit", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Vol_Over_Upper_Limit", 26 },
  { "Temp_Over_Upper_Limit", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Temp_Over_Upper_Limit", 27 },
  { "Cur_Over_Upper_Limit", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Cur_Over_Upper_Limit", 28 },
  { "Vol_Under_Lower_Limit", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Vol_Under_Lower_Limit", 29 },
  { "Cur_Under_Lower_Limit", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Cur_Under_Lower_Limit", 30 },
  { "Output_Cur_Unbalanced", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Output_Cur_Unbalanced", 31 },
  { "Output_Transient_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Output_Transient_Over_Vol", 32 },
  { "Output_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Output_Over_Vol", 33 },
  { "Output1_Transient_OverVol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Output1_Transient_OverVol", 34 },
  { "Output2_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Output2_Over_Vol", 35 },
  { "Output3_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Output3_Over_Vol", 36 },
  { "Output4_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Output4_Over_Vol", 37 },
  { "Output1_Under_Pressure", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Output1_Under_Pressure", 38 },
  { "Output2_Under_Pressure", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Output2_Under_Pressure", 39 },
  { "Output3_Under_Pressure", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Output3_Under_Pressure", 40 },
  { "Output4_Under_Pressure", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Output4_Under_Pressure", 41 },
  { "Output_M_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Output_M_Over_Vol", 42 },
  { "Output_Vol_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Output_Vol_Over_Vol", 43 },
  { "Output_Vol_Sample_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Output_Vol_Sample_Abnormal", 47 },
  { "Auxiliary_Power_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Auxiliary_Power_Over_Vol", 48 },
  { "Auxiliary_Power_Under_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Auxiliary_Power_Under_Vol", 49 },
  { "Signal_Line_Connect_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Signal_Line_Connect_Abnormal", 50 },
  { "Signal_Line_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Signal_Line_Abnormal", 51 },
  { "Env_Temp_Over_Temp", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Env_Temp_Over_Temp", 52 },
  { "Battery_Temp_Over_Temp", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Battery_Temp_Over_Temp", 53 },
  { "Cooler_Over_Temp", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Cooler_Over_Temp", 54 },
  { "Cooler1_Over_Temp", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Cooler1_Over_Temp", 55 },
  { "Cooler2_Over_Temp", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Cooler2_Over_Temp", 56 },
  { "Cooler3_Over_Temp", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Cooler3_Over_Temp", 57 },
  { "Cooler4_Over_Temp", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Cooler4_Over_Temp", 58 },
  { "Temp_Sample_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Temp_Sample_Abnormal", 59 },
  { "Board_Temp_Over_Temp", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Board_Temp_Over_Temp", 60 },
  { "Parallel_Channel_Fault", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Parallel_Channel_Fault", 61 },
  { "Parallel_Channel_Cell_Vol_Sample_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Parallel_Channel_Cell_Vol_Sample_Abnormal", 62 },
  { "Parallel_Channel_Out_Sync", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Parallel_Channel_Out_Sync", 63 },
  { "Fan_Fault", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Fan_Fault", 64 },
  { "Fan1_Fault", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Fan1_Fault", 65 },
  { "Fan2_Fault", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Fan2_Fault", 66 },
  { "Fan3_Fault", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Fan3_Fault", 67 },
  { "Fan4_Fault", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Fan4_Fault", 68 },
  { "Fan5_Fault", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Fan5_Fault", 69 },
  { "Fan6_Fault", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Fan6_Fault", 70 },
  { "Power_Grid_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Power_Grid_Over_Vol", 80 },
  { "Power_Grid_Under_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Power_Grid_Under_Vol", 81 },
  { "Power_Grid_Over_Freq", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Power_Grid_Over_Freq", 82 },
  { "Power_Grid_Under_Freq", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Power_Grid_Under_Freq", 83 },
  { "Power_Grid_Over_Cur", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Power_Grid_Over_Cur", 84 },
  { "Power_Grid_Transient_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Power_Grid_Transient_Over_Vol", 85 },
  { "Power_Grid_Power_Down", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Power_Grid_Power_Down", 86 },
  { "Power_Grid_Freq_Detect_Failed", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Power_Grid_Freq_Detect_Failed", 87 },
  { "Power_Grid_Phase_Detect_Failed", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Power_Grid_Phase_Detect_Failed", 88 },
  { "Power_Grid_Phase_Unbalanced", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Power_Grid_Phase_Unbalanced", 89 },
  { "Power_Grid_Lock_Phase_Failed", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Power_Grid_Lock_Phase_Failed", 90 },
  { "Power_Grid_Phase_Lost_Lock", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Power_Grid_Phase_Lost_Lock", 91 },
  { "Power_Grid_AC_Short_Circuit", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Power_Grid_AC_Short_Circuit", 92 },
  { "PWM_Island_Protection", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_Island_Protection", 93 },
  { "PWM_LCur_Over_Cur", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_LCur_Over_Cur", 94 },
  { "PWM_LCur_Overload", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_LCur_Overload", 95 },
  { "PWM_Soft_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_Soft_Over_Vol", 96 },
  { "PWM_Transient_Soft_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_Transient_Soft_Over_Vol", 97 },
  { "PWM_Soft_Under_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_Soft_Under_Vol", 98 },
  { "PWM_Hard_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_Hard_Over_Vol", 99 },
  { "PWM_DC_Over_Cur", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_DC_Over_Cur", 100 },
  { "PWM_DC_Soft_Over_Cur", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_DC_Soft_Over_Cur", 101 },
  { "PWM_DC_Overload", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_DC_Overload", 102 },
  { "PWM_PSB_Hard_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_PSB_Hard_Over_Vol", 103 },
  { "PWM_PSB_Transient_Soft_Under_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_PSB_Transient_Soft_Under_Vol", 104 },
  { "PWM_PSB_Soft_Under_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_PSB_Soft_Under_Vol", 105 },
  { "PWM_PSB_Hard_Over_Cur", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_PSB_Hard_Over_Cur", 106 },
  { "PWM_PSB_Transient_Soft_Over_Cur", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_PSB_Transient_Soft_Over_Cur", 107 },
  { "PWM_PSB_Hard_Over_Cur_OrOver_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_PSB_Hard_Over_Cur_OrOver_Vol", 108 },
  { "PWM_Cooler_Over_Temp", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_Cooler_Over_Temp", 112 },
  { "PWM_Cooler1_Over_Temp", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_Cooler1_Over_Temp", 113 },
  { "PWM_Cooler2_Over_Temp", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_Cooler2_Over_Temp", 114 },
  { "PWM_Cooler3_Over_Temp", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_Cooler3_Over_Temp", 115 },
  { "PWM_Env_Temp_Over_Tem", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_Env_Temp_Over_Tem", 116 },
  { "PWM_Start_Failed", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_Start_Failed", 117 },
  { "PWM_Comm_Disconnect", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_Comm_Disconnect", 118 },
  { "PWM_WB_Dischare_Failed", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_WB_Dischare_Failed", 119 },
  { "PWM_Auxiliary_Power_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_Auxiliary_Power_Over_Vol", 120 },
  { "PWM_Auxiliary_Power_Under_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_Auxiliary_Power_Under_Vol", 121 },
  { "PWM_DC_Vol_Sample_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_DC_Vol_Sample_Abnormal", 122 },
  { "PWM_DC_Cur_Sample_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_DC_Cur_Sample_Abnormal", 123 },
  { "PWM_AC_Vol_Sample_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_AC_Vol_Sample_Abnormal", 124 },
  { "PWM_AC_Cur_Sample_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_AC_Cur_Sample_Abnormal", 125 },
  { "PWM_DSP_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_DSP_Abnormal", 128 },
  { "PWM_GND_Error", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_GND_Error", 129 },
  { "PWM_EStop", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_EStop", 130 },
  { "PWM_IGBT_Over_Cur", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_IGBT_Over_Cur", 131 },
  { "PWM_Status_Invalid", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_Status_Invalid", 132 },
  { "PWM_Status_Engine_Invalid", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_Status_Engine_Invalid", 133 },
  { "LCur_P_Hard_Over_Cur", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__LCur_P_Hard_Over_Cur", 160 },
  { "LCur_N_Hard_Over_Cur", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__LCur_N_Hard_Over_Cur", 161 },
  { "LCur_Hard_Over_Cur", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__LCur_Hard_Over_Cur", 162 },
  { "DC_Cur_Hard_Over_Cur", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__DC_Cur_Hard_Over_Cur", 163 },
  { "Single_Cur_Hard_Over_Cur", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Single_Cur_Hard_Over_Cur", 164 },
  { "Cur_Hard_Over_Cur", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Cur_Hard_Over_Cur", 165 },
  { "DC_Cur_Transient_Over_Cur", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__DC_Cur_Transient_Over_Cur", 166 },
  { "LCur_Transient_Over_Cur", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__LCur_Transient_Over_Cur", 167 },
  { "LCur1_Transient_Over_Cur", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__LCur1_Transient_Over_Cur", 168 },
  { "LCur2_Transient_Over_Cur", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__LCur2_Transient_Over_Cur", 169 },
  { "LCur3_Transient_Over_Cur", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__LCur3_Transient_Over_Cur", 170 },
  { "LCur4_Transient_Over_Cur", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__LCur4_Transient_Over_Cur", 171 },
  { "Output_Sample_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Output_Sample_Abnormal", 174 },
  { "LCur_Sample_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__LCur_Sample_Abnormal", 175 },
  { "PWM1_Comm_Alarm", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM1_Comm_Alarm", 177 },
  { "PWM2_Comm_Alarm", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM2_Comm_Alarm", 178 },
  { "PWM3_Comm_Alarm", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM3_Comm_Alarm", 179 },
  { "PWM1_Comm_Disconnect", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM1_Comm_Disconnect", 180 },
  { "PWM2_Comm_Disconnect", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM2_Comm_Disconnect", 181 },
  { "PWM3_Comm_Disconnect", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM3_Comm_Disconnect", 182 },
  { "PWB_Alarm", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWB_Alarm", 183 },
  { "PSB_Alarm", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PSB_Alarm", 184 },
  { "PWM_Module_Comm_Disconnect", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PWM_Module_Comm_Disconnect", 186 },
  { "PSB_Module_Comm_Disconnect", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__PSB_Module_Comm_Disconnect", 187 },
  { "DSP_Cell_Vol_Sample_Comm_Failed", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__DSP_Cell_Vol_Sample_Comm_Failed", 188 },
  { "Cell_Sample_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Cell_Sample_Abnormal", 189 },
  { "Free_Cur_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Free_Cur_Abnormal", 190 },
  { "Start_Failed", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Start_Failed", 191 },
  { "Eeprom_Param_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Eeprom_Param_Abnormal", 192 },
  { "Battery_Vol_Sample_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Battery_Vol_Sample_Abnormal", 193 },
  { "Output_Soft_Start_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Output_Soft_Start_Abnormal", 194 },
  { "IO_Balace_Failed", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__IO_Balace_Failed", 195 },
  { "LCur1_Sample_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__LCur1_Sample_Abnormal", 196 },
  { "LCur2_Sample_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__LCur2_Sample_Abnormal", 197 },
  { "LCur3_Sample_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__LCur3_Sample_Abnormal", 198 },
  { "LCur4_Sample_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__LCur4_Sample_Abnormal", 199 },
  { "DSP_Lost_Lock", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__DSP_Lost_Lock", 200 },
  { "Output_Reversal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Output_Reversal", 201 },
  { "Output_Vol_P_Check_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Output_Vol_P_Check_Abnormal", 202 },
  { "Output_Vol_N_Check_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Output_Vol_N_Check_Abnormal", 203 },
  { "Monomer_Over_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Monomer_Over_Vol", 204 },
  { "Monomer_Under_Vol", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Monomer_Under_Vol", 205 },
  { "Output_PreCharge_Abnormal", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Output_PreCharge_Abnormal", 206 },
  { "Duty_Ratio_Over_Limit", "G_IM__LOWER_MACHINE_CHANNEL_FAULT_TYPE__Duty_Ratio_Over_Limit", 207 },
};
static const ProtobufCIntRange g_im__lower_machine_channel_fault_type__value_ranges[] = {
{0, 0},{20, 18},{47, 42},{80, 66},{112, 95},{128, 109},{160, 115},{174, 127},{177, 129},{186, 137},{0, 159}
};
static const ProtobufCEnumValueIndex g_im__lower_machine_channel_fault_type__enum_values_by_name[159] =
{
  { "ADC_Comm_Fault", 22 },
  { "Auxiliary_Power_Over_Vol", 43 },
  { "Auxiliary_Power_Under_Vol", 44 },
  { "Battery_Temp_Over_Temp", 48 },
  { "Battery_Vol_Sample_Abnormal", 144 },
  { "Board_Temp_Over_Temp", 55 },
  { "CHANNEL_NO_FAULT", 0 },
  { "Cell_Sample_Abnormal", 140 },
  { "Cooler1_Over_Temp", 50 },
  { "Cooler2_Over_Temp", 51 },
  { "Cooler3_Over_Temp", 52 },
  { "Cooler4_Over_Temp", 53 },
  { "Cooler_Over_Temp", 49 },
  { "Cur_Hard_Over_Cur", 120 },
  { "Cur_Over_Upper_Limit", 26 },
  { "Cur_Under_Lower_Limit", 28 },
  { "DC_Cur_Hard_Over_Cur", 118 },
  { "DC_Cur_Transient_Over_Cur", 121 },
  { "DSP_Cell_Vol_Sample_Comm_Failed", 139 },
  { "DSP_Lost_Lock", 151 },
  { "Duty_Ratio_Over_Limit", 158 },
  { "Eeprom_Param_Abnormal", 143 },
  { "Env_Temp_Over_Temp", 47 },
  { "Fan1_Fault", 60 },
  { "Fan2_Fault", 61 },
  { "Fan3_Fault", 62 },
  { "Fan4_Fault", 63 },
  { "Fan5_Fault", 64 },
  { "Fan6_Fault", 65 },
  { "Fan_Fault", 59 },
  { "Free_Cur_Abnormal", 141 },
  { "IO_Balace_Failed", 146 },
  { "Input1_Transient_Over_Vol", 2 },
  { "Input1_Transient_Under_Vol", 7 },
  { "Input2_Transient_Over_Vol", 3 },
  { "Input2_Transient_Under_Vol", 8 },
  { "Input3_Transient_Over_Vol", 4 },
  { "Input3_Transient_Under_Vol", 9 },
  { "Input4_Transient_Over_Vol", 5 },
  { "Input4_Transient_Under_Vol", 10 },
  { "Input_Transient_Over_Vol", 1 },
  { "Input_Transient_Under_Vol", 6 },
  { "Input_Vol1_Reversal", 11 },
  { "Input_Vol2_Reversal", 12 },
  { "Input_Vol3_Reversal", 13 },
  { "Input_Vol4_Reversal", 14 },
  { "Input_Vol_Over_Vol", 16 },
  { "Input_Vol_Reversal", 17 },
  { "Input_Vol_Sample_Abnormal", 15 },
  { "LCur1_Sample_Abnormal", 147 },
  { "LCur1_Transient_Over_Cur", 123 },
  { "LCur2_Sample_Abnormal", 148 },
  { "LCur2_Transient_Over_Cur", 124 },
  { "LCur3_Sample_Abnormal", 149 },
  { "LCur3_Transient_Over_Cur", 125 },
  { "LCur4_Sample_Abnormal", 150 },
  { "LCur4_Transient_Over_Cur", 126 },
  { "LCur_Hard_Over_Cur", 117 },
  { "LCur_N_Hard_Over_Cur", 116 },
  { "LCur_N_Transient_Over_Cur", 19 },
  { "LCur_P_Hard_Over_Cur", 115 },
  { "LCur_P_Transient_Over_Cur", 18 },
  { "LCur_Sample_Abnormal", 128 },
  { "LCur_Transient_Over_Cur", 122 },
  { "Monomer_Over_Vol", 155 },
  { "Monomer_Under_Vol", 156 },
  { "Output1_Transient_OverVol", 32 },
  { "Output1_Under_Pressure", 36 },
  { "Output2_Over_Vol", 33 },
  { "Output2_Under_Pressure", 37 },
  { "Output3_Over_Vol", 34 },
  { "Output3_Under_Pressure", 38 },
  { "Output4_Over_Vol", 35 },
  { "Output4_Under_Pressure", 39 },
  { "Output_Cur_Unbalanced", 29 },
  { "Output_M_Over_Vol", 40 },
  { "Output_Over_Vol", 31 },
  { "Output_PreCharge_Abnormal", 157 },
  { "Output_Reversal", 152 },
  { "Output_Sample_Abnormal", 127 },
  { "Output_Short_Circuit", 23 },
  { "Output_Soft_Start_Abnormal", 145 },
  { "Output_Transient_Over_Vol", 30 },
  { "Output_Vol_N_Check_Abnormal", 154 },
  { "Output_Vol_N_Over_Vol", 21 },
  { "Output_Vol_Over_Vol", 41 },
  { "Output_Vol_P_Check_Abnormal", 153 },
  { "Output_Vol_P_Over_Vol", 20 },
  { "Output_Vol_Sample_Abnormal", 42 },
  { "PSB_Alarm", 136 },
  { "PSB_Module_Comm_Disconnect", 138 },
  { "PWB_Alarm", 135 },
  { "PWM1_Comm_Alarm", 129 },
  { "PWM1_Comm_Disconnect", 132 },
  { "PWM2_Comm_Alarm", 130 },
  { "PWM2_Comm_Disconnect", 133 },
  { "PWM3_Comm_Alarm", 131 },
  { "PWM3_Comm_Disconnect", 134 },
  { "PWM_AC_Cur_Sample_Abnormal", 108 },
  { "PWM_AC_Vol_Sample_Abnormal", 107 },
  { "PWM_Auxiliary_Power_Over_Vol", 103 },
  { "PWM_Auxiliary_Power_Under_Vol", 104 },
  { "PWM_Comm_Disconnect", 101 },
  { "PWM_Cooler1_Over_Temp", 96 },
  { "PWM_Cooler2_Over_Temp", 97 },
  { "PWM_Cooler3_Over_Temp", 98 },
  { "PWM_Cooler_Over_Temp", 95 },
  { "PWM_DC_Cur_Sample_Abnormal", 106 },
  { "PWM_DC_Over_Cur", 86 },
  { "PWM_DC_Overload", 88 },
  { "PWM_DC_Soft_Over_Cur", 87 },
  { "PWM_DC_Vol_Sample_Abnormal", 105 },
  { "PWM_DSP_Abnormal", 109 },
  { "PWM_EStop", 111 },
  { "PWM_Env_Temp_Over_Tem", 99 },
  { "PWM_GND_Error", 110 },
  { "PWM_Hard_Over_Vol", 85 },
  { "PWM_IGBT_Over_Cur", 112 },
  { "PWM_Island_Protection", 79 },
  { "PWM_LCur_Over_Cur", 80 },
  { "PWM_LCur_Overload", 81 },
  { "PWM_Module_Comm_Disconnect", 137 },
  { "PWM_PSB_Hard_Over_Cur", 92 },
  { "PWM_PSB_Hard_Over_Cur_OrOver_Vol", 94 },
  { "PWM_PSB_Hard_Over_Vol", 89 },
  { "PWM_PSB_Soft_Under_Vol", 91 },
  { "PWM_PSB_Transient_Soft_Over_Cur", 93 },
  { "PWM_PSB_Transient_Soft_Under_Vol", 90 },
  { "PWM_Soft_Over_Vol", 82 },
  { "PWM_Soft_Under_Vol", 84 },
  { "PWM_Start_Failed", 100 },
  { "PWM_Status_Engine_Invalid", 114 },
  { "PWM_Status_Invalid", 113 },
  { "PWM_Transient_Soft_Over_Vol", 83 },
  { "PWM_WB_Dischare_Failed", 102 },
  { "Parallel_Channel_Cell_Vol_Sample_Abnormal", 57 },
  { "Parallel_Channel_Fault", 56 },
  { "Parallel_Channel_Out_Sync", 58 },
  { "Power_Grid_AC_Short_Circuit", 78 },
  { "Power_Grid_Freq_Detect_Failed", 73 },
  { "Power_Grid_Lock_Phase_Failed", 76 },
  { "Power_Grid_Over_Cur", 70 },
  { "Power_Grid_Over_Freq", 68 },
  { "Power_Grid_Over_Vol", 66 },
  { "Power_Grid_Phase_Detect_Failed", 74 },
  { "Power_Grid_Phase_Lost_Lock", 77 },
  { "Power_Grid_Phase_Unbalanced", 75 },
  { "Power_Grid_Power_Down", 72 },
  { "Power_Grid_Transient_Over_Vol", 71 },
  { "Power_Grid_Under_Freq", 69 },
  { "Power_Grid_Under_Vol", 67 },
  { "Signal_Line_Abnormal", 46 },
  { "Signal_Line_Connect_Abnormal", 45 },
  { "Single_Cur_Hard_Over_Cur", 119 },
  { "Start_Failed", 142 },
  { "Temp_Over_Upper_Limit", 25 },
  { "Temp_Sample_Abnormal", 54 },
  { "Vol_Over_Upper_Limit", 24 },
  { "Vol_Under_Lower_Limit", 27 },
};
const ProtobufCEnumDescriptor g_im__lower_machine_channel_fault_type__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.lower_machine_channel_fault_type",
  "lower_machine_channel_fault_type",
  "GIm__LowerMachineChannelFaultType",
  "g_im",
  159,
  g_im__lower_machine_channel_fault_type__enum_values_by_number,
  159,
  g_im__lower_machine_channel_fault_type__enum_values_by_name,
  10,
  g_im__lower_machine_channel_fault_type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__adjust_power_mode__enum_values_by_number[5] =
{
  { "AUTO_PARALLEL", "G_IM__ADJUST_POWER_MODE__AUTO_PARALLEL", 0 },
  { "SERIES_MODULE", "G_IM__ADJUST_POWER_MODE__SERIES_MODULE", 1 },
  { "SERIES_CELL", "G_IM__ADJUST_POWER_MODE__SERIES_CELL", 2 },
  { "CV_SERIES_MODULE", "G_IM__ADJUST_POWER_MODE__CV_SERIES_MODULE", 3 },
  { "CV_SERIES_CELL", "G_IM__ADJUST_POWER_MODE__CV_SERIES_CELL", 4 },
};
static const ProtobufCIntRange g_im__adjust_power_mode__value_ranges[] = {
{0, 0},{0, 5}
};
static const ProtobufCEnumValueIndex g_im__adjust_power_mode__enum_values_by_name[5] =
{
  { "AUTO_PARALLEL", 0 },
  { "CV_SERIES_CELL", 4 },
  { "CV_SERIES_MODULE", 3 },
  { "SERIES_CELL", 2 },
  { "SERIES_MODULE", 1 },
};
const ProtobufCEnumDescriptor g_im__adjust_power_mode__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.adjust_power_mode",
  "adjust_power_mode",
  "GIm__AdjustPowerMode",
  "g_im",
  5,
  g_im__adjust_power_mode__enum_values_by_number,
  5,
  g_im__adjust_power_mode__enum_values_by_name,
  1,
  g_im__adjust_power_mode__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__device_state__enum_values_by_number[7] =
{
  { "NORMAL", "G_IM__DEVICE_STATE__NORMAL", 0 },
  { "ABNORMAL", "G_IM__DEVICE_STATE__ABNORMAL", 1 },
  { "COMMNUNICATION_ERROR", "G_IM__DEVICE_STATE__COMMNUNICATION_ERROR", 2 },
  { "CONFIG_ERROR", "G_IM__DEVICE_STATE__CONFIG_ERROR", 3 },
  { "DISCONNECTION", "G_IM__DEVICE_STATE__DISCONNECTION", 4 },
  { "LOCKED_ROTOR", "G_IM__DEVICE_STATE__LOCKED_ROTOR", 5 },
  { "TEMPERATURE_ABNORMAL", "G_IM__DEVICE_STATE__TEMPERATURE_ABNORMAL", 6 },
};
static const ProtobufCIntRange g_im__device_state__value_ranges[] = {
{0, 0},{0, 7}
};
static const ProtobufCEnumValueIndex g_im__device_state__enum_values_by_name[7] =
{
  { "ABNORMAL", 1 },
  { "COMMNUNICATION_ERROR", 2 },
  { "CONFIG_ERROR", 3 },
  { "DISCONNECTION", 4 },
  { "LOCKED_ROTOR", 5 },
  { "NORMAL", 0 },
  { "TEMPERATURE_ABNORMAL", 6 },
};
const ProtobufCEnumDescriptor g_im__device_state__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.device_state",
  "device_state",
  "GIm__DeviceState",
  "g_im",
  7,
  g_im__device_state__enum_values_by_number,
  7,
  g_im__device_state__enum_values_by_name,
  1,
  g_im__device_state__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__door_state__enum_values_by_number[4] =
{
  { "DOOR_STATE_UNKNOWN", "G_IM__DOOR_STATE__DOOR_STATE_UNKNOWN", 0 },
  { "DOOR_STATE_OPEN", "G_IM__DOOR_STATE__DOOR_STATE_OPEN", 1 },
  { "DOOR_STATE_CLOSE", "G_IM__DOOR_STATE__DOOR_STATE_CLOSE", 2 },
  { "DOOR_STATE_FOREIGN_BODY", "G_IM__DOOR_STATE__DOOR_STATE_FOREIGN_BODY", 3 },
};
static const ProtobufCIntRange g_im__door_state__value_ranges[] = {
{0, 0},{0, 4}
};
static const ProtobufCEnumValueIndex g_im__door_state__enum_values_by_name[4] =
{
  { "DOOR_STATE_CLOSE", 2 },
  { "DOOR_STATE_FOREIGN_BODY", 3 },
  { "DOOR_STATE_OPEN", 1 },
  { "DOOR_STATE_UNKNOWN", 0 },
};
const ProtobufCEnumDescriptor g_im__door_state__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.door_state",
  "door_state",
  "GIm__DoorState",
  "g_im",
  4,
  g_im__door_state__enum_values_by_number,
  4,
  g_im__door_state__enum_values_by_name,
  1,
  g_im__door_state__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__accessdoor_state__enum_values_by_number[3] =
{
  { "ACCESSDOOR_DOOR_UNKNOWN", "G_IM__ACCESSDOOR_STATE__ACCESSDOOR_DOOR_UNKNOWN", 0 },
  { "ACCESSDOOR_DOOR_OPEN", "G_IM__ACCESSDOOR_STATE__ACCESSDOOR_DOOR_OPEN", 1 },
  { "ACCESSDOOR_DOOR_CLOSE", "G_IM__ACCESSDOOR_STATE__ACCESSDOOR_DOOR_CLOSE", 2 },
};
static const ProtobufCIntRange g_im__accessdoor_state__value_ranges[] = {
{0, 0},{0, 3}
};
static const ProtobufCEnumValueIndex g_im__accessdoor_state__enum_values_by_name[3] =
{
  { "ACCESSDOOR_DOOR_CLOSE", 2 },
  { "ACCESSDOOR_DOOR_OPEN", 1 },
  { "ACCESSDOOR_DOOR_UNKNOWN", 0 },
};
const ProtobufCEnumDescriptor g_im__accessdoor_state__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.accessdoor_state",
  "accessdoor_state",
  "GIm__AccessdoorState",
  "g_im",
  3,
  g_im__accessdoor_state__enum_values_by_number,
  3,
  g_im__accessdoor_state__enum_values_by_name,
  1,
  g_im__accessdoor_state__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__tray_state__enum_values_by_number[4] =
{
  { "TRAY_STATE_UNKNOWN", "G_IM__TRAY_STATE__TRAY_STATE_UNKNOWN", 0 },
  { "TRAY_STATE_NOTINPLACE", "G_IM__TRAY_STATE__TRAY_STATE_NOTINPLACE", 1 },
  { "TRAY_STATE_ABNORMAL", "G_IM__TRAY_STATE__TRAY_STATE_ABNORMAL", 6 },
  { "TRAY_STATE_PUT_IN_PLACE", "G_IM__TRAY_STATE__TRAY_STATE_PUT_IN_PLACE", 8 },
};
static const ProtobufCIntRange g_im__tray_state__value_ranges[] = {
{0, 0},{6, 2},{8, 3},{0, 4}
};
static const ProtobufCEnumValueIndex g_im__tray_state__enum_values_by_name[4] =
{
  { "TRAY_STATE_ABNORMAL", 2 },
  { "TRAY_STATE_NOTINPLACE", 1 },
  { "TRAY_STATE_PUT_IN_PLACE", 3 },
  { "TRAY_STATE_UNKNOWN", 0 },
};
const ProtobufCEnumDescriptor g_im__tray_state__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.tray_state",
  "tray_state",
  "GIm__TrayState",
  "g_im",
  4,
  g_im__tray_state__enum_values_by_number,
  4,
  g_im__tray_state__enum_values_by_name,
  3,
  g_im__tray_state__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__needlebed_state__enum_values_by_number[3] =
{
  { "NEEDLEBED_STATE_UNKNOWN", "G_IM__NEEDLEBED_STATE__NEEDLEBED_STATE_UNKNOWN", 0 },
  { "NEEDLEBED_STATE_NOTINPLACE", "G_IM__NEEDLEBED_STATE__NEEDLEBED_STATE_NOTINPLACE", 1 },
  { "NEEDLEBED_STATE_INPLACE", "G_IM__NEEDLEBED_STATE__NEEDLEBED_STATE_INPLACE", 2 },
};
static const ProtobufCIntRange g_im__needlebed_state__value_ranges[] = {
{0, 0},{0, 3}
};
static const ProtobufCEnumValueIndex g_im__needlebed_state__enum_values_by_name[3] =
{
  { "NEEDLEBED_STATE_INPLACE", 2 },
  { "NEEDLEBED_STATE_NOTINPLACE", 1 },
  { "NEEDLEBED_STATE_UNKNOWN", 0 },
};
const ProtobufCEnumDescriptor g_im__needlebed_state__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.needlebed_state",
  "needlebed_state",
  "GIm__NeedlebedState",
  "g_im",
  3,
  g_im__needlebed_state__enum_values_by_number,
  3,
  g_im__needlebed_state__enum_values_by_name,
  1,
  g_im__needlebed_state__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__firedoor_state__enum_values_by_number[8] =
{
  { "FIREDOOR_STATE_UNKNOWN", "G_IM__FIREDOOR_STATE__FIREDOOR_STATE_UNKNOWN", 0 },
  { "FIREDOOR_STATE_OPENING", "G_IM__FIREDOOR_STATE__FIREDOOR_STATE_OPENING", 1 },
  { "FIREDOOR_STATE_OPEN", "G_IM__FIREDOOR_STATE__FIREDOOR_STATE_OPEN", 2 },
  { "FIREDOOR_STATE_CLOSEING", "G_IM__FIREDOOR_STATE__FIREDOOR_STATE_CLOSEING", 3 },
  { "FIREDOOR_STATE_CLOSE", "G_IM__FIREDOOR_STATE__FIREDOOR_STATE_CLOSE", 4 },
  { "FIREDOOR_STATE_OPEN_TIMEOUT", "G_IM__FIREDOOR_STATE__FIREDOOR_STATE_OPEN_TIMEOUT", 5 },
  { "FIREDOOR_STATE_CLOSE_TIMEOUT", "G_IM__FIREDOOR_STATE__FIREDOOR_STATE_CLOSE_TIMEOUT", 6 },
  { "FIREDOOR_STATE_ABNORMAL", "G_IM__FIREDOOR_STATE__FIREDOOR_STATE_ABNORMAL", 7 },
};
static const ProtobufCIntRange g_im__firedoor_state__value_ranges[] = {
{0, 0},{0, 8}
};
static const ProtobufCEnumValueIndex g_im__firedoor_state__enum_values_by_name[8] =
{
  { "FIREDOOR_STATE_ABNORMAL", 7 },
  { "FIREDOOR_STATE_CLOSE", 4 },
  { "FIREDOOR_STATE_CLOSEING", 3 },
  { "FIREDOOR_STATE_CLOSE_TIMEOUT", 6 },
  { "FIREDOOR_STATE_OPEN", 2 },
  { "FIREDOOR_STATE_OPENING", 1 },
  { "FIREDOOR_STATE_OPEN_TIMEOUT", 5 },
  { "FIREDOOR_STATE_UNKNOWN", 0 },
};
const ProtobufCEnumDescriptor g_im__firedoor_state__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.firedoor_state",
  "firedoor_state",
  "GIm__FiredoorState",
  "g_im",
  8,
  g_im__firedoor_state__enum_values_by_number,
  8,
  g_im__firedoor_state__enum_values_by_name,
  1,
  g_im__firedoor_state__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__scapegoat_state__enum_values_by_number[3] =
{
  { "SCAPEGOAT_STATE_UNKNOWN", "G_IM__SCAPEGOAT_STATE__SCAPEGOAT_STATE_UNKNOWN", 0 },
  { "SCAPEGOAT_STATE_IN_PLACE", "G_IM__SCAPEGOAT_STATE__SCAPEGOAT_STATE_IN_PLACE", 1 },
  { "SCAPEGOAT_STATE_NOT_IN_PLACE", "G_IM__SCAPEGOAT_STATE__SCAPEGOAT_STATE_NOT_IN_PLACE", 2 },
};
static const ProtobufCIntRange g_im__scapegoat_state__value_ranges[] = {
{0, 0},{0, 3}
};
static const ProtobufCEnumValueIndex g_im__scapegoat_state__enum_values_by_name[3] =
{
  { "SCAPEGOAT_STATE_IN_PLACE", 1 },
  { "SCAPEGOAT_STATE_NOT_IN_PLACE", 2 },
  { "SCAPEGOAT_STATE_UNKNOWN", 0 },
};
const ProtobufCEnumDescriptor g_im__scapegoat_state__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.scapegoat_state",
  "scapegoat_state",
  "GIm__ScapegoatState",
  "g_im",
  3,
  g_im__scapegoat_state__enum_values_by_number,
  3,
  g_im__scapegoat_state__enum_values_by_name,
  1,
  g_im__scapegoat_state__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__reservoir_state__enum_values_by_number[5] =
{
  { "RESERVOIR_UNKNOWN", "G_IM__RESERVOIR_STATE__RESERVOIR_UNKNOWN", 0 },
  { "RESERVOIR_UNDER", "G_IM__RESERVOIR_STATE__RESERVOIR_UNDER", 1 },
  { "RESERVOIR_ALREADY_FULL", "G_IM__RESERVOIR_STATE__RESERVOIR_ALREADY_FULL", 2 },
  { "RESERVOIR_DISCHARGEING", "G_IM__RESERVOIR_STATE__RESERVOIR_DISCHARGEING", 3 },
  { "RESERVOIR_DISCHARGE_ABNORMAL", "G_IM__RESERVOIR_STATE__RESERVOIR_DISCHARGE_ABNORMAL", 4 },
};
static const ProtobufCIntRange g_im__reservoir_state__value_ranges[] = {
{0, 0},{0, 5}
};
static const ProtobufCEnumValueIndex g_im__reservoir_state__enum_values_by_name[5] =
{
  { "RESERVOIR_ALREADY_FULL", 2 },
  { "RESERVOIR_DISCHARGEING", 3 },
  { "RESERVOIR_DISCHARGE_ABNORMAL", 4 },
  { "RESERVOIR_UNDER", 1 },
  { "RESERVOIR_UNKNOWN", 0 },
};
const ProtobufCEnumDescriptor g_im__reservoir_state__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.reservoir_state",
  "reservoir_state",
  "GIm__ReservoirState",
  "g_im",
  5,
  g_im__reservoir_state__enum_values_by_number,
  5,
  g_im__reservoir_state__enum_values_by_name,
  1,
  g_im__reservoir_state__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__negativepressure_action__enum_values_by_number[10] =
{
  { "NEGATIVEPRESSURE_ACTION_READY", "G_IM__NEGATIVEPRESSURE_ACTION__NEGATIVEPRESSURE_ACTION_READY", 0 },
  { "NEGATIVEPRESSURE_ACTION_BLOCKTEST_ABNORMAL", "G_IM__NEGATIVEPRESSURE_ACTION__NEGATIVEPRESSURE_ACTION_BLOCKTEST_ABNORMAL", 1 },
  { "NEGATIVEPRESSURE_ACTION_LEAKTESTING_ABNORMAL", "G_IM__NEGATIVEPRESSURE_ACTION__NEGATIVEPRESSURE_ACTION_LEAKTESTING_ABNORMAL", 2 },
  { "NEGATIVEPRESSURE_ACTION_DISCHARGEING_ABNORMAL", "G_IM__NEGATIVEPRESSURE_ACTION__NEGATIVEPRESSURE_ACTION_DISCHARGEING_ABNORMAL", 3 },
  { "NEGATIVEPRESSURE_ACTION_BLOCKTESTING", "G_IM__NEGATIVEPRESSURE_ACTION__NEGATIVEPRESSURE_ACTION_BLOCKTESTING", 4 },
  { "NEGATIVEPRESSURE_ACTION_BLOCKTEST_COMPLETE", "G_IM__NEGATIVEPRESSURE_ACTION__NEGATIVEPRESSURE_ACTION_BLOCKTEST_COMPLETE", 5 },
  { "NEGATIVEPRESSURE_ACTION_LEAKTESTING", "G_IM__NEGATIVEPRESSURE_ACTION__NEGATIVEPRESSURE_ACTION_LEAKTESTING", 6 },
  { "NEGATIVEPRESSURE_ACTION_LEAKTESTING_COMPLETE", "G_IM__NEGATIVEPRESSURE_ACTION__NEGATIVEPRESSURE_ACTION_LEAKTESTING_COMPLETE", 7 },
  { "NEGATIVEPRESSURE_ACTION_DISCHARGEING", "G_IM__NEGATIVEPRESSURE_ACTION__NEGATIVEPRESSURE_ACTION_DISCHARGEING", 8 },
  { "NEGATIVEPRESSURE_ACTION_DISCHARGEING_COMPLETE", "G_IM__NEGATIVEPRESSURE_ACTION__NEGATIVEPRESSURE_ACTION_DISCHARGEING_COMPLETE", 9 },
};
static const ProtobufCIntRange g_im__negativepressure_action__value_ranges[] = {
{0, 0},{0, 10}
};
static const ProtobufCEnumValueIndex g_im__negativepressure_action__enum_values_by_name[10] =
{
  { "NEGATIVEPRESSURE_ACTION_BLOCKTESTING", 4 },
  { "NEGATIVEPRESSURE_ACTION_BLOCKTEST_ABNORMAL", 1 },
  { "NEGATIVEPRESSURE_ACTION_BLOCKTEST_COMPLETE", 5 },
  { "NEGATIVEPRESSURE_ACTION_DISCHARGEING", 8 },
  { "NEGATIVEPRESSURE_ACTION_DISCHARGEING_ABNORMAL", 3 },
  { "NEGATIVEPRESSURE_ACTION_DISCHARGEING_COMPLETE", 9 },
  { "NEGATIVEPRESSURE_ACTION_LEAKTESTING", 6 },
  { "NEGATIVEPRESSURE_ACTION_LEAKTESTING_ABNORMAL", 2 },
  { "NEGATIVEPRESSURE_ACTION_LEAKTESTING_COMPLETE", 7 },
  { "NEGATIVEPRESSURE_ACTION_READY", 0 },
};
const ProtobufCEnumDescriptor g_im__negativepressure_action__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.negativepressure_action",
  "negativepressure_action",
  "GIm__NegativepressureAction",
  "g_im",
  10,
  g_im__negativepressure_action__enum_values_by_number,
  10,
  g_im__negativepressure_action__enum_values_by_name,
  1,
  g_im__negativepressure_action__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__negativepressure_operation_items__enum_values_by_number[9] =
{
  { "NEGATIVEPRESSURE_FAIL_ITEMS_NORMAL", "G_IM__NEGATIVEPRESSURE_OPERATION_ITEMS__NEGATIVEPRESSURE_FAIL_ITEMS_NORMAL", 0 },
  { "NEGATIVEPRESSURE_FAIL_ITEMS_SET_FAIL", "G_IM__NEGATIVEPRESSURE_OPERATION_ITEMS__NEGATIVEPRESSURE_FAIL_ITEMS_SET_FAIL", 1 },
  { "NEGATIVEPRESSURE_FAIL_ITEMS_Suction_Fail", "G_IM__NEGATIVEPRESSURE_OPERATION_ITEMS__NEGATIVEPRESSURE_FAIL_ITEMS_Suction_Fail", 2 },
  { "NEGATIVEPRESSURE_FAIL_ITEMS_Close_Suction_Fail", "G_IM__NEGATIVEPRESSURE_OPERATION_ITEMS__NEGATIVEPRESSURE_FAIL_ITEMS_Close_Suction_Fail", 3 },
  { "NEGATIVEPRESSURE_FAIL_ITEMS_Open_Breaked_Fail", "G_IM__NEGATIVEPRESSURE_OPERATION_ITEMS__NEGATIVEPRESSURE_FAIL_ITEMS_Open_Breaked_Fail", 4 },
  { "NEGATIVEPRESSURE_FAIL_ITEMS_Close_Breaked_Fail", "G_IM__NEGATIVEPRESSURE_OPERATION_ITEMS__NEGATIVEPRESSURE_FAIL_ITEMS_Close_Breaked_Fail", 5 },
  { "NEGATIVEPRESSURE_FAIL_ITEMS_Res_Read_Fail", "G_IM__NEGATIVEPRESSURE_OPERATION_ITEMS__NEGATIVEPRESSURE_FAIL_ITEMS_Res_Read_Fail", 6 },
  { "NEGATIVEPRESSURE_FAIL_ITEMS_Judge_Fail", "G_IM__NEGATIVEPRESSURE_OPERATION_ITEMS__NEGATIVEPRESSURE_FAIL_ITEMS_Judge_Fail", 7 },
  { "NEGATIVEPRESSURE_FAIL_ITEMS_Judge_Leakage_Rate_Fail", "G_IM__NEGATIVEPRESSURE_OPERATION_ITEMS__NEGATIVEPRESSURE_FAIL_ITEMS_Judge_Leakage_Rate_Fail", 8 },
};
static const ProtobufCIntRange g_im__negativepressure_operation_items__value_ranges[] = {
{0, 0},{0, 9}
};
static const ProtobufCEnumValueIndex g_im__negativepressure_operation_items__enum_values_by_name[9] =
{
  { "NEGATIVEPRESSURE_FAIL_ITEMS_Close_Breaked_Fail", 5 },
  { "NEGATIVEPRESSURE_FAIL_ITEMS_Close_Suction_Fail", 3 },
  { "NEGATIVEPRESSURE_FAIL_ITEMS_Judge_Fail", 7 },
  { "NEGATIVEPRESSURE_FAIL_ITEMS_Judge_Leakage_Rate_Fail", 8 },
  { "NEGATIVEPRESSURE_FAIL_ITEMS_NORMAL", 0 },
  { "NEGATIVEPRESSURE_FAIL_ITEMS_Open_Breaked_Fail", 4 },
  { "NEGATIVEPRESSURE_FAIL_ITEMS_Res_Read_Fail", 6 },
  { "NEGATIVEPRESSURE_FAIL_ITEMS_SET_FAIL", 1 },
  { "NEGATIVEPRESSURE_FAIL_ITEMS_Suction_Fail", 2 },
};
const ProtobufCEnumDescriptor g_im__negativepressure_operation_items__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.negativepressure_operation_items",
  "negativepressure_operation_items",
  "GIm__NegativepressureOperationItems",
  "g_im",
  9,
  g_im__negativepressure_operation_items__enum_values_by_number,
  9,
  g_im__negativepressure_operation_items__enum_values_by_name,
  1,
  g_im__negativepressure_operation_items__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__serucrity_reset_state__enum_values_by_number[3] =
{
  { "SERUCRITY_NORMAL", "G_IM__SERUCRITY_RESET_STATE__SERUCRITY_NORMAL", 0 },
  { "SERUCRITY_WAITING_RESET", "G_IM__SERUCRITY_RESET_STATE__SERUCRITY_WAITING_RESET", 1 },
  { "SECONDARY_HAS_RESET", "G_IM__SERUCRITY_RESET_STATE__SECONDARY_HAS_RESET", 2 },
};
static const ProtobufCIntRange g_im__serucrity_reset_state__value_ranges[] = {
{0, 0},{0, 3}
};
static const ProtobufCEnumValueIndex g_im__serucrity_reset_state__enum_values_by_name[3] =
{
  { "SECONDARY_HAS_RESET", 2 },
  { "SERUCRITY_NORMAL", 0 },
  { "SERUCRITY_WAITING_RESET", 1 },
};
const ProtobufCEnumDescriptor g_im__serucrity_reset_state__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.serucrity_reset_state",
  "serucrity_reset_state",
  "GIm__SerucrityResetState",
  "g_im",
  3,
  g_im__serucrity_reset_state__enum_values_by_number,
  3,
  g_im__serucrity_reset_state__enum_values_by_name,
  1,
  g_im__serucrity_reset_state__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__secondary_security_result_state__enum_values_by_number[3] =
{
  { "SECONDARY_SECURITY_RESULT_STATE_NOT_TRIGGER", "G_IM__SECONDARY_SECURITY_RESULT_STATE__SECONDARY_SECURITY_RESULT_STATE_NOT_TRIGGER", 0 },
  { "SECONDARY_SECURITY_RESULT_STATE_TRIGGER_SUCCESS", "G_IM__SECONDARY_SECURITY_RESULT_STATE__SECONDARY_SECURITY_RESULT_STATE_TRIGGER_SUCCESS", 1 },
  { "SECONDARY_SECURITY_RESULT_STATE_TRIGGER_FAIL", "G_IM__SECONDARY_SECURITY_RESULT_STATE__SECONDARY_SECURITY_RESULT_STATE_TRIGGER_FAIL", 2 },
};
static const ProtobufCIntRange g_im__secondary_security_result_state__value_ranges[] = {
{0, 0},{0, 3}
};
static const ProtobufCEnumValueIndex g_im__secondary_security_result_state__enum_values_by_name[3] =
{
  { "SECONDARY_SECURITY_RESULT_STATE_NOT_TRIGGER", 0 },
  { "SECONDARY_SECURITY_RESULT_STATE_TRIGGER_FAIL", 2 },
  { "SECONDARY_SECURITY_RESULT_STATE_TRIGGER_SUCCESS", 1 },
};
const ProtobufCEnumDescriptor g_im__secondary_security_result_state__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.secondary_security_result_state",
  "secondary_security_result_state",
  "GIm__SecondarySecurityResultState",
  "g_im",
  3,
  g_im__secondary_security_result_state__enum_values_by_number,
  3,
  g_im__secondary_security_result_state__enum_values_by_name,
  1,
  g_im__secondary_security_result_state__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__plc_status__enum_values_by_number[9] =
{
  { "PLC_STATUS_UNKNOWN", "G_IM__PLC_STATUS__PLC_STATUS_UNKNOWN", 0 },
  { "PLC_STATUS_NORMAL", "G_IM__PLC_STATUS__PLC_STATUS_NORMAL", 1 },
  { "PLC_STATUS_ABNORMAL", "G_IM__PLC_STATUS__PLC_STATUS_ABNORMAL", 2 },
  { "PLC_STATUS_ESTOP", "G_IM__PLC_STATUS__PLC_STATUS_ESTOP", 4 },
  { "PLC_STATUS_POWERON", "G_IM__PLC_STATUS__PLC_STATUS_POWERON", 5 },
  { "PLC_STATUS_FIRE_FIGHTING", "G_IM__PLC_STATUS__PLC_STATUS_FIRE_FIGHTING", 6 },
  { "PLC_STATUS_NOT_RESET", "G_IM__PLC_STATUS__PLC_STATUS_NOT_RESET", 7 },
  { "PLC_STATUS_SINGLE_STEP", "G_IM__PLC_STATUS__PLC_STATUS_SINGLE_STEP", 8 },
  { "PLC_STATUS_COMMNUNICATION_ABNORMAL", "G_IM__PLC_STATUS__PLC_STATUS_COMMNUNICATION_ABNORMAL", 9 },
};
static const ProtobufCIntRange g_im__plc_status__value_ranges[] = {
{0, 0},{4, 3},{0, 9}
};
static const ProtobufCEnumValueIndex g_im__plc_status__enum_values_by_name[9] =
{
  { "PLC_STATUS_ABNORMAL", 2 },
  { "PLC_STATUS_COMMNUNICATION_ABNORMAL", 8 },
  { "PLC_STATUS_ESTOP", 3 },
  { "PLC_STATUS_FIRE_FIGHTING", 5 },
  { "PLC_STATUS_NORMAL", 1 },
  { "PLC_STATUS_NOT_RESET", 6 },
  { "PLC_STATUS_POWERON", 4 },
  { "PLC_STATUS_SINGLE_STEP", 7 },
  { "PLC_STATUS_UNKNOWN", 0 },
};
const ProtobufCEnumDescriptor g_im__plc_status__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.plc_status",
  "plc_status",
  "GIm__PlcStatus",
  "g_im",
  9,
  g_im__plc_status__enum_values_by_number,
  9,
  g_im__plc_status__enum_values_by_name,
  2,
  g_im__plc_status__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__lowercomputer_status__enum_values_by_number[6] =
{
  { "LOWERCOMPUTER_STATUS_UNKNOWN", "G_IM__LOWERCOMPUTER_STATUS__LOWERCOMPUTER_STATUS_UNKNOWN", 0 },
  { "LOWERCOMPUTER_STATUS_DCDC_ABNORMAL", "G_IM__LOWERCOMPUTER_STATUS__LOWERCOMPUTER_STATUS_DCDC_ABNORMAL", 1 },
  { "LOWERCOMPUTER_STATUS_CP_MODULE_ABNORMAL", "G_IM__LOWERCOMPUTER_STATUS__LOWERCOMPUTER_STATUS_CP_MODULE_ABNORMAL", 2 },
  { "LOWERCOMPUTER_STATUS_COLLECT_MODULE_ABNORMA", "G_IM__LOWERCOMPUTER_STATUS__LOWERCOMPUTER_STATUS_COLLECT_MODULE_ABNORMA", 3 },
  { "LOWERCOMPUTER_STATUS_DCDC_MODULE_IOVER", "G_IM__LOWERCOMPUTER_STATUS__LOWERCOMPUTER_STATUS_DCDC_MODULE_IOVER", 4 },
  { "LOWERCOMPUTER_STATUS_DCDC_MODULE_IOVERL", "G_IM__LOWERCOMPUTER_STATUS__LOWERCOMPUTER_STATUS_DCDC_MODULE_IOVERL", 5 },
};
static const ProtobufCIntRange g_im__lowercomputer_status__value_ranges[] = {
{0, 0},{0, 6}
};
static const ProtobufCEnumValueIndex g_im__lowercomputer_status__enum_values_by_name[6] =
{
  { "LOWERCOMPUTER_STATUS_COLLECT_MODULE_ABNORMA", 3 },
  { "LOWERCOMPUTER_STATUS_CP_MODULE_ABNORMAL", 2 },
  { "LOWERCOMPUTER_STATUS_DCDC_ABNORMAL", 1 },
  { "LOWERCOMPUTER_STATUS_DCDC_MODULE_IOVER", 4 },
  { "LOWERCOMPUTER_STATUS_DCDC_MODULE_IOVERL", 5 },
  { "LOWERCOMPUTER_STATUS_UNKNOWN", 0 },
};
const ProtobufCEnumDescriptor g_im__lowercomputer_status__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.lowercomputer_status",
  "lowercomputer_status",
  "GIm__LowercomputerStatus",
  "g_im",
  6,
  g_im__lowercomputer_status__enum_values_by_number,
  6,
  g_im__lowercomputer_status__enum_values_by_name,
  1,
  g_im__lowercomputer_status__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__stock_model__enum_values_by_number[3] =
{
  { "STOCK_MODEL_UNKNOWN", "G_IM__STOCK_MODEL__STOCK_MODEL_UNKNOWN", 0 },
  { "STOCK_MODEL_AUTO", "G_IM__STOCK_MODEL__STOCK_MODEL_AUTO", 1 },
  { "STOCK_MODEL_MANUAL", "G_IM__STOCK_MODEL__STOCK_MODEL_MANUAL", 2 },
};
static const ProtobufCIntRange g_im__stock_model__value_ranges[] = {
{0, 0},{0, 3}
};
static const ProtobufCEnumValueIndex g_im__stock_model__enum_values_by_name[3] =
{
  { "STOCK_MODEL_AUTO", 1 },
  { "STOCK_MODEL_MANUAL", 2 },
  { "STOCK_MODEL_UNKNOWN", 0 },
};
const ProtobufCEnumDescriptor g_im__stock_model__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.stock_model",
  "stock_model",
  "GIm__StockModel",
  "g_im",
  3,
  g_im__stock_model__enum_values_by_number,
  3,
  g_im__stock_model__enum_values_by_name,
  1,
  g_im__stock_model__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__security_runing_state__enum_values_by_number[4] =
{
  { "SECURITY_STATE_ENABLE", "G_IM__SECURITY_RUNING_STATE__SECURITY_STATE_ENABLE", 0 },
  { "SECURITY_STATE_DISABLE", "G_IM__SECURITY_RUNING_STATE__SECURITY_STATE_DISABLE", 1 },
  { "SECURITY_STATE_DISABLESOME", "G_IM__SECURITY_RUNING_STATE__SECURITY_STATE_DISABLESOME", 2 },
  { "SECURITY_STATE_NORESET", "G_IM__SECURITY_RUNING_STATE__SECURITY_STATE_NORESET", 3 },
};
static const ProtobufCIntRange g_im__security_runing_state__value_ranges[] = {
{0, 0},{0, 4}
};
static const ProtobufCEnumValueIndex g_im__security_runing_state__enum_values_by_name[4] =
{
  { "SECURITY_STATE_DISABLE", 1 },
  { "SECURITY_STATE_DISABLESOME", 2 },
  { "SECURITY_STATE_ENABLE", 0 },
  { "SECURITY_STATE_NORESET", 3 },
};
const ProtobufCEnumDescriptor g_im__security_runing_state__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.security_runing_state",
  "security_runing_state",
  "GIm__SecurityRuningState",
  "g_im",
  4,
  g_im__security_runing_state__enum_values_by_number,
  4,
  g_im__security_runing_state__enum_values_by_name,
  1,
  g_im__security_runing_state__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__electric_ball_valve_state__enum_values_by_number[3] =
{
  { "ELECTRIC_BALL_VALVE_STATE_UNKNOWN", "G_IM__ELECTRIC_BALL_VALVE_STATE__ELECTRIC_BALL_VALVE_STATE_UNKNOWN", 0 },
  { "ELECTRIC_BALL_VALVE_STATE_CLOSE", "G_IM__ELECTRIC_BALL_VALVE_STATE__ELECTRIC_BALL_VALVE_STATE_CLOSE", 1 },
  { "ELECTRIC_BALL_VALVE_STATE_OPEN", "G_IM__ELECTRIC_BALL_VALVE_STATE__ELECTRIC_BALL_VALVE_STATE_OPEN", 2 },
};
static const ProtobufCIntRange g_im__electric_ball_valve_state__value_ranges[] = {
{0, 0},{0, 3}
};
static const ProtobufCEnumValueIndex g_im__electric_ball_valve_state__enum_values_by_name[3] =
{
  { "ELECTRIC_BALL_VALVE_STATE_CLOSE", 1 },
  { "ELECTRIC_BALL_VALVE_STATE_OPEN", 2 },
  { "ELECTRIC_BALL_VALVE_STATE_UNKNOWN", 0 },
};
const ProtobufCEnumDescriptor g_im__electric_ball_valve_state__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.electric_ball_valve_state",
  "electric_ball_valve_state",
  "GIm__ElectricBallValveState",
  "g_im",
  3,
  g_im__electric_ball_valve_state__enum_values_by_number,
  3,
  g_im__electric_ball_valve_state__enum_values_by_name,
  1,
  g_im__electric_ball_valve_state__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__deviece_update_status__enum_values_by_number[4] =
{
  { "UPDATE_STATUS_SUCCESS", "G_IM__DEVIECE_UPDATE_STATUS__UPDATE_STATUS_SUCCESS", 0 },
  { "UPDATE_STATUS_FAIL", "G_IM__DEVIECE_UPDATE_STATUS__UPDATE_STATUS_FAIL", 1 },
  { "UPDATE_STATUS_RUNNING", "G_IM__DEVIECE_UPDATE_STATUS__UPDATE_STATUS_RUNNING", 2 },
  { "UPDATE_STATUS_UNKNOWN", "G_IM__DEVIECE_UPDATE_STATUS__UPDATE_STATUS_UNKNOWN", 100 },
};
static const ProtobufCIntRange g_im__deviece_update_status__value_ranges[] = {
{0, 0},{100, 3},{0, 4}
};
static const ProtobufCEnumValueIndex g_im__deviece_update_status__enum_values_by_name[4] =
{
  { "UPDATE_STATUS_FAIL", 1 },
  { "UPDATE_STATUS_RUNNING", 2 },
  { "UPDATE_STATUS_SUCCESS", 0 },
  { "UPDATE_STATUS_UNKNOWN", 3 },
};
const ProtobufCEnumDescriptor g_im__deviece_update_status__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.deviece_update_status",
  "deviece_update_status",
  "GIm__DevieceUpdateStatus",
  "g_im",
  4,
  g_im__deviece_update_status__enum_values_by_number,
  4,
  g_im__deviece_update_status__enum_values_by_name,
  2,
  g_im__deviece_update_status__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__deviece_update_errorcode__enum_values_by_number[3] =
{
  { "UPDATE_RESULT_UNKNOWN", "G_IM__DEVIECE_UPDATE_ERRORCODE__UPDATE_RESULT_UNKNOWN", 0 },
  { "UPDATE_RESULT_FILECHECK_ERROR", "G_IM__DEVIECE_UPDATE_ERRORCODE__UPDATE_RESULT_FILECHECK_ERROR", 1 },
  { "UPDATE_RESULT_LINK_OVERTIME", "G_IM__DEVIECE_UPDATE_ERRORCODE__UPDATE_RESULT_LINK_OVERTIME", 2 },
};
static const ProtobufCIntRange g_im__deviece_update_errorcode__value_ranges[] = {
{0, 0},{0, 3}
};
static const ProtobufCEnumValueIndex g_im__deviece_update_errorcode__enum_values_by_name[3] =
{
  { "UPDATE_RESULT_FILECHECK_ERROR", 1 },
  { "UPDATE_RESULT_LINK_OVERTIME", 2 },
  { "UPDATE_RESULT_UNKNOWN", 0 },
};
const ProtobufCEnumDescriptor g_im__deviece_update_errorcode__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.deviece_update_errorcode",
  "deviece_update_errorcode",
  "GIm__DevieceUpdateErrorcode",
  "g_im",
  3,
  g_im__deviece_update_errorcode__enum_values_by_number,
  3,
  g_im__deviece_update_errorcode__enum_values_by_name,
  1,
  g_im__deviece_update_errorcode__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__device_upgrade_type__enum_values_by_number[5] =
{
  { "DEVICE_UPDATE_UNKNOWN", "G_IM__DEVICE_UPGRADE_TYPE__DEVICE_UPDATE_UNKNOWN", 0 },
  { "DEVICE_UPDATE_END", "G_IM__DEVICE_UPGRADE_TYPE__DEVICE_UPDATE_END", 1 },
  { "DEVICE_UPDATE_RUN", "G_IM__DEVICE_UPGRADE_TYPE__DEVICE_UPDATE_RUN", 2 },
  { "DEVICE_UPDATE_HEARTBEAT", "G_IM__DEVICE_UPGRADE_TYPE__DEVICE_UPDATE_HEARTBEAT", 3 },
  { "DEVICE_GET_VERSION", "G_IM__DEVICE_UPGRADE_TYPE__DEVICE_GET_VERSION", 4 },
};
static const ProtobufCIntRange g_im__device_upgrade_type__value_ranges[] = {
{0, 0},{0, 5}
};
static const ProtobufCEnumValueIndex g_im__device_upgrade_type__enum_values_by_name[5] =
{
  { "DEVICE_GET_VERSION", 4 },
  { "DEVICE_UPDATE_END", 1 },
  { "DEVICE_UPDATE_HEARTBEAT", 3 },
  { "DEVICE_UPDATE_RUN", 2 },
  { "DEVICE_UPDATE_UNKNOWN", 0 },
};
const ProtobufCEnumDescriptor g_im__device_upgrade_type__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.device_upgrade_type",
  "device_upgrade_type",
  "GIm__DeviceUpgradeType",
  "g_im",
  5,
  g_im__device_upgrade_type__enum_values_by_number,
  5,
  g_im__device_upgrade_type__enum_values_by_name,
  1,
  g_im__device_upgrade_type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__security_transfer_model__enum_values_by_number[2] =
{
  { "ONLY_STATE_CHANGE", "G_IM__SECURITY_TRANSFER_MODEL__ONLY_STATE_CHANGE", 0 },
  { "REAL_TIME", "G_IM__SECURITY_TRANSFER_MODEL__REAL_TIME", 1 },
};
static const ProtobufCIntRange g_im__security_transfer_model__value_ranges[] = {
{0, 0},{0, 2}
};
static const ProtobufCEnumValueIndex g_im__security_transfer_model__enum_values_by_name[2] =
{
  { "ONLY_STATE_CHANGE", 0 },
  { "REAL_TIME", 1 },
};
const ProtobufCEnumDescriptor g_im__security_transfer_model__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.security_transfer_model",
  "security_transfer_model",
  "GIm__SecurityTransferModel",
  "g_im",
  2,
  g_im__security_transfer_model__enum_values_by_number,
  2,
  g_im__security_transfer_model__enum_values_by_name,
  1,
  g_im__security_transfer_model__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__workjust_type__enum_values_by_number[13] =
{
  { "WORKJUST_TYPE_UNKNOWN", "G_IM__WORKJUST_TYPE__WORKJUST_TYPE_UNKNOWN", 0 },
  { "WORKJUST_TYPE_TEMPERATURE", "G_IM__WORKJUST_TYPE__WORKJUST_TYPE_TEMPERATURE", 1 },
  { "WORKJUST_TYPE_LINESEQUENCE", "G_IM__WORKJUST_TYPE__WORKJUST_TYPE_LINESEQUENCE", 2 },
  { "WORKJUST_TYPE_ACCURACY", "G_IM__WORKJUST_TYPE__WORKJUST_TYPE_ACCURACY", 3 },
  { "WORKJUST_TYPE_LINESEQUENCELEAKDETECTION", "G_IM__WORKJUST_TYPE__WORKJUST_TYPE_LINESEQUENCELEAKDETECTION", 4 },
  { "WORKJUST_TYPE_POWERLEAKDETECTION", "G_IM__WORKJUST_TYPE__WORKJUST_TYPE_POWERLEAKDETECTION", 5 },
  { "WORKJUST_TYPE_LOCATEFS", "G_IM__WORKJUST_TYPE__WORKJUST_TYPE_LOCATEFS", 31 },
  { "WORKJUST_TYPE_UnplugNozzle", "G_IM__WORKJUST_TYPE__WORKJUST_TYPE_UnplugNozzle", 32 },
  { "WORKJUST_TYPE_PlugNozzle", "G_IM__WORKJUST_TYPE__WORKJUST_TYPE_PlugNozzle", 33 },
  { "WORKJUST_TYPE_NegativePressureFlow", "G_IM__WORKJUST_TYPE__WORKJUST_TYPE_NegativePressureFlow", 34 },
  { "WORKJUST_TYPE_CleanNegativePressureCup", "G_IM__WORKJUST_TYPE__WORKJUST_TYPE_CleanNegativePressureCup", 35 },
  { "WORKJUST_TYPE_LocateGs", "G_IM__WORKJUST_TYPE__WORKJUST_TYPE_LocateGs", 36 },
  { "WORKJUST_TYPE_LeakDetection", "G_IM__WORKJUST_TYPE__WORKJUST_TYPE_LeakDetection", 37 },
};
static const ProtobufCIntRange g_im__workjust_type__value_ranges[] = {
{0, 0},{31, 6},{0, 13}
};
static const ProtobufCEnumValueIndex g_im__workjust_type__enum_values_by_name[13] =
{
  { "WORKJUST_TYPE_ACCURACY", 3 },
  { "WORKJUST_TYPE_CleanNegativePressureCup", 10 },
  { "WORKJUST_TYPE_LINESEQUENCE", 2 },
  { "WORKJUST_TYPE_LINESEQUENCELEAKDETECTION", 4 },
  { "WORKJUST_TYPE_LOCATEFS", 6 },
  { "WORKJUST_TYPE_LeakDetection", 12 },
  { "WORKJUST_TYPE_LocateGs", 11 },
  { "WORKJUST_TYPE_NegativePressureFlow", 9 },
  { "WORKJUST_TYPE_POWERLEAKDETECTION", 5 },
  { "WORKJUST_TYPE_PlugNozzle", 8 },
  { "WORKJUST_TYPE_TEMPERATURE", 1 },
  { "WORKJUST_TYPE_UNKNOWN", 0 },
  { "WORKJUST_TYPE_UnplugNozzle", 7 },
};
const ProtobufCEnumDescriptor g_im__workjust_type__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.workjust_type",
  "workjust_type",
  "GIm__WorkjustType",
  "g_im",
  13,
  g_im__workjust_type__enum_values_by_number,
  13,
  g_im__workjust_type__enum_values_by_name,
  2,
  g_im__workjust_type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__stock_state__enum_values_by_number[3] =
{
  { "STOCK_STATE_DISABLE", "G_IM__STOCK_STATE__STOCK_STATE_DISABLE", 0 },
  { "STOCK_STATE_AUTO", "G_IM__STOCK_STATE__STOCK_STATE_AUTO", 1 },
  { "STOCK_STATE_MAINTAINED", "G_IM__STOCK_STATE__STOCK_STATE_MAINTAINED", 2 },
};
static const ProtobufCIntRange g_im__stock_state__value_ranges[] = {
{0, 0},{0, 3}
};
static const ProtobufCEnumValueIndex g_im__stock_state__enum_values_by_name[3] =
{
  { "STOCK_STATE_AUTO", 1 },
  { "STOCK_STATE_DISABLE", 0 },
  { "STOCK_STATE_MAINTAINED", 2 },
};
const ProtobufCEnumDescriptor g_im__stock_state__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.stock_state",
  "stock_state",
  "GIm__StockState",
  "g_im",
  3,
  g_im__stock_state__enum_values_by_number,
  3,
  g_im__stock_state__enum_values_by_name,
  1,
  g_im__stock_state__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__execute_result__enum_values_by_number[3] =
{
  { "SUCCESS", "G_IM__EXECUTE_RESULT__SUCCESS", 0 },
  { "FAIL", "G_IM__EXECUTE_RESULT__FAIL", 1 },
  { "CANCEL", "G_IM__EXECUTE_RESULT__CANCEL", 2 },
};
static const ProtobufCIntRange g_im__execute_result__value_ranges[] = {
{0, 0},{0, 3}
};
static const ProtobufCEnumValueIndex g_im__execute_result__enum_values_by_name[3] =
{
  { "CANCEL", 2 },
  { "FAIL", 1 },
  { "SUCCESS", 0 },
};
const ProtobufCEnumDescriptor g_im__execute_result__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.execute_result",
  "execute_result",
  "GIm__ExecuteResult",
  "g_im",
  3,
  g_im__execute_result__enum_values_by_number,
  3,
  g_im__execute_result__enum_values_by_name,
  1,
  g_im__execute_result__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__negative_pressure_cmd_type__enum_values_by_number[8] =
{
  { "NEGATIVE_PRESSURE_CMD_TYPE_START", "G_IM__NEGATIVE_PRESSURE_CMD_TYPE__NEGATIVE_PRESSURE_CMD_TYPE_START", 0 },
  { "NEGATIVE_PRESSURE_CMD_TYPE_STOP", "G_IM__NEGATIVE_PRESSURE_CMD_TYPE__NEGATIVE_PRESSURE_CMD_TYPE_STOP", 1 },
  { "NEGATIVE_PRESSURE_CMD_TYPE_READ_TEST_RES", "G_IM__NEGATIVE_PRESSURE_CMD_TYPE__NEGATIVE_PRESSURE_CMD_TYPE_READ_TEST_RES", 2 },
  { "NEGATIVE_PRESSURE_CMD_TYPE_OPEN", "G_IM__NEGATIVE_PRESSURE_CMD_TYPE__NEGATIVE_PRESSURE_CMD_TYPE_OPEN", 3 },
  { "NEGATIVE_PRESSURE_CMD_TYPE_CLOSE", "G_IM__NEGATIVE_PRESSURE_CMD_TYPE__NEGATIVE_PRESSURE_CMD_TYPE_CLOSE", 4 },
  { "NEGATIVE_PRESSURE_CMD_TYPE_READ", "G_IM__NEGATIVE_PRESSURE_CMD_TYPE__NEGATIVE_PRESSURE_CMD_TYPE_READ", 5 },
  { "NEGATIVE_PRESSURE_CMD_TYPE_SET", "G_IM__NEGATIVE_PRESSURE_CMD_TYPE__NEGATIVE_PRESSURE_CMD_TYPE_SET", 6 },
  { "NEGATIVE_PRESSURE_CMD_TYPE_DECOMPRESSION", "G_IM__NEGATIVE_PRESSURE_CMD_TYPE__NEGATIVE_PRESSURE_CMD_TYPE_DECOMPRESSION", 7 },
};
static const ProtobufCIntRange g_im__negative_pressure_cmd_type__value_ranges[] = {
{0, 0},{0, 8}
};
static const ProtobufCEnumValueIndex g_im__negative_pressure_cmd_type__enum_values_by_name[8] =
{
  { "NEGATIVE_PRESSURE_CMD_TYPE_CLOSE", 4 },
  { "NEGATIVE_PRESSURE_CMD_TYPE_DECOMPRESSION", 7 },
  { "NEGATIVE_PRESSURE_CMD_TYPE_OPEN", 3 },
  { "NEGATIVE_PRESSURE_CMD_TYPE_READ", 5 },
  { "NEGATIVE_PRESSURE_CMD_TYPE_READ_TEST_RES", 2 },
  { "NEGATIVE_PRESSURE_CMD_TYPE_SET", 6 },
  { "NEGATIVE_PRESSURE_CMD_TYPE_START", 0 },
  { "NEGATIVE_PRESSURE_CMD_TYPE_STOP", 1 },
};
const ProtobufCEnumDescriptor g_im__negative_pressure_cmd_type__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.negative_pressure_cmd_type",
  "negative_pressure_cmd_type",
  "GIm__NegativePressureCmdType",
  "g_im",
  8,
  g_im__negative_pressure_cmd_type__enum_values_by_number,
  8,
  g_im__negative_pressure_cmd_type__enum_values_by_name,
  1,
  g_im__negative_pressure_cmd_type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__negative_pressure_op_res__enum_values_by_number[19] =
{
  { "NEGATIVE_PRESSURE_OP_RES_SUCC", "G_IM__NEGATIVE_PRESSURE_OP_RES__NEGATIVE_PRESSURE_OP_RES_SUCC", 0 },
  { "NEGATIVE_PRESSURE_OP_RES_SET_FAIL", "G_IM__NEGATIVE_PRESSURE_OP_RES__NEGATIVE_PRESSURE_OP_RES_SET_FAIL", 1 },
  { "NEGATIVE_PRESSURE_OP_RES_OPEN_SUCTION_FAIL", "G_IM__NEGATIVE_PRESSURE_OP_RES__NEGATIVE_PRESSURE_OP_RES_OPEN_SUCTION_FAIL", 2 },
  { "NEGATIVE_PRESSURE_OP_RES_CLOSE_SUCTION_FAIL", "G_IM__NEGATIVE_PRESSURE_OP_RES__NEGATIVE_PRESSURE_OP_RES_CLOSE_SUCTION_FAIL", 3 },
  { "NEGATIVE_PRESSURE_OP_RES_OPEN_BREAKED_FAIL", "G_IM__NEGATIVE_PRESSURE_OP_RES__NEGATIVE_PRESSURE_OP_RES_OPEN_BREAKED_FAIL", 4 },
  { "NEGATIVE_PRESSURE_OP_RES_CLOSE_BREAKED_FAIL", "G_IM__NEGATIVE_PRESSURE_OP_RES__NEGATIVE_PRESSURE_OP_RES_CLOSE_BREAKED_FAIL", 5 },
  { "NEGATIVE_PRESSURE_OP_RES_READ_FAIL", "G_IM__NEGATIVE_PRESSURE_OP_RES__NEGATIVE_PRESSURE_OP_RES_READ_FAIL", 6 },
  { "NEGATIVE_PRESSURE_OP_RES_TESTING", "G_IM__NEGATIVE_PRESSURE_OP_RES__NEGATIVE_PRESSURE_OP_RES_TESTING", 7 },
  { "NEGATIVE_PRESSURE_OP_RES_TEST_FAIL", "G_IM__NEGATIVE_PRESSURE_OP_RES__NEGATIVE_PRESSURE_OP_RES_TEST_FAIL", 8 },
  { "NEGATIVE_PRESSURE_OP_RES_LEAKAGE", "G_IM__NEGATIVE_PRESSURE_OP_RES__NEGATIVE_PRESSURE_OP_RES_LEAKAGE", 9 },
  { "NEGATIVE_PRESSURE_OP_RES_TIMEOUT", "G_IM__NEGATIVE_PRESSURE_OP_RES__NEGATIVE_PRESSURE_OP_RES_TIMEOUT", 10 },
  { "NEGATIVE_PRESSURE_OP_RES_JUDGE_FAIL", "G_IM__NEGATIVE_PRESSURE_OP_RES__NEGATIVE_PRESSURE_OP_RES_JUDGE_FAIL", 11 },
  { "NEGATIVE_PRESSURE_OP_RES_JUDGE_LEAKAGE_RATE_FAIL", "G_IM__NEGATIVE_PRESSURE_OP_RES__NEGATIVE_PRESSURE_OP_RES_JUDGE_LEAKAGE_RATE_FAIL", 12 },
  { "NEGATIVE_PRESSURE_OP_RES_PLUGGING", "G_IM__NEGATIVE_PRESSURE_OP_RES__NEGATIVE_PRESSURE_OP_RES_PLUGGING", 13 },
  { "NEGATIVE_PRESSURE_OP_RES_LEAKAGING", "G_IM__NEGATIVE_PRESSURE_OP_RES__NEGATIVE_PRESSURE_OP_RES_LEAKAGING", 14 },
  { "NEGATIVE_PRESSURE_OP_RES_DECOMPRESSING", "G_IM__NEGATIVE_PRESSURE_OP_RES__NEGATIVE_PRESSURE_OP_RES_DECOMPRESSING", 15 },
  { "NEGATIVE_PRESSURE_OP_RES_DECOMPRESSION_FAIL", "G_IM__NEGATIVE_PRESSURE_OP_RES__NEGATIVE_PRESSURE_OP_RES_DECOMPRESSION_FAIL", 16 },
  { "NEGATIVE_PRESSURE_OP_RES_CMD_INVALID", "G_IM__NEGATIVE_PRESSURE_OP_RES__NEGATIVE_PRESSURE_OP_RES_CMD_INVALID", 17 },
  { "NEGATIVE_PRESSURE_OP_RES_CONFIG_FILE_NOT_EXIST", "G_IM__NEGATIVE_PRESSURE_OP_RES__NEGATIVE_PRESSURE_OP_RES_CONFIG_FILE_NOT_EXIST", 18 },
};
static const ProtobufCIntRange g_im__negative_pressure_op_res__value_ranges[] = {
{0, 0},{0, 19}
};
static const ProtobufCEnumValueIndex g_im__negative_pressure_op_res__enum_values_by_name[19] =
{
  { "NEGATIVE_PRESSURE_OP_RES_CLOSE_BREAKED_FAIL", 5 },
  { "NEGATIVE_PRESSURE_OP_RES_CLOSE_SUCTION_FAIL", 3 },
  { "NEGATIVE_PRESSURE_OP_RES_CMD_INVALID", 17 },
  { "NEGATIVE_PRESSURE_OP_RES_CONFIG_FILE_NOT_EXIST", 18 },
  { "NEGATIVE_PRESSURE_OP_RES_DECOMPRESSING", 15 },
  { "NEGATIVE_PRESSURE_OP_RES_DECOMPRESSION_FAIL", 16 },
  { "NEGATIVE_PRESSURE_OP_RES_JUDGE_FAIL", 11 },
  { "NEGATIVE_PRESSURE_OP_RES_JUDGE_LEAKAGE_RATE_FAIL", 12 },
  { "NEGATIVE_PRESSURE_OP_RES_LEAKAGE", 9 },
  { "NEGATIVE_PRESSURE_OP_RES_LEAKAGING", 14 },
  { "NEGATIVE_PRESSURE_OP_RES_OPEN_BREAKED_FAIL", 4 },
  { "NEGATIVE_PRESSURE_OP_RES_OPEN_SUCTION_FAIL", 2 },
  { "NEGATIVE_PRESSURE_OP_RES_PLUGGING", 13 },
  { "NEGATIVE_PRESSURE_OP_RES_READ_FAIL", 6 },
  { "NEGATIVE_PRESSURE_OP_RES_SET_FAIL", 1 },
  { "NEGATIVE_PRESSURE_OP_RES_SUCC", 0 },
  { "NEGATIVE_PRESSURE_OP_RES_TESTING", 7 },
  { "NEGATIVE_PRESSURE_OP_RES_TEST_FAIL", 8 },
  { "NEGATIVE_PRESSURE_OP_RES_TIMEOUT", 10 },
};
const ProtobufCEnumDescriptor g_im__negative_pressure_op_res__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.negative_pressure_op_res",
  "negative_pressure_op_res",
  "GIm__NegativePressureOpRes",
  "g_im",
  19,
  g_im__negative_pressure_op_res__enum_values_by_number,
  19,
  g_im__negative_pressure_op_res__enum_values_by_name,
  1,
  g_im__negative_pressure_op_res__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__negative_pressure_vacuum_valve_type__enum_values_by_number[2] =
{
  { "NEGATIVE_PRESSURE_VACUUM_VALVE_TYPE_SUCTION", "G_IM__NEGATIVE_PRESSURE_VACUUM_VALVE_TYPE__NEGATIVE_PRESSURE_VACUUM_VALVE_TYPE_SUCTION", 0 },
  { "NEGATIVE_PRESSURE_VACUUM_VALVE_TYPE_BREAKED", "G_IM__NEGATIVE_PRESSURE_VACUUM_VALVE_TYPE__NEGATIVE_PRESSURE_VACUUM_VALVE_TYPE_BREAKED", 1 },
};
static const ProtobufCIntRange g_im__negative_pressure_vacuum_valve_type__value_ranges[] = {
{0, 0},{0, 2}
};
static const ProtobufCEnumValueIndex g_im__negative_pressure_vacuum_valve_type__enum_values_by_name[2] =
{
  { "NEGATIVE_PRESSURE_VACUUM_VALVE_TYPE_BREAKED", 1 },
  { "NEGATIVE_PRESSURE_VACUUM_VALVE_TYPE_SUCTION", 0 },
};
const ProtobufCEnumDescriptor g_im__negative_pressure_vacuum_valve_type__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.negative_pressure_vacuum_valve_type",
  "negative_pressure_vacuum_valve_type",
  "GIm__NegativePressureVacuumValveType",
  "g_im",
  2,
  g_im__negative_pressure_vacuum_valve_type__enum_values_by_number,
  2,
  g_im__negative_pressure_vacuum_valve_type__enum_values_by_name,
  1,
  g_im__negative_pressure_vacuum_valve_type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__version_query_chip_type__enum_values_by_number[3] =
{
  { "VERSION_QUERY_CHIP_TYPE_UNKNOWN", "G_IM__VERSION_QUERY_CHIP_TYPE__VERSION_QUERY_CHIP_TYPE_UNKNOWN", 0 },
  { "VERSION_QUERY_CHIP_TYPE_ARM", "G_IM__VERSION_QUERY_CHIP_TYPE__VERSION_QUERY_CHIP_TYPE_ARM", 1 },
  { "VERSION_QUERY_CHIP_TYPE_DSP", "G_IM__VERSION_QUERY_CHIP_TYPE__VERSION_QUERY_CHIP_TYPE_DSP", 2 },
};
static const ProtobufCIntRange g_im__version_query_chip_type__value_ranges[] = {
{0, 0},{0, 3}
};
static const ProtobufCEnumValueIndex g_im__version_query_chip_type__enum_values_by_name[3] =
{
  { "VERSION_QUERY_CHIP_TYPE_ARM", 1 },
  { "VERSION_QUERY_CHIP_TYPE_DSP", 2 },
  { "VERSION_QUERY_CHIP_TYPE_UNKNOWN", 0 },
};
const ProtobufCEnumDescriptor g_im__version_query_chip_type__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.version_query_chip_type",
  "version_query_chip_type",
  "GIm__VersionQueryChipType",
  "g_im",
  3,
  g_im__version_query_chip_type__enum_values_by_number,
  3,
  g_im__version_query_chip_type__enum_values_by_name,
  1,
  g_im__version_query_chip_type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCEnumValue g_im__version_query_type__enum_values_by_number[3] =
{
  { "VERSION_QUERY_TYPE_UNKNOWN", "G_IM__VERSION_QUERY_TYPE__VERSION_QUERY_TYPE_UNKNOWN", 0 },
  { "VERSION_QUERY_TYPE_APP_VERSION", "G_IM__VERSION_QUERY_TYPE__VERSION_QUERY_TYPE_APP_VERSION", 1 },
  { "VERSION_QUERY_TYPE_APP_NAME", "G_IM__VERSION_QUERY_TYPE__VERSION_QUERY_TYPE_APP_NAME", 2 },
};
static const ProtobufCIntRange g_im__version_query_type__value_ranges[] = {
{0, 0},{0, 3}
};
static const ProtobufCEnumValueIndex g_im__version_query_type__enum_values_by_name[3] =
{
  { "VERSION_QUERY_TYPE_APP_NAME", 2 },
  { "VERSION_QUERY_TYPE_APP_VERSION", 1 },
  { "VERSION_QUERY_TYPE_UNKNOWN", 0 },
};
const ProtobufCEnumDescriptor g_im__version_query_type__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "g_im.version_query_type",
  "version_query_type",
  "GIm__VersionQueryType",
  "g_im",
  3,
  g_im__version_query_type__enum_values_by_number,
  3,
  g_im__version_query_type__enum_values_by_name,
  1,
  g_im__version_query_type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};

const char *g_im__im_service__methods[] = {
    "/g_im.imService/im_cmd_call",
    "/g_im.imService/im_ajust_call",
    "/g_im.imService/im_debug_call",
    "/g_im.imService/im_eeprom_read",
    "/g_im.imService/im_eeprom_write",
    "/g_im.imService/im_negative_pressure_adjust_call",
    "/g_im.imService/im_adjust_call_version_query",
};

int
g_im__im_service__im_cmd_call (grpc_c_client_t *client, grpc_c_metadata_array_t *array, uint32_t flags, GIm__ImCmdRequest *input,
                                    GIm__ImCmdResponse **output, grpc_c_status_t *status, long timeout)
{
    return grpc_c_client_request_unary(client, array, flags, g_im__im_service__methods[0], (void *)input, (void **)output, status, 0, 0, &g_im__im_cmd_request_packer, &g_im__im_cmd_request_unpacker, &g_im__im_cmd_request_free, &g_im__im_cmd_response_packer, &g_im__im_cmd_response_unpacker, &g_im__im_cmd_response_free, timeout);
}

int
g_im__im_service__im_cmd_call__sync (grpc_c_client_t *client, grpc_c_metadata_array_t *array, uint32_t flags, grpc_c_context_t **context, GIm__ImCmdRequest *input, long timeout)
{
    return grpc_c_client_request_sync(client, array, flags, context, g_im__im_service__methods[0], input, 0, 0, &g_im__im_cmd_request_packer, &g_im__im_cmd_request_unpacker, &g_im__im_cmd_request_free, &g_im__im_cmd_response_packer,&g_im__im_cmd_response_unpacker, &g_im__im_cmd_response_free, timeout);
}

int
g_im__im_service__im_cmd_call__async (grpc_c_client_t *client,
                                     grpc_c_metadata_array_t *array, uint32_t flags,
                                     GIm__ImCmdRequest *input,
                                     grpc_c_client_callback_t *cb,
                                     void *tag)
{
    return grpc_c_client_request_async(client, array, flags, g_im__im_service__methods[0], input, cb, tag, 0, 0, &g_im__im_cmd_request_packer, &g_im__im_cmd_request_unpacker, &g_im__im_cmd_request_free, &g_im__im_cmd_response_packer, &g_im__im_cmd_response_unpacker, &g_im__im_cmd_response_free);
}

int
g_im__im_service__im_ajust_call (grpc_c_client_t *client, grpc_c_metadata_array_t *array, uint32_t flags, GIm__ImAjustRequest *input,
                                      GIm__ImAjustResponse **output, grpc_c_status_t *status, long timeout)
{
    return grpc_c_client_request_unary(client, array, flags, g_im__im_service__methods[1], (void *)input, (void **)output, status, 0, 0, &g_im__im_ajust_request_packer, &g_im__im_ajust_request_unpacker, &g_im__im_ajust_request_free, &g_im__im_ajust_response_packer, &g_im__im_ajust_response_unpacker, &g_im__im_ajust_response_free, timeout);
}

int
g_im__im_service__im_ajust_call__sync (grpc_c_client_t *client, grpc_c_metadata_array_t *array, uint32_t flags, grpc_c_context_t **context, GIm__ImAjustRequest *input, long timeout)
{
    return grpc_c_client_request_sync(client, array, flags, context, g_im__im_service__methods[1], input, 0, 0, &g_im__im_ajust_request_packer, &g_im__im_ajust_request_unpacker, &g_im__im_ajust_request_free, &g_im__im_ajust_response_packer,&g_im__im_ajust_response_unpacker, &g_im__im_ajust_response_free, timeout);
}

int
g_im__im_service__im_ajust_call__async (grpc_c_client_t *client,
                                       grpc_c_metadata_array_t *array, uint32_t flags,
                                       GIm__ImAjustRequest *input,
                                       grpc_c_client_callback_t *cb,
                                       void *tag)
{
    return grpc_c_client_request_async(client, array, flags, g_im__im_service__methods[1], input, cb, tag, 0, 0, &g_im__im_ajust_request_packer, &g_im__im_ajust_request_unpacker, &g_im__im_ajust_request_free, &g_im__im_ajust_response_packer, &g_im__im_ajust_response_unpacker, &g_im__im_ajust_response_free);
}

int
g_im__im_service__im_debug_call (grpc_c_client_t *client, grpc_c_metadata_array_t *array, uint32_t flags, GIm__ImDebugRequest *input,
                                      GIm__ImDebugResponse **output, grpc_c_status_t *status, long timeout)
{
    return grpc_c_client_request_unary(client, array, flags, g_im__im_service__methods[2], (void *)input, (void **)output, status, 0, 0, &g_im__im_debug_request_packer, &g_im__im_debug_request_unpacker, &g_im__im_debug_request_free, &g_im__im_debug_response_packer, &g_im__im_debug_response_unpacker, &g_im__im_debug_response_free, timeout);
}

int
g_im__im_service__im_debug_call__sync (grpc_c_client_t *client, grpc_c_metadata_array_t *array, uint32_t flags, grpc_c_context_t **context, GIm__ImDebugRequest *input, long timeout)
{
    return grpc_c_client_request_sync(client, array, flags, context, g_im__im_service__methods[2], input, 0, 0, &g_im__im_debug_request_packer, &g_im__im_debug_request_unpacker, &g_im__im_debug_request_free, &g_im__im_debug_response_packer,&g_im__im_debug_response_unpacker, &g_im__im_debug_response_free, timeout);
}

int
g_im__im_service__im_debug_call__async (grpc_c_client_t *client,
                                       grpc_c_metadata_array_t *array, uint32_t flags,
                                       GIm__ImDebugRequest *input,
                                       grpc_c_client_callback_t *cb,
                                       void *tag)
{
    return grpc_c_client_request_async(client, array, flags, g_im__im_service__methods[2], input, cb, tag, 0, 0, &g_im__im_debug_request_packer, &g_im__im_debug_request_unpacker, &g_im__im_debug_request_free, &g_im__im_debug_response_packer, &g_im__im_debug_response_unpacker, &g_im__im_debug_response_free);
}

int
g_im__im_service__im_eeprom_read (grpc_c_client_t *client, grpc_c_metadata_array_t *array, uint32_t flags, GIm__ImEepromRequest *input,
                                       GIm__ImEepromReadResponse **output, grpc_c_status_t *status, long timeout)
{
    return grpc_c_client_request_unary(client, array, flags, g_im__im_service__methods[3], (void *)input, (void **)output, status, 0, 0, &g_im__im_eeprom_request_packer, &g_im__im_eeprom_request_unpacker, &g_im__im_eeprom_request_free, &g_im__im_eeprom_read_response_packer, &g_im__im_eeprom_read_response_unpacker, &g_im__im_eeprom_read_response_free, timeout);
}

int
g_im__im_service__im_eeprom_read__sync (grpc_c_client_t *client, grpc_c_metadata_array_t *array, uint32_t flags, grpc_c_context_t **context, GIm__ImEepromRequest *input, long timeout)
{
    return grpc_c_client_request_sync(client, array, flags, context, g_im__im_service__methods[3], input, 0, 0, &g_im__im_eeprom_request_packer, &g_im__im_eeprom_request_unpacker, &g_im__im_eeprom_request_free, &g_im__im_eeprom_read_response_packer,&g_im__im_eeprom_read_response_unpacker, &g_im__im_eeprom_read_response_free, timeout);
}

int
g_im__im_service__im_eeprom_read__async (grpc_c_client_t *client,
                                        grpc_c_metadata_array_t *array, uint32_t flags,
                                        GIm__ImEepromRequest *input,
                                        grpc_c_client_callback_t *cb,
                                        void *tag)
{
    return grpc_c_client_request_async(client, array, flags, g_im__im_service__methods[3], input, cb, tag, 0, 0, &g_im__im_eeprom_request_packer, &g_im__im_eeprom_request_unpacker, &g_im__im_eeprom_request_free, &g_im__im_eeprom_read_response_packer, &g_im__im_eeprom_read_response_unpacker, &g_im__im_eeprom_read_response_free);
}

int
g_im__im_service__im_eeprom_write (grpc_c_client_t *client, grpc_c_metadata_array_t *array, uint32_t flags, GIm__ImEepromRequest *input,
                                        GIm__ImEepromWriteResponse **output, grpc_c_status_t *status, long timeout)
{
    return grpc_c_client_request_unary(client, array, flags, g_im__im_service__methods[4], (void *)input, (void **)output, status, 0, 0, &g_im__im_eeprom_request_packer, &g_im__im_eeprom_request_unpacker, &g_im__im_eeprom_request_free, &g_im__im_eeprom_write_response_packer, &g_im__im_eeprom_write_response_unpacker, &g_im__im_eeprom_write_response_free, timeout);
}

int
g_im__im_service__im_eeprom_write__sync (grpc_c_client_t *client, grpc_c_metadata_array_t *array, uint32_t flags, grpc_c_context_t **context, GIm__ImEepromRequest *input, long timeout)
{
    return grpc_c_client_request_sync(client, array, flags, context, g_im__im_service__methods[4], input, 0, 0, &g_im__im_eeprom_request_packer, &g_im__im_eeprom_request_unpacker, &g_im__im_eeprom_request_free, &g_im__im_eeprom_write_response_packer,&g_im__im_eeprom_write_response_unpacker, &g_im__im_eeprom_write_response_free, timeout);
}

int
g_im__im_service__im_eeprom_write__async (grpc_c_client_t *client,
                                         grpc_c_metadata_array_t *array, uint32_t flags,
                                         GIm__ImEepromRequest *input,
                                         grpc_c_client_callback_t *cb,
                                         void *tag)
{
    return grpc_c_client_request_async(client, array, flags, g_im__im_service__methods[4], input, cb, tag, 0, 0, &g_im__im_eeprom_request_packer, &g_im__im_eeprom_request_unpacker, &g_im__im_eeprom_request_free, &g_im__im_eeprom_write_response_packer, &g_im__im_eeprom_write_response_unpacker, &g_im__im_eeprom_write_response_free);
}

int
g_im__im_service__im_negative_pressure_adjust_call (grpc_c_client_t *client, grpc_c_metadata_array_t *array, uint32_t flags, GIm__ImNegativePressureRequest *input,
                                                         GIm__ImNegativePressureResponse **output, grpc_c_status_t *status, long timeout)
{
    return grpc_c_client_request_unary(client, array, flags, g_im__im_service__methods[5], (void *)input, (void **)output, status, 0, 0, &g_im__im_negative_pressure_request_packer, &g_im__im_negative_pressure_request_unpacker, &g_im__im_negative_pressure_request_free, &g_im__im_negative_pressure_response_packer, &g_im__im_negative_pressure_response_unpacker, &g_im__im_negative_pressure_response_free, timeout);
}

int
g_im__im_service__im_negative_pressure_adjust_call__sync (grpc_c_client_t *client, grpc_c_metadata_array_t *array, uint32_t flags, grpc_c_context_t **context, GIm__ImNegativePressureRequest *input, long timeout)
{
    return grpc_c_client_request_sync(client, array, flags, context, g_im__im_service__methods[5], input, 0, 0, &g_im__im_negative_pressure_request_packer, &g_im__im_negative_pressure_request_unpacker, &g_im__im_negative_pressure_request_free, &g_im__im_negative_pressure_response_packer,&g_im__im_negative_pressure_response_unpacker, &g_im__im_negative_pressure_response_free, timeout);
}

int
g_im__im_service__im_negative_pressure_adjust_call__async (grpc_c_client_t *client,
                                                          grpc_c_metadata_array_t *array, uint32_t flags,
                                                          GIm__ImNegativePressureRequest *input,
                                                          grpc_c_client_callback_t *cb,
                                                          void *tag)
{
    return grpc_c_client_request_async(client, array, flags, g_im__im_service__methods[5], input, cb, tag, 0, 0, &g_im__im_negative_pressure_request_packer, &g_im__im_negative_pressure_request_unpacker, &g_im__im_negative_pressure_request_free, &g_im__im_negative_pressure_response_packer, &g_im__im_negative_pressure_response_unpacker, &g_im__im_negative_pressure_response_free);
}

int
g_im__im_service__im_adjust_call_version_query (grpc_c_client_t *client, grpc_c_metadata_array_t *array, uint32_t flags, GIm__ImVersionQueryRequest *input,
                                                     GIm__ImVersionQueryResponse **output, grpc_c_status_t *status, long timeout)
{
    return grpc_c_client_request_unary(client, array, flags, g_im__im_service__methods[6], (void *)input, (void **)output, status, 0, 0, &g_im__im_version_query_request_packer, &g_im__im_version_query_request_unpacker, &g_im__im_version_query_request_free, &g_im__im_version_query_response_packer, &g_im__im_version_query_response_unpacker, &g_im__im_version_query_response_free, timeout);
}

int
g_im__im_service__im_adjust_call_version_query__sync (grpc_c_client_t *client, grpc_c_metadata_array_t *array, uint32_t flags, grpc_c_context_t **context, GIm__ImVersionQueryRequest *input, long timeout)
{
    return grpc_c_client_request_sync(client, array, flags, context, g_im__im_service__methods[6], input, 0, 0, &g_im__im_version_query_request_packer, &g_im__im_version_query_request_unpacker, &g_im__im_version_query_request_free, &g_im__im_version_query_response_packer,&g_im__im_version_query_response_unpacker, &g_im__im_version_query_response_free, timeout);
}

int
g_im__im_service__im_adjust_call_version_query__async (grpc_c_client_t *client,
                                                      grpc_c_metadata_array_t *array, uint32_t flags,
                                                      GIm__ImVersionQueryRequest *input,
                                                      grpc_c_client_callback_t *cb,
                                                      void *tag)
{
    return grpc_c_client_request_async(client, array, flags, g_im__im_service__methods[6], input, cb, tag, 0, 0, &g_im__im_version_query_request_packer, &g_im__im_version_query_request_unpacker, &g_im__im_version_query_request_free, &g_im__im_version_query_response_packer, &g_im__im_version_query_response_unpacker, &g_im__im_version_query_response_free);
}

const char *g_im__pc_service__methods[] = {
    "/g_im.pcService/ui_data_call",
    "/g_im.pcService/ui_security_call",
    "/g_im.pcService/ui_upgrade_call",
};

int
g_im__pc_service__ui_data_call (grpc_c_client_t *client, grpc_c_metadata_array_t *array, uint32_t flags, GIm__ImUiData *input,
                                     GIm__ImUiDataResponse **output, grpc_c_status_t *status, long timeout)
{
    return grpc_c_client_request_unary(client, array, flags, g_im__pc_service__methods[0], (void *)input, (void **)output, status, 0, 0, &g_im__im_ui_data_packer, &g_im__im_ui_data_unpacker, &g_im__im_ui_data_free, &g_im__im_ui_data_response_packer, &g_im__im_ui_data_response_unpacker, &g_im__im_ui_data_response_free, timeout);
}

int
g_im__pc_service__ui_data_call__sync (grpc_c_client_t *client, grpc_c_metadata_array_t *array, uint32_t flags, grpc_c_context_t **context, GIm__ImUiData *input, long timeout)
{
    return grpc_c_client_request_sync(client, array, flags, context, g_im__pc_service__methods[0], input, 0, 0, &g_im__im_ui_data_packer, &g_im__im_ui_data_unpacker, &g_im__im_ui_data_free, &g_im__im_ui_data_response_packer,&g_im__im_ui_data_response_unpacker, &g_im__im_ui_data_response_free, timeout);
}

int
g_im__pc_service__ui_data_call__async (grpc_c_client_t *client,
                                      grpc_c_metadata_array_t *array, uint32_t flags,
                                      GIm__ImUiData *input,
                                      grpc_c_client_callback_t *cb,
                                      void *tag)
{
    return grpc_c_client_request_async(client, array, flags, g_im__pc_service__methods[0], input, cb, tag, 0, 0, &g_im__im_ui_data_packer, &g_im__im_ui_data_unpacker, &g_im__im_ui_data_free, &g_im__im_ui_data_response_packer, &g_im__im_ui_data_response_unpacker, &g_im__im_ui_data_response_free);
}

int
g_im__pc_service__ui_security_call (grpc_c_client_t *client, grpc_c_metadata_array_t *array, uint32_t flags, GIm__ImSecurityData *input,
                                         GIm__ImUiDataResponse **output, grpc_c_status_t *status, long timeout)
{
    return grpc_c_client_request_unary(client, array, flags, g_im__pc_service__methods[1], (void *)input, (void **)output, status, 0, 0, &g_im__im_security_data_packer, &g_im__im_security_data_unpacker, &g_im__im_security_data_free, &g_im__im_ui_data_response_packer, &g_im__im_ui_data_response_unpacker, &g_im__im_ui_data_response_free, timeout);
}

int
g_im__pc_service__ui_security_call__sync (grpc_c_client_t *client, grpc_c_metadata_array_t *array, uint32_t flags, grpc_c_context_t **context, GIm__ImSecurityData *input, long timeout)
{
    return grpc_c_client_request_sync(client, array, flags, context, g_im__pc_service__methods[1], input, 0, 0, &g_im__im_security_data_packer, &g_im__im_security_data_unpacker, &g_im__im_security_data_free, &g_im__im_ui_data_response_packer,&g_im__im_ui_data_response_unpacker, &g_im__im_ui_data_response_free, timeout);
}

int
g_im__pc_service__ui_security_call__async (grpc_c_client_t *client,
                                          grpc_c_metadata_array_t *array, uint32_t flags,
                                          GIm__ImSecurityData *input,
                                          grpc_c_client_callback_t *cb,
                                          void *tag)
{
    return grpc_c_client_request_async(client, array, flags, g_im__pc_service__methods[1], input, cb, tag, 0, 0, &g_im__im_security_data_packer, &g_im__im_security_data_unpacker, &g_im__im_security_data_free, &g_im__im_ui_data_response_packer, &g_im__im_ui_data_response_unpacker, &g_im__im_ui_data_response_free);
}

int
g_im__pc_service__ui_upgrade_call (grpc_c_client_t *client, grpc_c_metadata_array_t *array, uint32_t flags, GIm__ImDeviceUpgradeData *input,
                                        GIm__ImUiDataResponse **output, grpc_c_status_t *status, long timeout)
{
    return grpc_c_client_request_unary(client, array, flags, g_im__pc_service__methods[2], (void *)input, (void **)output, status, 0, 0, &g_im__im_device_upgrade_data_packer, &g_im__im_device_upgrade_data_unpacker, &g_im__im_device_upgrade_data_free, &g_im__im_ui_data_response_packer, &g_im__im_ui_data_response_unpacker, &g_im__im_ui_data_response_free, timeout);
}

int
g_im__pc_service__ui_upgrade_call__sync (grpc_c_client_t *client, grpc_c_metadata_array_t *array, uint32_t flags, grpc_c_context_t **context, GIm__ImDeviceUpgradeData *input, long timeout)
{
    return grpc_c_client_request_sync(client, array, flags, context, g_im__pc_service__methods[2], input, 0, 0, &g_im__im_device_upgrade_data_packer, &g_im__im_device_upgrade_data_unpacker, &g_im__im_device_upgrade_data_free, &g_im__im_ui_data_response_packer,&g_im__im_ui_data_response_unpacker, &g_im__im_ui_data_response_free, timeout);
}

int
g_im__pc_service__ui_upgrade_call__async (grpc_c_client_t *client,
                                         grpc_c_metadata_array_t *array, uint32_t flags,
                                         GIm__ImDeviceUpgradeData *input,
                                         grpc_c_client_callback_t *cb,
                                         void *tag)
{
    return grpc_c_client_request_async(client, array, flags, g_im__pc_service__methods[2], input, cb, tag, 0, 0, &g_im__im_device_upgrade_data_packer, &g_im__im_device_upgrade_data_unpacker, &g_im__im_device_upgrade_data_free, &g_im__im_ui_data_response_packer, &g_im__im_ui_data_response_unpacker, &g_im__im_ui_data_response_free);
}
